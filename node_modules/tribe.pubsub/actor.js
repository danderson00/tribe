var addHandler = require('./actor.addHandler'),
    utils = require('./utils');

var actor = module.exports = function (pubsub, definition) {
    var self = this;

    pubsub = pubsub.createLifetime();
    this.pubsub = pubsub;
    this.children = [];

    configureActor();
    this.handles = this.handles || {};
    this.topics = utils.keys(this.handles);

    function configureActor() {
        if (definition)
            if (definition.constructor === Function)
                definition(self);
            else
                utils.copyProperties(definition, self, ['handles', 'endsChildrenExplicitly', 'onstart', 'onresume', 'onsuspend', 'onend']);
    }
};

// OK, so this is interesting... a hangover from days gone where types were defined on the Tribe.PubSub object.
// I wonder if this performs any better than returning a new object that exposes the API?
// It should in theory - not having to create a new function reference for each instance,
// but then there is the overhead of traversing in prototype chain...

actor.prototype.start = function (startData) {
    utils.each(this.handles, this.addHandler, this);
    if (this.onstart) this.onstart(startData, this);
    return this;
};

actor.prototype.startChild = function (child, onstartData) {
    this.children.push(new actor(this.pubsub, child)
        .start(onstartData));
    return this;
};

actor.prototype.resume = function (data, resumeData) {
    utils.each(this.handles, this.addHandler, this);
    this.data = data;
    if (this.onresume) this.onresume(resumeData, this);
    return this;
};

actor.prototype.suspend = function (suspendData) {
    if (this.onsuspend) this.onsuspend(suspendData, this);
    this.pubsub.end();
    this.suspendChildren(suspendData);
    return this;
};

actor.prototype.end = function (endData) {
    if (this.onend) this.onend(endData, this);
    this.pubsub.end();
    this.endChildren(endData);
    return this;
};

actor.prototype.endChildren = function (data) {
    utils.each(this.children, function (child) {
        child.end(data);
    });
};
    
actor.prototype.suspendChildren = function (data) {
    utils.each(this.children, function (child) {
        child.suspend(data);
    });
};

actor.prototype.addHandler = addHandler;