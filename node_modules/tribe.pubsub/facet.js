var addHandler = require('./facet.addHandler'),
    expressions = require('tribe.expressions'),
    utils = require('./utils');

var facet = module.exports = function (pubsub, definition, scope, dependencies) {
    var self = this;

    pubsub = pubsub.createLifetime(scope);
    this.pubsub = pubsub;
    this.children = [];
    this.scope = scope;
    this.metadata = {
        expression: [],
        scope: []
    };
    this.dependencies = dependencies;
    this.handlers = {};
    this.handlerContext = {};

    configureFacet();

    this.topics = function () {
        return utils.keys(this.handlers);
    };

    function configureFacet() {
        if (!definition) {
            self.instance = { __facet: self };
        } else if (definition.constructor === Function) {
            self.instance = new definition(self);
            self.instance.__facet = self;
        } else {
            //throw new Error("Facet definition must be a function");
            utils.copyProperties(definition, self, ['endsChildrenExplicitly', 'onstart', 'onresume', 'onsuspend', 'onend']);
            self.handlers = definition.handles;
        }
    }
};

facet.prototype.handles = function (topicOrHandlers, handler) {
    var self = this;

    if(topicOrHandlers.constructor === String)
        handlers(topicOrHandlers).push(handler);
    else
        utils.each(topicOrHandlers, function (handler, topic) {
            handlers(topic).push(handler);
        });

    function handlers(topic) {
        if(!self.handlers[topic])
            self.handlers[topic] = [];
        return self.handlers[topic];
    }
};

facet.prototype.start = function (startData) {
    if (this.onstart) this.onstart(startData, this);
    utils.each(this.handlers, this.addHandler, this);
    return this;
};

facet.prototype.startChild = function (child, onstartData) {
    this.children.push(new facet(this.pubsub, child)
        .start(onstartData));
    return this;
};

facet.prototype.resume = function (data, resumeData) {
    this.data = data;
    if (this.onresume) this.onresume(resumeData, this);
    utils.each(this.handlers, this.addHandler, this);
    return this;
};

facet.prototype.suspend = function (suspendData) {
    if (this.onsuspend) this.onsuspend(suspendData, this);
    this.pubsub.end();
    this.suspendChildren(suspendData);
    return this;
};

facet.prototype.end = function (endData) {
    if (this.onend) this.onend(endData, this);
    this.pubsub.end();
    this.endChildren(endData);
    return this;
};

facet.prototype.endChildren = function (data) {
    utils.each(this.children, function (child) {
        child.end(data);
    });
};

facet.prototype.suspendChildren = function (data) {
    utils.each(this.children, function (child) {
        child.suspend(data);
    });
};

// this exists mostly for backwards compatibility with the facet server operation, used by test-studio
// in future, it will be used to provide hints for indexes. in the not-too-distant future, it won't be required
facet.prototype.isScopedTo = function (property) {
    var self = this;
    utils.each(arguments, function (arg) {
        var value = (self.scope && self.scope.constructor === Object)
            ? self.scope[arg]
            : self.scope;
        self.metadata.expression.push({ p: 'data.' + arg, v: value });
        self.metadata.scope.push(arg);
    });
};

facet.prototype.replay = function (envelopes) {
    var self = this;
    self.pubsub.suspend();
    self.handlerContext = { origin: 'replay' };
    utils.each(envelopes, function (envelope) {
        if (self.handlers[envelope.topic])
            replay(self.handlers[envelope.topic]);

        if (self.handlers['*'])
            replay(self.handlers['*']);

        function replay(handlers) {
            utils.each(handlers, function (handler) {
                handler(envelope.data, envelope);
            });
        }
    });
    self.handlerContext = { };
    self.pubsub.resume();
};

facet.prototype.publish = function (topicOrEnvelope, data) {
    if(!this.handlerContext.trigger || (['server', 'replay'].indexOf(this.handlerContext.trigger.origin) === -1 && !this.handlerContext.trigger.silent))
        this.pubsub.publish.apply(this.pubsub, arguments);
}

facet.prototype.addHandler = addHandler;
