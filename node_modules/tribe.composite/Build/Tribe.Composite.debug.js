/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */
window.eval("(function (global) {\n    if (typeof ($) === 'undefined')\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (typeof (ko) === 'undefined')\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n\n    global.T = global.T || {};\n    global.T.Events = {};\n    global.T.Factories = {};\n    global.T.LoadHandlers = {};\n    global.T.LoadStrategies = {};\n    global.T.Transitions = {};\n    global.T.Types = {};\n    global.T.Utils = {};\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n    });\n})(window || this);\n\n//# sourceURL=http://tribe/composite/setup.js");
window.eval("(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//# sourceURL=http://tribe/composite/Utilities/bindingHandlers.js");
window.eval("(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n\n    utils.pluck = function(array, property) {\n        return utils.map(array, function(value) {\n            return value && value[property];\n        });\n    };\n\n    utils.reduce = function (array, initialValue, reduceFunction) {\n        utils.each(array, function(value, index) {\n            initialValue = reduceFunction(initialValue, value, index, array);\n        });\n        return initialValue;\n    };\n})(T.Utils);\n\n//# sourceURL=http://tribe/composite/Utilities/collections.js");
window.eval("// this is taken from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 \"Cowboy\" Ben Alman and also released under the MIT license\n\n// Deserialize a params string into an object, optionally coercing numbers,\n// booleans, null and undefined values; this method is the counterpart to the\n// internal jQuery.param method.\nT.Utils.deparam = function (params, coerce) {\n    var decode = decodeURIComponent;\n    var obj = {},\n      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    // Iterate over all name=value pairs.\n    $.each(params.replace(/\\+/g, ' ').split('&'), function (j, v) {\n        var param = v.split('='),\n          key = decode(param[0]),\n          val,\n          cur = obj,\n          i = 0,\n\n          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n          // into its component parts.\n          keys = key.split(']['),\n          keys_last = keys.length - 1;\n\n        // If the first keys part contains [ and the last ends with ], then []\n        // are correctly balanced.\n        if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n            // Remove the trailing ] from the last keys part.\n            keys[keys_last] = keys[keys_last].replace(/\\]$/, '');\n\n            // Split first keys part into two parts on the [ and add them back onto\n            // the beginning of the keys array.\n            keys = keys.shift().split('[').concat(keys);\n\n            keys_last = keys.length - 1;\n        } else {\n            // Basic 'foo' style key.\n            keys_last = 0;\n        }\n\n        // Are we dealing with a name=value pair, or just a name?\n        if (param.length === 2) {\n            val = decode(param[1]);\n\n            // Coerce values.\n            if (coerce) {\n                val = val && !isNaN(val) ? +val              // number\n                  : val === 'undefined' ? undefined         // undefined\n                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n                  : val;                                                // string\n            }\n\n            if (keys_last) {\n                // Complex key, build deep object structure based on a few rules:\n                // * The 'cur' pointer starts at the object top-level.\n                // * [] = array push (n is set to array length), [n] = array if n is \n                //   numeric, otherwise object.\n                // * If at the last keys part, set the value.\n                // * For each keys part, if the current level is undefined create an\n                //   object or array based on the type of the next keys part.\n                // * Move the 'cur' pointer to the next level.\n                // * Rinse & repeat.\n                for (; i <= keys_last; i++) {\n                    key = keys[i] === '' ? cur.length : keys[i];\n                    cur = cur[key] = i < keys_last\n                      ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])\n                      : val;\n                }\n\n            } else {\n                // Simple key, even simpler rules, since only scalars and shallow\n                // arrays are allowed.\n\n                if ($.isArray(obj[key])) {\n                    // val is already an array, so push on the next value.\n                    obj[key].push(val);\n\n                } else if (obj[key] !== undefined) {\n                    // val isn't an array, but since a second value has been specified,\n                    // convert val into an array.\n                    obj[key] = [obj[key], val];\n\n                } else {\n                    // val is a scalar.\n                    obj[key] = val;\n                }\n            }\n\n        } else if (key) {\n            // No value was defined, so set something meaningful.\n            obj[key] = coerce\n              ? undefined\n              : '';\n        }\n    });\n\n    return obj;\n};\n//# sourceURL=http://tribe/composite/Utilities/deparam.js");
window.eval("(function() {\n    T.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    T.Utils.contextFor = function (element) {\n        return element && T.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    T.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && (embeddedProperty(koBindingContext.$data, 'context') || embeddedProperty(koBindingContext.$root, 'context'));\n    };\n\n    T.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && (embeddedProperty(koBindingContext.$data, 'node') || embeddedProperty(koBindingContext.$root, 'node'));\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//# sourceURL=http://tribe/composite/Utilities/embeddedContext.js");
window.eval("(function () {\n    T.Utils.elementDestroyed = function (element) {\n        if (element.constructor === jQuery)\n            element = element[0];\n\n        var promise = $.Deferred();\n\n        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n        $(element).on('destroyed', resolve);\n\n        // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n        $(document).on(\"DOMNodeRemoved\", matchElement);\n\n        function matchElement(event) {\n            if (event.target === element)\n                resolve();\n        }\n\n        function resolve() {\n            $(element).off('destroyed', resolve);\n            $(document).off('DOMNodeRemoved', matchElement);\n            promise.resolve();\n        }\n\n        return promise;\n    };\n\n    // this used to use DOM functions to raise events, but IE8 doesn't support custom events\n    // we'll use jQuery, but expose the originalEvent for DOM events and the jQuery event\n    // for custom events (originalEvent is null for custom events).\n    T.Utils.raiseDocumentEvent = function (name, eventData) {\n        var e = $.Event(name);\n        e.eventData = eventData;\n        $(document).trigger(e);\n    };\n\n    var handlers = {};\n\n    // if a handler is used for more than one event, a leak will occur\n    T.Utils.handleDocumentEvent = function (name, handler) {\n        $(document).on(name, internalHandler);\n        handlers[handler] = internalHandler;\n        \n        function internalHandler(e) {\n            handler(e.originalEvent || e);\n        }\n    };\n\n    T.Utils.detachDocumentEvent = function (name, handler) {\n        $(document).off(name, handlers[handler]);\n        delete handlers[handler];\n    };\n})();\n//# sourceURL=http://tribe/composite/Utilities/events.js");
window.eval("T.Utils.tryCatch = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(this, args || []);\n        } catch (ex) {\n            T.logger.error(message, ex);\n        }\n    else\n        func.apply(this, args || []);\n};\n//# sourceURL=http://tribe/composite/Utilities/exceptions.js");
window.eval("(function () {\n    T.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = T.Utils.idGenerator();\n    T.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//# sourceURL=http://tribe/composite/Utilities/idGenerator.js");
window.eval("if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\n        'use strict';\n        if (this == null) {\n            throw new TypeError();\n        }\n        var n, k, t = Object(this),\n            len = t.length >>> 0;\n\n        if (len === 0) {\n            return -1;\n        }\n        n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0) ; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    };\n}\n//# sourceURL=http://tribe/composite/Utilities/indexOf.js");
window.eval("(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//# sourceURL=http://tribe/composite/Utilities/jquery.complete.js");
window.eval("(function () {\n    var oldClean = $.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})();\n//# sourceURL=http://tribe/composite/Utilities/jquery.destroyed.js");
window.eval("T.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//# sourceURL=http://tribe/composite/Utilities/knockout.js");
window.eval("T.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        func: byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nT.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nT.Utils.inheritOptions = function (from, to, options) {\n    for (var i = 0, l = options.length; i < l; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nT.Utils.cloneData = function (from, except) {\n    if (!from || typeof from !== \"object\") return from;\n    if(from.constructor === Array) {\n        var result = [];\n        for(var i = 0, l = from.length; i < l; i++)\n            result.push(T.Utils.cloneData(ko.utils.unwrapObservable(from[i])));\n        return result;\n    } else {\n        var result = {};\n        for (var property in from) {\n            var value = from[property];\n            if (from.hasOwnProperty(property) &&\n                (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&\n                (!value || (value.constructor !== Function || ko.isObservable(value))))\n\n                result[property] = T.Utils.cloneData(ko.utils.unwrapObservable(value));\n        }\n        return result;\n    }\n};\n\nT.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {\n    var data = allBindingsAccessor();\n    data.value = valueAccessor();\n    if (!ko.isObservable(data.value) && $.isFunction(data.value))\n        data.value = data.value();\n    return data;\n};\n\n//# sourceURL=http://tribe/composite/Utilities/objects.js");
window.eval("(function () {\n    var utils = T.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n\n    utils.bindPane = function (node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || T.context();\n        \n        var pane = new T.Types.Pane($.extend({\n            element: $(element)[0]\n        }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new T.Types.Pipeline(T.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    utils.insertPaneAfter = function (node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return utils.bindPane(node, element, paneOptions, context);\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Utilities/panes.js");
window.eval("(function() {\n    T.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path.charAt(0) === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, '');\n            },\n            setExtension: function(extension) {\n                return Path(this.withoutExtension() + '.' + extension);\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Utilities/Path.js");
window.eval("(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    T.Utils.Querystring.parse = function (source, seperator, eqSymbol) {\n        stripLeadIn();\n        \n        return T.Utils.reduce(\n            T.Utils.map(\n                source.split(seperator || \"&\"),\n                pieceParser(eqSymbol || \"=\")\n            ),\n            {},\n            mergeParams\n        );\n\n        function stripLeadIn() {\n            if(source.length > 0 && source.charAt(0) === '?')\n                source = source.substring(1);\n        }\n    };\n    \n    function unescape(s) {\n        return decodeURIComponent(s.replace(/\\+/g, ' '));\n    };\n\n    function pieceParser(eq) {\n        return function parsePiece(key, val) {\n\n            var sliced, numVal, head, tail, ret;\n\n            if (arguments.length === 2) {\n                // key=val, called from the map/reduce\n                key = key.split(eq);\n                return parsePiece(\n                    unescape(key.shift()),\n                    unescape(key.join(eq)),\n                    true\n                );\n            }\n            \n            key = key.replace(/^\\s+|\\s+$/g, '');\n            if (val.constructor === String) {\n                val = val.replace(/^\\s+|\\s+$/g, '');\n                // convert numerals to numbers\n                if (!isNaN(val)) {\n                    numVal = +val;\n                    if (val === numVal.toString(10)) {\n                        val = numVal;\n                    }\n                }\n            }\n            \n            sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n            if (!sliced) {\n                ret = {};\n                if (key)\n                    ret[key] = val;\n                return ret;\n            }\n            \n            // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n            tail = sliced[2];\n            head = sliced[1];\n\n            // array: key[]=val\n            if (!tail)\n                return parsePiece(head, [val], true);\n\n            // object: key[subkey]=val\n            ret = {};\n            ret[tail] = val;\n            return parsePiece(head, ret, true);\n        };\n    }\n\n    // the reducer function that merges each query piece together into one set of params\n    function mergeParams(params, addition) {\n        return (\n            // if it's uncontested, then just return the addition.\n            (!params) ? addition\n            // if the existing value is an array, then concat it.\n            : ($.isArray(params)) ? params.concat(addition)\n            // if the existing value is not an array, and either are not objects, arrayify it.\n            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)\n            // else merge them as objects, which is a little more complex\n            : mergeObjects(params, addition)\n        );\n    }\n\n    // Merge two *objects* together. If this is called, we've already ruled\n    // out the simple cases, and need to do the for-in business.\n    function mergeObjects(params, addition) {\n        for (var i in addition)\n            if (i && addition.hasOwnProperty(i))\n                params[i] = mergeParams(params[i], addition[i]);\n\n        return params;\n    }\n})();\n\n//# sourceURL=http://tribe/composite/Utilities/querystring.parse.js");
window.eval("(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    var escape = encodeURIComponent;\n\n    T.Utils.Querystring.stringify = function (source, options) {\n        return stringify(source, options);\n    };\n\n    function stringify(source, options, name, stack) {\n        options = options || {};\n        stack = stack || [];\n        var begin, end, i, l, n, s;\n        var sep = options.seperator || \"&\";\n        var eq = options.eqSymbol || \"=\";\n        var arrayKey = options.arrayKey !== false;\n\n        if (source === null || source === undefined || source.constructor === Function)\n            return name ? escape(name) + eq : '';\n\n        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')\n            source = +source;\n\n        if (!isNaN(source) || source.constructor === String)\n            return escape(name) + eq + escape(source);\n\n        if ($.isArray(source)) {\n            s = [];\n            name = arrayKey ? name + '[]' : name;\n            for (i = 0, l = source.length; i < l; i++) {\n                s.push(stringify(source[i], options, name, stack));\n            }\n\n            return s.join(sep);\n        }\n        \n        // now we know it's an object.\n        // Check for cyclical references in nested objects\n        for (i = stack.length - 1; i >= 0; --i)\n            if (stack[i] === source)\n                throw new Error(\"T.Utils.Querystring.stringify: cyclical reference\");\n\n        stack.push(source);\n        s = [];\n        begin = name ? name + '[' : '';\n        end = name ? ']' : '';\n        for (i in source) {\n            if (source.hasOwnProperty(i)) {\n                n = begin + i + end;\n                s.push(stringify(source[i], options, n, stack));\n            }\n        }\n\n        stack.pop();\n        s = s.join(sep);\n        if (!s && name)\n            return name + \"=\";\n\n        return s;\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Utilities/querystring.stringify.js");
window.eval("T.Types.History = function (history) {\n    var currentState = 0;\n    history.replaceState(currentState, window.title);\n\n    var popActions = {\n        raiseEvent: function (e) {\n            T.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });\n            currentState = e.state;\n        },\n        updateStack: function(e) {\n            currentState = e.state;\n            currentAction = popActions.raiseEvent;\n        }\n    };\n    var currentAction = popActions.raiseEvent;\n\n    // this leaves IE7 & 8 high and dry. We'll probably require a polyfill and create a generic event subscription method\n    if(window.addEventListener)\n        window.addEventListener('popstate', executeCurrentAction);\n\n    function executeCurrentAction(e) {\n        if (e.state !== null) currentAction(e);\n    }\n\n    this.navigate = function (urlOptions) {\n        urlOptions = urlOptions || {};\n        history.pushState(++currentState, urlOptions.title, urlOptions.url);\n    };\n\n    this.go = function(frameCount) {\n        history.go(frameCount);\n    };\n\n    this.update = function(frameCount) {\n        currentAction = popActions.updateStack;\n        history.go(frameCount);\n    };\n\n    this.dispose = function () {\n        window.removeEventListener('popstate', executeCurrentAction);\n    };\n};\n\nif (window.history.pushState)\n    T.history = new T.Types.History(window.history);\nelse\n    T.history = new T.Types.History({\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { }\n    });\n//# sourceURL=http://tribe/composite/Types/History.js");
window.eval("T.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = T.Path(url).extension().toString();\n        var handler = T.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        T.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//# sourceURL=http://tribe/composite/Types/Loader.js");
window.eval("T.Types.Navigation = function (node, options) {\n    normaliseOptions();\n    setInitialPaneState();\n\n    var stack = [initialStackItem()];\n    var currentFrame = 0;\n\n    this.node = node;\n    this.stack = stack;\n\n    this.navigate = function (paneOptions) {\n        if (options.browser)\n            T.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));\n\n        trimStack();\n        stack.push(paneOptions);\n        currentFrame++;\n\n        navigateTo(paneOptions);\n    };\n\n    this.isAtStart = function() {\n        return currentFrame === 0;\n    };\n\n    this.go = function(frameCount) {\n        go(frameCount);\n        if (options.browser) T.history.update(frameCount);\n    };\n    \n    if(options.browser) T.Utils.handleDocumentEvent('browser.go', onBrowserGo);\n    function onBrowserGo(e) {\n        go(e.eventData.count);\n    }\n\n    function go(frameCount) {\n        var newFrame = currentFrame + frameCount;\n        if (newFrame < 0) newFrame = 0;\n        if (newFrame >= stack.length) newFrame = stack.length - 1;\n\n        if (newFrame != currentFrame)\n            navigateTo(stack[newFrame], frameCount < 0);\n\n        currentFrame = newFrame;\n    }\n\n    function navigateTo(paneOptions, reverse) {\n        T.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });\n        node.transitionTo(paneOptions, options.transition, reverse);\n    }\n\n    function trimStack() {\n        stack.splice(currentFrame + 1, stack.length);\n    }\n\n    this.dispose = function() {\n        T.Utils.detachDocumentEvent('browser.go', onBrowserGo);\n    };\n    \n    function normaliseOptions() {\n        options = options || {};\n        if (options.constructor === String)\n            options = { transition: options };\n        if (options.browser === true)\n            options.browser = T.options.defaultUrlProvider;\n    }\n    \n    function setInitialPaneState() {\n        var query = window.location.href.match(/\\#.*/);\n        if (query) query = query[0].substring(1);\n        var urlState = options.browser && options.browser.paneOptionsFrom(query);\n        if (urlState) {\n            node.pane.path = urlState.path;\n            node.pane.data = urlState.data;\n        }\n    }\n    \n    function initialStackItem() {\n        return { path: node.pane.path, data: node.pane.data };\n    }\n};\n//# sourceURL=http://tribe/composite/Types/Navigation.js");
window.eval("T.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n    this.id = T.Utils.getUniqueId();\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nT.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = T.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!T.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = T.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();\n\n    this.findNavigation().navigate(paneOptions);\n};\n\nT.Types.Node.prototype.navigateBack = function () {\n    this.findNavigation().go(-1);\n};\n\nT.Types.Node.prototype.findNavigation = function() {\n    if (this.defaultNavigation)\n        return this.defaultNavigation;\n\n    else if (this.navigation)\n        return this.navigation;\n\n    if (!this.parent) {\n        this.navigation = new T.Types.Navigation(this);\n        return this.navigation;\n    }\n\n    return this.parent.findNavigation();\n};\n\nT.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    T.transition(this, transition, reverse).to(paneOptions);\n};\n\nT.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.navigation = new T.Types.Navigation(this, pane.handlesNavigation);\n\n        // this sets this pane as the \"default\", accessible from panes outside the tree. Last in best dressed.\n        this.root.defaultNavigation = this.navigation;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nT.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nT.Types.Node.prototype.dispose = function() {\n    if (this.root.defaultNavigation === this.navigation)\n        this.root.defaultNavigation = null;\n\n    if (this.parent)\n        T.Utils.removeItem(this.parent.children, this);\n\n    if (this.pane && this.pane.dispose) {\n        delete this.pane.node;\n        this.pane.dispose();\n    }\n};\n\n//# sourceURL=http://tribe/composite/Types/Node.js");
window.eval("T.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        T.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//# sourceURL=http://tribe/composite/Types/Operation.js");
window.eval("T.Types.Pane = function (options) {\n    T.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath', 'scope', 'resetScope']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };\n};\n\nT.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nT.Types.Pane.prototype.navigateBack = function () {\n    this.node && this.node.navigateBack();\n};\n\nT.Types.Pane.prototype.remove = function () {\n    $(this.element).remove();\n};\n\nT.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        delete this.node.pane;\n        this.node.dispose();\n    }\n\n    if (this.element)\n        T.Utils.cleanElement(this.element);\n};\n\nT.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;\n    var path = T.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = T.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nT.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nT.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nT.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nT.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n\nT.Types.Pane.prototype.startActor = function(path, args) {\n    var actor = T.context().actors[path];\n    this.pubsub.startActor.apply(this.pubsub, [actor.constructor].concat(Array.prototype.slice.call(arguments, 1)));\n};\n\n//# sourceURL=http://tribe/composite/Types/Pane.js");
window.eval("T.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var thisEvent = events[eventName];\n\n            if (!thisEvent) {\n                T.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            // could possibly improve debugging in non-production scenarios by omitting the fail handler\n            // using .done without a fail handler should mean the exception is unhandled, allowing it\n            // to be caught by the debugger easily.\n            // $.when(thisEvent(target, context))\n            //     .done(executeNextEvent)\n            //     .fail(handleFailure);\n\n            // this handles promises returned from any other A+ compliant promise library\n            var eventResult = thisEvent(target, context);\n            if(eventResult && typeof eventResult.then === 'function') {\n                eventResult.then(executeNextEvent, handleFailure);\n            } else {\n                try {\n                    executeNextEvent();\n                } catch(error) {\n                    handleFailure(error);\n                }\n            }\n\n            function handleFailure(error) {\n                promise.reject(error);\n                var targetDescription = target ? target.toString() : \"empty target\";\n                T.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription, error);\n            }\n        }\n\n        return promise;\n    };\n};\n\n//# sourceURL=http://tribe/composite/Types/Pipeline.js");
window.eval("T.Types.Resources = function () { };\n\nT.Types.Resources.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    T.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//# sourceURL=http://tribe/composite/Types/Resources.js");
window.eval("T.Types.StringCollection = function (initialContent) {\n    var content = initialContent ? initialContent.concat() : [];\n\n    content.insertBefore = function (before, item) {\n        content.splice(content.indexOf(before), 0, item);\n        return content;\n    };\n\n    content.insertAfter = function (after, item) {\n        content.splice(content.indexOf(after) + 1, 0, item);\n        return content;\n    };\n\n    return content;\n};\n\n//# sourceURL=http://tribe/composite/Types/StringCollection.js");
window.eval("T.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = T.Path(path).asMarkupIdentifier().toString();\n        embedTemplate(template, 'template-' + id);\n    };\n    \n    function embedTemplate(template, id) {\n        var element = document.createElement('script');\n        element.className = '__tribe';\n        element.setAttribute('type', 'text/template');\n        element.id = id;\n        element.text = template;\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n    \n    this.loaded = function(path) {\n        return $('head script#template-' + T.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = T.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//# sourceURL=http://tribe/composite/Types/Templates.js");
window.eval("T.defaultOptions = function() {\n    return {\n        synchronous: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: T.Types.StringCollection(['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'paneRendered', 'renderComplete', 'active', 'dispose'])\n    };\n};\nT.options = T.defaultOptions();\n\n//# sourceURL=http://tribe/composite/options.js");
window.eval("var level = 4;\nvar levels = {\n    silly: 5,\n    debug: 4,\n    info: 3,\n    warn: 2,\n    error: 1,\n    none: 0\n};\n\nT.logger = {\n    setLevel: function (newLevel) {\n        level = levels[newLevel];\n        if (level === undefined) level = 4;\n    },\n    silly: function (message) {\n        if (level >= 5) console.log(('SILLY: ' + message));\n    },\n    debug: function (message) {\n        if (level >= 4) console.log(('DEBUG: ' + message));\n    },\n    info: function (message) {\n        if (level >= 3) console.info(('INFO: ' + message));\n    },\n    warn: function (message) {\n        if (level >= 2) console.warn(('WARN: ' + message));\n    },\n    error: function (message, error) {\n        if (level >= 1) console.error(('ERROR: ' + message + '\\n'), T.logger.errorDetails(error));\n    },\n    errorDetails: function (ex) {\n        if (!ex) return '';\n        return (ex.constructor === String) ? ex :\n            (ex.stack || '') + (ex.inner ? '\\n\\n' + this.errorDetails(ex.inner) : '\\n');\n    },\n    log: function (message) {\n        console.log(message);\n    }\n};\n\n//# sourceURL=http://tribe/composite/logger.js");
window.eval("T.Events.active = function (pane, context) {\n    return T.Utils.elementDestroyed(pane.element);\n};\n//# sourceURL=http://tribe/composite/Events/active.js");
window.eval("T.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path],\n        model = (definition && definition.constructor)\n            ? new definition.constructor(pane)\n            : { };\n\n    model.pane = model.pane || pane;\n    model.data = model.data || pane.data;\n    model.navigate = model.navigate || navigate;\n    model.publish = model.publish || publishToPane;\n    model.publish.toRoot = publishToRoot;\n\n    T.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n\n    function navigate(path, data) {\n        var args = arguments;\n        return function () {\n            pane.navigate.apply(pane, args);\n        };\n    }\n\n    function publishToPane(topicOrEnvelopes, data) {\n        return publish(pane.pubsub, topicOrEnvelopes, data);\n    }\n\n    function publishToRoot(topicOrEnvelopes, data) {\n        return publish(pane.pubsub.owner, topicOrEnvelopes, data);\n    }\n\n    function publish(pubsub, topicOrEnvelopes, data) {\n        return function () {\n            if(topicOrEnvelopes.constructor === Array)\n                topicOrEnvelopes.forEach(function (envelope) {\n                    pubsub.publish(T.Utils.cloneData(envelope));\n                })\n            else\n                pubsub.publish(createEnvelope(topicOrEnvelopes, data));\n        }\n    }\n\n    function createEnvelope(topicOrEnvelope, data) {\n        return topicOrEnvelope && topicOrEnvelope.topic\n            ? T.Utils.cloneData(topicOrEnvelope)\n            : { topic: topicOrEnvelope, data: T.Utils.cloneData(data) };\n    }\n};\n\n//# sourceURL=http://tribe/composite/Events/createModel.js");
window.eval("T.Events.createPubSub = function (pane, context) {\n    // this does not cascade scope correctly\n    // if (context.pubsub)\n    //     pane.pubsub = (pane.scope === 'reset' && context.pubsub.owner)\n    //         ? context.pubsub.owner.createLifetime()\n    //         : context.pubsub.createLifetime(T.Utils.cloneData(pane.scope));\n\n    var parentNode = pane.node.parent;\n\n    if(pane.scope === 'reset')\n        pane.pubsub = context.pubsub.createLifetime();\n    else if(pane.resetScope)\n        pane.pubsub = context.pubsub.createLifetime(T.Utils.cloneData(pane.scope));\n    else if(parentNode)\n        pane.pubsub = parentNode.pane.pubsub.createLifetime(T.Utils.cloneData(pane.scope));\n    else\n        pane.pubsub = context.pubsub.createLifetime(T.Utils.cloneData(pane.scope));\n};\n\n//# sourceURL=http://tribe/composite/Events/createPubSub.js");
window.eval("T.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//# sourceURL=http://tribe/composite/Events/dispose.js");
window.eval("T.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//# sourceURL=http://tribe/composite/Events/initialiseModel.js");
window.eval("T.Events.loadResources = function (pane, context) {\n    var strategy = T.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//# sourceURL=http://tribe/composite/Events/loadResources.js");
window.eval("T.Events.paneRendered = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n};\n\n//# sourceURL=http://tribe/composite/Events/paneRendered.js");
window.eval("T.Events.renderComplete = function (pane, context) {\n    $.when(\n        T.transition(pane, pane.transition, pane.reverseTransitionIn)['in']())\n     .done(executeRenderComplete);\n    \n    pane.endRender();\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        T.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new T.Types.Operation();\n    }\n};\n//# sourceURL=http://tribe/composite/Events/renderComplete.js");
window.eval("T.Events.renderPane = function (pane, context) {\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    T.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    function applyBindings() {\n        ko.applyBindingsToDescendants(pane.model, pane.element);\n    }\n};\n\n//# sourceURL=http://tribe/composite/Events/renderPane.js");
window.eval("T.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeScript\n    });\n\n    function executeScript(script) {\n        T.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        T.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete T.scriptEnvironment;\n\n        T.logger.debug('Loaded script from ' + url);\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//# sourceURL=tribe://Application/' + url.replace(/ /g, \"_\");\n    }\n};\n\n//# sourceURL=http://tribe/composite/LoadHandlers/scripts.js");
window.eval("T.LoadHandlers.css = function (url, resourcePath, context) {\n    var supportsTextNodes = true;\n    \n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        var element = document.getElementById('__tribeStyles');\n        if (!element) {\n            element = document.createElement('style');\n            element.className = '__tribe';\n            element.id = '__tribeStyles';\n            document.getElementsByTagName('head')[0].appendChild(element);\n        }\n\n        if(supportsTextNodes)\n            try {\n                element.appendChild(document.createTextNode(stylesheet));\n            } catch(ex) {\n                supportsTextNodes = false;\n            }\n\n        if (!supportsTextNodes)\n            if (element.styleSheet) {\n                // using styleSheet.cssText is required for IE8 support\n                // IE8 also has a limit on the number of <style/> elements, so append it to the same node\n                element.styleSheet.cssText += stylesheet;\n            } else throw new Error('Unable to append stylesheet for ' + resourcePath + ' to document.');\n    }\n};\n//# sourceURL=http://tribe/composite/LoadHandlers/stylesheets.js");
window.eval("T.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nT.LoadHandlers.html = T.LoadHandlers.htm;\n\n//# sourceURL=http://tribe/composite/LoadHandlers/templates.js");
window.eval("T.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = T.Path(context.options.basePath).combine(T.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            T.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//# sourceURL=http://tribe/composite/LoadStrategies/adhoc.js");
window.eval("T.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        T.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//# sourceURL=http://tribe/composite/LoadStrategies/preloaded.js");
window.eval("T.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n\n    transition = transition || (pane && pane.transition) || (node && node.transition);\n    var implementation = T.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = T.Transitions[implementation.reverse];\n\n    return {\n        'in': function () {\n            $(element).show();\n            return implementation && implementation['in'](element);\n        },\n\n        out: function (remove, transitionAttributes) {\n            $(element).css(transitionAttributes || getTransitionAttributes());\n\n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n\n            function removeElement() {\n                if (remove === false) {\n                    $(element).hide().attr('style', '');\n                } else\n                    $(element).remove();\n            }\n        },\n\n        to: function (paneOptions, remove) {\n            var context = T.context(),\n                attributes = getTransitionAttributes();\n            if (node)\n                T.Utils.insertPaneAfter(node, element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                T.insertNodeAfter(element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove, attributes);\n            return context.renderOperation.promise;\n        }\n    };\n\n    function getTransitionAttributes() {\n        var $element = $(element);\n        if (T.transition.mode === 'fixed')\n            return {\n                position: 'fixed',\n                width: $element.width(),\n                left: $element.offset().left,\n                top: $element.offset().top\n            };\n        else\n            return {\n                position: 'absolute',\n                width: $element.width(),\n                left: $element.position().left,\n                top: $element.position().top\n            };\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to T.transition\";\n\n        if (target.constructor === T.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === T.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }\n};\n\n//# sourceURL=http://tribe/composite/Transitions/transition.js");
window.eval("(function () {\n    var supported = supportsTransitions();\n    \n    createCssTransition('fade');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n\n    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';\n\n    function createCssTransition(transition, reverse) {\n        T.Transitions[transition] = {\n            'in': function (element) {\n                if (!supported) return null;\n                \n                var promise = $.Deferred();\n                $(element).bind(transitionEndEvents, transitionEnded(element, promise))\n                    .addClass('prepare in ' + transition);\n\n                trigger(element);\n                return promise;\n            },\n\n            out: function (element) {\n                if (!supported) return null;\n                var promise = $.Deferred();\n\n                $(element).addClass('prepare out ' + transition)\n                    .on(transitionEndEvents, transitionEnded(element, promise, true));\n\n                trigger(element);\n                return promise;\n            },\n            reverse: reverse || transition\n        };\n\n        function trigger(element) {\n            setTimeout(function () {\n                $(element).addClass('trigger');\n            }, 30);\n        }\n\n        function transitionEnded(element, promise, hide) {\n            return function() {\n                $(element).unbind(transitionEndEvents)\n                    .removeClass(transition + ' in out prepare trigger');\n                if (hide) $(element).hide();\n                promise.resolve();\n            };\n        }\n    }\n    \n    function supportsTransitions() {\n        var b = document.body || document.documentElement;\n        var style = b.style;\n        var property = 'transition';\n        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n        if (typeof style[property] == 'string') { return true; }\n\n        // Tests for vendor specific prop\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        for (var i = 0, l = vendors.length; i < l; i++) {\n            if (typeof style[vendors[i] + property] == 'string') { return true; }\n        }\n        \n        return false;\n    }\n})();\n\n//# sourceURL=http://tribe/composite/Transitions/Css/css.js");
window.eval("//\nwindow.__appendStyle = function (content) {\n    var element = document.getElementById('__tribeStyles');\n    if (!element) {\n        element = document.createElement('style');\n        element.className = '__tribe';\n        element.id = '__tribeStyles';\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n\n    if(element.styleSheet)\n        element.styleSheet.cssText += content;\n    else\n        element.appendChild(document.createTextNode(content));\n};//\nwindow.__appendStyle('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}');\n//# sourceURL=http://tribe/composite/Transitions/Css/style.css.js");
window.eval("(function () {\n    T.registerModel = function () {\n        addResource('models', T.Utils.arguments(arguments));\n    };\n\n    T.registerActor = function () {\n        addResource('actors', T.Utils.arguments(arguments));\n    };\n\n    function addResource(contextProperty, args) {\n        var environment = T.scriptEnvironment || {};\n        var context = environment.context || T.context();\n\n        var path = args.string || environment.resourcePath;\n        var constructor = args.func;\n        var options = args.object;\n\n        context[contextProperty].register(path, constructor, options);\n    }\n\n    T.run = function(options, initialModel) {\n        T.options = $.extend(T.options, options);\n        T.options.pubsub = T.options.pubsub || new Tribe.PubSub({ sync: T.options.synchronous, handleExceptions: T.options.handleExceptions });\n        ko.applyBindings(initialModel);\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Api/api.js");
window.eval("(function () {\n    var staticState;\n\n    T.context = function (source) {\n        staticState = staticState || {\n            models: new T.Types.Resources(),\n            actors: new T.Types.Resources(),\n            loader: new T.Types.Loader(),\n            options: T.options,\n            templates: new T.Types.Templates(),\n            loadedPanes: {}\n        };\n        var perContextState = {\n            renderOperation: new T.Types.Operation(),\n            pubsub: T.options.pubsub\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Api/context.js");
window.eval("T.options.defaultUrlProvider = {\n    urlDataFrom: function(paneOptions) {\n        return paneOptions && { url: '#' + $.param(paneOptions) };\n    },\n    paneOptionsFrom: function(url) {\n        return url && T.Utils.deparam(url.substr(1));\n    }\n};\n//# sourceURL=http://tribe/composite/Api/defaultUrlProvider.js");
window.eval("(function () {\n    var utils = T.Utils;\n\n    T.createNode = function (element, paneOptions, parentNode, context) {\n        var node = new T.Types.Node(parentNode || T.nodeFor(element));\n\n        context = context || utils.contextFor(element) || T.context();\n        utils.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    T.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return T.createNode(element, paneOptions, parentNode, context);\n    };\n\n    T.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return T.createNode(element, paneOptions, parentNode || T.nodeFor(target), context);\n    };\n\n    T.nodeFor = function (element) {\n        return element && T.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n})();\n\n//# sourceURL=http://tribe/composite/Api/nodes.js");
window.eval("(function() {\n    ko.bindingHandlers.foreachProperty = {\n        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.init(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        },\n        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.update(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        }\n    };\n    \n    function makeAccessor(source) {\n        return function() {\n            return source;\n        };\n    }\n\n    function mapToArray(source) {\n        var result = [];\n        for (var property in source)\n            if (source.hasOwnProperty(property))\n                // we don't want to modify the original object, extend it onto a new object\n                result.push($.extend({ $key: property }, source[property]));\n        return result;\n    }\n})();\n\n//# sourceURL=http://tribe/composite/BindingHandlers/foreachProperty.js");
window.eval("ko.bindingHandlers.navigate = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, navigate, allBindingsAccessor, viewModel);\n\n        function navigate() {\n            return function () {\n                node.navigate(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//# sourceURL=http://tribe/composite/BindingHandlers/navigate.js");
window.eval("ko.bindingHandlers.navigateBack = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);\n\n        function navigateBack() {\n            return function () {\n                node.navigateBack();\n            };\n        }\n    }\n};\n//# sourceURL=http://tribe/composite/BindingHandlers/navigateBack.js");
window.eval("(function() {\n    ko.bindingHandlers.pane = { init: init, update: update };\n    ko.virtualElements.allowedBindings.pane = true;\n\n    function init() {\n        return { controlsDescendantBindings: true };\n    }\n\n    function update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        if(element && element.nodeType === 8) {\n            var child = firstChild(element);\n            if(child) {\n                // a bit nasty - got to get a child element to get at the node\n                var node = T.nodeFor(firstChild(child, true));\n                node.navigate(constructPaneOptions(valueAccessor, allBindingsAccessor));\n                return node;\n            } else {\n                ko.virtualElements.prepend(element, $('<div></div>')[0]);\n                return createNode(ko.virtualElements.firstChild(element));\n            }\n        } else\n            return createNode(element);\n\n        function createNode(element) {\n            return T.createNode(element, constructPaneOptions(), T.Utils.extractNode(bindingContext), T.Utils.extractContext(bindingContext));\n        }\n\n        function constructPaneOptions() {\n            return T.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n\n        function firstChild(target, includeComments) {\n            var child = ko.virtualElements.firstChild(target);\n            return firstSibling(child);\n\n            function firstSibling(sibling) {\n                if(!sibling)\n                    return null;\n\n                if(sibling.nodeType === 1 || (includeComments && sibling.nodeType === 8))\n                    return sibling;\n\n                return firstSibling(ko.virtualElements.nextSibling(sibling));\n            }\n        }\n    }\n})();\n\n//# sourceURL=http://tribe/composite/BindingHandlers/pane.js");
window.eval("ko.bindingHandlers.publish = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var pubsub = T.nodeFor(element).pane.pubsub;\n        if (!pubsub) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, publishAccessor, allBindingsAccessor, viewModel, bindingContext);\n\n        function publishAccessor() {\n            return function () {\n                pubsub.publish(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//# sourceURL=http://tribe/composite/BindingHandlers/publish.js");
