Test = {
    Unit: {},
    Integration: {},
    state: {}
};

Test.defaultOptions = function() {
    return {
        synchronous: true,
        handleExceptions: false,
        basePath: 'Integration/Panes/',
        loadStrategy: 'adhoc',
        events: T.defaultOptions().events,
        defaultUrlProvider: T.options.defaultUrlProvider
    };
};
T.options = Test.defaultOptions();


QUnit.testDone(function () {
    ko.cleanNode(document.getElementById('qunit-fixture'));
    Test.state = {};
    T.options = Test.defaultOptions();
});

T.history.dispose();
window.eval("T.context = function (state) {\n    Test.Integration.context = $.extend({\n        models: new T.Types.Resources(),\n        actors: new T.Types.Resources(),\n        loader: new T.Types.Loader(),\n        options: T.options,\n        templates: new T.Types.Templates(),\n        loadedPanes: {},\n        renderOperation: new T.Types.Operation(),\n        pubsub: Test.Integration.pubsub()\n    }, state);\n    return Test.Integration.context;\n};\n//@ sourceURL=tribe://Integration/Infrastructure/context.js");
window.eval("(function () {\n    var helpers = Test.Integration;\n\n    helpers.executeEvents = function (events, pane, data) {\n        T.options.events = events;\n        T.options.basePath = 'Integration/Panes';\n\n        var $element = $('#qunit-fixture');\n        $element.append('<div data-bind=\"pane: \\'' + pane + '\\', data: \\'' + data + '\\'\"></div>');\n        ko.applyBindings(null, $element.children()[0]);\n    };\n\n    helpers.executeDefaultEvents = function (pane) {\n        helpers.executeEvents(T.defaultOptions().events, pane);\n    };\n\n    helpers.createTestElement = function() {\n        $('#qunit-fixture').append('<div class=\"test\"/>');\n    };\n\n    helpers.testEventsUntil = function(event) {\n        var events = [];\n        var defaultEvents = T.defaultOptions().events;\n        for (var i = 0, l = defaultEvents.length; i < l; i++) {\n            events.push(defaultEvents[i]);\n            if (defaultEvents[i] === event)\n                break;\n        }\n        T.Events.spy = sinon.spy();\n        events.push('spy');\n        return events;\n    };\n\n    helpers.teardown = function() {\n        $('.__tribe').remove();\n    };\n})();\n\n//@ sourceURL=tribe://Integration/Infrastructure/helpers.js");
window.eval("Test.Integration.pubsubAsMock = function() {\n    Test.Integration.pubsub = function() {\n        var pubsub = { end: sinon.spy(), createLifetime: function () { return pubsub; } };\n        sinon.spy(pubsub, 'createLifetime');\n        return pubsub;\n    };\n};\n\nTest.Integration.pubsubAsTribe = function () {\n    Test.Integration.pubsub = function () {\n        return new Tribe.PubSub({ sync: true });\n    };\n};\n\nTest.Integration.pubsubAsMock();\n//@ sourceURL=tribe://Integration/Infrastructure/pubsub.js");
window.eval("Test.supportsTransitions = (function() {\n    var b = document.body || document.documentElement;\n    var style = b.style;\n    var property = 'transition';\n    var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n    if (typeof style[property] == 'string') { return true; }\n\n    // Tests for vendor specific prop\n    property = property.charAt(0).toUpperCase() + property.substr(1);\n    for (var i = 0, l = vendors.length; i < l; i++) {\n        if (typeof style[vendors[i] + property] == 'string') { return true; }\n    }\n\n    return false;\n})();\n\n//@ sourceURL=tribe://Integration/Infrastructure/supportsTransitions.js");
window.eval("Test.Unit.context = function () {\n    var template = '';\n    var context = {\n        loader: {\n            get: sinon.spy()\n        },\n        models: {\n            test: { constructor: sinon.spy() }\n        },\n        options: {\n            synchronous: true,\n            basePath: '',\n            events: ['test']\n        },\n        templates: {\n            template: '',\n            store: sinon.spy(),\n            loaded: sinon.spy(),\n            render: function() {\n                $('#qunit-fixture').append(template);\n            }\n        },\n        setTemplate: function(value) {\n            template = value;\n        },\n        loadedPanes: {},\n        rootNode: null,\n        renderOperation: {\n            promise: $.Deferred(),\n            complete: function () { }\n        }\n    };\n    sinon.spy(context.templates, 'render');\n    return context;\n};\n//@ sourceURL=tribe://Unit/Infrastructure/context.js");
window.eval("Test.raiseDocumentEvent = function(name, eventData, state) {\n    var e;\n    if (document.createEvent) {\n        e = document.createEvent(\"Event\");\n        e.initEvent(name, true, false);\n    } else {\n        e = document.createEventObject();\n        e.eventType = name;\n    }\n\n    e.eventName = name;\n    e.eventData = eventData;\n    e.state = state;\n\n    if (document.createEvent)\n        document.dispatchEvent(e);\n    else\n        document.fireEvent(\"on\" + e.eventType, e);\n};\n//@ sourceURL=tribe://Unit/Infrastructure/events.js");
window.eval("Test.supportsMutationEvents = (\"MutationEvent\" in window);\nTest.supportsHistory = (\"onpopstate\" in window);\n\n//@ sourceURL=tribe://Unit/Infrastructure/featureDetection.js");
window.eval("Test.Unit.node = function () {\n    var pane = Test.pane();\n    return {\n        pane: pane,\n        path: pane.path,\n        children: [],\n        nodeForPath: function() { return this; }\n    };\n};\n//@ sourceURL=tribe://Unit/Infrastructure/node.js");
window.eval("Test.pane = function () {\n    return {\n        path: 'test',\n        element: '#qunit-fixture',\n        model: {\n            initialise: sinon.spy(),\n            paneRendered: sinon.spy()\n        },\n        startRender: function () { },\n        endRender: function () { },\n        dispose: function () { }\n    };\n};\n//@ sourceURL=tribe://Unit/Infrastructure/pane.js");
window.eval("(function() {\n    module('Unit.Utilities.bindingHandlers');\n\n    test(\"enterPressed executes callback when enter keyup event occurs in specified element, passing element value\", function () {\n        var element = $('<input/>').appendTo('#qunit-fixture');\n        var spy = sinon.spy();\n        ko.bindingHandlers.enterPressed.init(element[0], function () { return spy; });\n    \n        ok(spy.notCalled);\n        element.val('value');\n        element.trigger(keyEvent('keyup', 13));\n        ok(spy.calledOnce);\n        ok(spy.calledWithExactly('value'));\n    });\n    \n    function keyEvent(eventName, which) {\n        var event = jQuery.Event(eventName);\n        event.which = which;\n        return event;\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/bindingHandlers.tests.js");
window.eval("module('Unit.Utilities.collections');\n\ntest(\"each executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.Utils.each(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"each executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.Utils.each({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.Utils.map(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"map executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.Utils.map({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map does not flatten arrays\", function() {\n    var result = T.Utils.map([1, 2], function () { return [3, 4]; });\n    equal(result.length, 2);\n    deepEqual(result[0], [3, 4]);\n    deepEqual(result[1], [3, 4]);\n});\n\ntest(\"map returns empty array for undefined input\", function() {\n    var spy = sinon.spy();\n    deepEqual(T.Utils.map(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"filter executes once for each item of array\", function() {\n    var spy = sinon.spy();\n    T.Utils.filter(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"filter executes once for each property of object\", function () {\n    var spy = sinon.spy();\n    T.Utils.filter({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"filter returns array of values filtered by iterator function\", function() {\n    var result = T.Utils.filter(['1', '2'], function (item) { return item !== '1'; });\n    equal(result.length, 1);\n    equal(result[0], '2');\n});\n\ntest(\"filter returns empty array for undefined input\", function () {\n    var spy = sinon.spy();\n    deepEqual(T.Utils.filter(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"pluck returns property value from each object in array\", function() {\n    var result = T.Utils.pluck([\n        { one: 'a', two: 'b' },\n        { one: 'c', two: 'd' },\n        { one: 'e', two: 'f' }\n    ], 'one');\n    equal(result.length, 3);\n    equal(result.join(''), 'ace');\n});\n\ntest(\"reduce executes reduceFunction with expected arguments\", function() {\n    var spy = sinon.spy();\n    var list = [1, 2];\n    T.Utils.reduce(list, 'initial', spy);\n\n    equal(spy.callCount, 2);\n    deepEqual(spy.firstCall.args, ['initial', 1, 0, list]);\n    deepEqual(spy.secondCall.args, [undefined, 2, 1, list]);\n});\n\ntest(\"reduce returns expected result\", function() {\n    var result = T.Utils.reduce([1, 2, 3, 4], 10, function(memo, value) {\n        return memo + value;\n    });\n    equal(result, 20);\n});\n//@ sourceURL=tribe://Unit/Utilities/collections.tests.js");
window.eval("(function () {\n    // these are based on tests from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 \"Cowboy\" Ben Alman and also released under the MIT license\n    module('Unit.Utilities.deparam');\n    \n    var params_obj = { a: ['4', '5', '6'], b: { x: ['7'], y: '8', z: ['9', '0', 'true', 'false', 'undefined', ''] }, c: '1' },\n        params_obj_coerce = { a: [4, 5, 6], b: { x: [7], y: 8, z: [9, 0, true, false, undefined, ''] }, c: 1 },\n        params_str = 'a[]=4&a[]=5&a[]=6&b[x][]=7&b[y]=8&b[z][]=9&b[z][]=0&b[z][]=true&b[z][]=false&b[z][]=undefined&b[z][]=&c=1';\n\n    test(\"deparam deserialises string correctly\", function() {\n        deepEqual(T.Utils.deparam(params_str), params_obj);\n    });\n\n    test(\"deparam deserialises string correctly and coerces types\", function () {\n        deepEqual(T.Utils.deparam(params_str, true), params_obj_coerce);\n    });\n})();\n//@ sourceURL=tribe://Unit/Utilities/deparam.tests.js");
window.eval("module('Unit.Utilities.elementDestroyed');\n\ntest(\"promise resolves when element is removed using jQuery\", function () {\n    expect(1);\n    var element = $('<div/>').appendTo('#qunit-fixture');\n    $.when(T.Utils.elementDestroyed(element)).done(function() {\n        ok(true);\n    });\n    element.remove();\n});\n\nasyncTest(\"promise resolves when element is removed using native functions\", function () {\n    if (Test.supportsMutationEvents) {\n        expect(1);\n        var element = $('<div/>').appendTo('#qunit-fixture');\n        $.when(T.Utils.elementDestroyed(element)).done(function() {\n            ok(true);\n            start();\n        });\n        element[0].parentNode.removeChild(element[0]);\n    } else {\n        // this should really be a warning\n        ok(true, \"Browser does not support DOM mutation events. Only elements removed with jQuery will be properly cleaned in this browser.\");\n        start();\n    }\n});\n\n//@ sourceURL=tribe://Unit/Utilities/elementDestroyed.tests.js");
window.eval("(function() {\n    var utils = T.Utils;\n    var spy;\n\n    module('Unit.Utilities.events', {\n        setup: function () { spy = sinon.spy(); }\n    });\n\n    test(\"handleDocumentEvent executes handler when event is fired using raiseDocumentEvent\", function () {\n        utils.handleDocumentEvent('click', spy);\n        utils.raiseDocumentEvent('click');\n        ok(spy.calledOnce);\n        utils.detachDocumentEvent('click', spy);\n    });\n\n    test(\"handleDocumentEvent executes handler when event is fired manually\", function () {\n        utils.handleDocumentEvent('click', spy);\n        raise('click');\n        ok(spy.calledOnce);\n        utils.detachDocumentEvent('click', spy);\n    });\n\n    test(\"detachDocumentEvent removes handler attached with handleDocumentEvent\", function () {\n        utils.handleDocumentEvent('click', spy);\n        utils.raiseDocumentEvent('click');\n        utils.detachDocumentEvent('click', spy);\n        utils.raiseDocumentEvent('click');\n        ok(spy.calledOnce);\n    });\n\n    test(\"raiseDocumentEvent sets eventData property from argument\", function() {\n        var data = {};\n        utils.handleDocumentEvent('click', spy);\n        utils.raiseDocumentEvent('click', data);\n        equal(spy.firstCall.args[0].eventData, data);\n        utils.detachDocumentEvent('click', spy);\n    });\n\n    function raise(name) {\n        var e;\n        if (document.createEvent) {\n            e = document.createEvent(\"Event\");\n            e.initEvent(name, true, false);\n        } else {\n            e = document.createEventObject();\n            e.eventType = name;\n        }\n\n        e.eventName = name;\n\n        if (document.createEvent)\n            document.dispatchEvent(e);\n        else\n            document.fireEvent(\"on\" + e.eventType, e);\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/events.tests.js");
window.eval("(function () {\n    module('Unit.Utilities.idGenerator');\n\n    test(\"idGenerator starts at 0 and generates sequential numbers\", function () {\n        var generator = T.Utils.idGenerator();\n        equal(generator.next(), 0);\n        equal(generator.next(), 1);\n        equal(generator.next(), 2);\n        equal(generator.next(), 3);\n        equal(generator.next(), 4);\n    });\n\n    test(\"getUniqueId is a static generator\", function() {\n        equal(T.Utils.getUniqueId(), 0);\n        equal(T.Utils.getUniqueId(), 1);\n        equal(T.Utils.getUniqueId(), 2);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/idGenerator.tests.js");
window.eval("(function () {\n    var deferreds;\n\n    module(\"Unit.Utilities.jquery.complete\", {\n        setup: function() { deferreds = [ $.Deferred(), $.Deferred() ]; }\n    });\n\n    test(\"complete resolves when at least one deferred resolves\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].resolve();\n        equal(result.state(), 'resolved');\n    });\n\n    test(\"complete rejects when all passed deferreds reject\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].reject();\n        equal(result.state(), 'rejected');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/jquery.complete.tests.js");
window.eval("(function() {\n    module('Unit.Utilities.nodes', {\n        setup: function () {\n            T.Events.spy = sinon.spy();\n            T.options.events = ['spy'];\n        }\n    });\n\n    test(\"createNode executes events specified in options with new node\", function () {\n        T.createNode('#qunit-fixture');\n        ok(T.Events.spy.calledOnce);\n        ok(pane());\n    });\n\n    test(\"appendNode appends wrapper to target element\", function() {\n        T.appendNode('#qunit-fixture');\n        equal($('#qunit-fixture div').length, 1);\n    });\n\n    function pane() {\n        return T.Events.spy.firstCall.args[0];\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/nodes.tests.js");
window.eval("(function() {\n    var utils = T.Utils;\n    module('Unit.Utilities.objects');\n\n    test(\"arguments.byConstructor\", function() {\n        var argsToPass = [\"\", {}, function() {\n        }, [], 2.2];\n\n        (function() {\n            var args = utils.arguments(arguments);\n            equal(args.string, argsToPass[0]);\n            equal(args.object, argsToPass[1]);\n            equal(args.func, argsToPass[2]);\n            equal(args.array, argsToPass[3]);\n            equal(args.number, argsToPass[4]);\n\n        }).apply(null, argsToPass);\n    });\n\n    test(\"removeItem removes matching item from array\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 2);\n        deepEqual(array, [1, 3]);\n    });\n\n    test(\"removeItem does not affect array if item does not exist\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 4);\n        deepEqual(array, [1, 2, 3]);\n    });\n\n    test(\"inheritOptions\", function() {\n        var source = { test1: 'test', test2: 2 };\n        equal(T.Utils.inheritOptions(source, {}, ['test1']).test1, 'test');\n        equal(T.Utils.inheritOptions(source, {}, ['test2']).test2, 2);\n        equal(T.Utils.inheritOptions(source, {}, ['test1', 'test2', 'test3']).test3, undefined);\n    });\n    \n    test(\"cloneData\", function () {\n        var object = {};\n        var result = utils.cloneData({\n            func: function () { },\n            string: 'string',\n            object: object,\n            observable: ko.observable('test'),\n            except1: 'except1',\n            except2: 'except2'\n        }, 'except1', 'except2');\n\n        equal(result.func, undefined);\n        equal(result.string, 'string');\n        equal(result.object, object);\n        equal(result.observable, 'test');\n        equal(result.except1, undefined);\n        equal(result.except2, undefined);\n    });\n\n    test(\"cloneData handles value objects\", function () {\n        equal(utils.cloneData('test'), 'test');\n        equal(utils.cloneData(1), 1);\n    });\n    \n    test(\"normaliseBindings evaluates function passed as value\", function () {\n        equal(utils.normaliseBindings(value, function () { return {}; }).value, 'test');\n\n        function value() {\n            return function () {\n                return 'test';\n            };\n        }\n    });\n})();\n//@ sourceURL=tribe://Unit/Utilities/objects.tests.js");
window.eval("(function () {\n    var utils = T.Utils;\n    \n    module('Unit.Utilities.panes');\n\n    test(\"getPaneOptions\", function () {\n        deepEqual(utils.getPaneOptions('test'), { path: 'test' }, \"accepts string value as path\");\n        deepEqual(utils.getPaneOptions('test', { data: 'data' }), { path: 'test', data: 'data' }, \"accepts string value as path and merges other options\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }), { path: 'test' }, \"accepts options object\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }, { data: 'data' }), { path: 'test', data: 'data' }, \"accepts options object and merges other options\");\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/panes.tests.js");
window.eval("(function () {\n    module(\"Unit.Utilities.Path\");\n\n    test('Path handles empty arguments', function () {\n        equal(T.Path('').toString(), '');\n        equal(T.Path(undefined).toString(), '');\n        equal(T.Path(null).toString(), '');\n    });\n\n    test(\"withoutFilename\", function () {\n        equal(T.Path(\"/folder/subfolder/filename.ext\").withoutFilename().toString(), \"/folder/subfolder/\", \"Path with slashes\");\n    });\n\n    test(\"filename\", function () {\n        equal(T.Path(\"filename.ext\").filename().toString(), \"filename.ext\", \"Filename\");\n        equal(T.Path(\"/filename.ext\").filename().toString(), \"filename.ext\", \"Root path filename\");\n        equal(T.Path(\"/folder/subfolder/filename.ext\").filename().toString(), \"filename.ext\", \"Path with slashes\");\n    });\n\n    test(\"extension\", function () {\n        equal(T.Path(\"filename.ext\").extension().toString(), \"ext\", \"Filename\");\n        equal(T.Path(\"/filename.ext\").extension().toString(), \"ext\", \"Root path filename\");\n        equal(T.Path(\"filename\").extension().toString(), \"\", \"Filename without extension\");\n        equal(T.Path(\"/filename\").extension().toString(), \"\", \"Root path filename without extension\");\n        equal(T.Path(\"filename.\").extension().toString(), \"\", \"Empty extension\");\n        equal(T.Path(\"/folder/subfolder/filename.ext\").extension().toString(), \"ext\", \"Path with slashes\");\n    });\n\n    test(\"withoutExtension\", function () {\n        equal(T.Path(\"filename.ext\").withoutExtension().toString(), \"filename\");\n        equal(T.Path(\"filename\").withoutExtension().toString(), \"filename\");\n        equal(T.Path(\"/test/filename.ext\").withoutExtension().toString(), \"/test/filename\");\n        equal(T.Path(\"/test/filename\").withoutExtension().toString(), \"/test/filename\");\n        equal(T.Path(\"/test/filename.ext\").filename().withoutExtension().toString(), \"filename\");\n        equal(T.Path(\"/test/filename\").filename().withoutExtension().toString(), \"filename\");\n    });\n\n    test(\"Path objects can be concatenated with strings\", function () {\n        equal(T.Path('/folder/filename.ext').withoutFilename() + 'new.ext', '/folder/new.ext');\n    });\n\n    test(\"isAbsolute\", function () {\n        ok(T.Path(\"/test/\").isAbsolute());\n        ok(T.Path(\"http://test/\").isAbsolute());\n        ok(!T.Path(\"test/\").isAbsolute());\n        ok(!T.Path(\"test.txt\").isAbsolute());\n        ok(!T.Path(\"../test.txt\").isAbsolute());\n    });\n\n    test(\"makeAbsolute\", function () {\n        equal(T.Path(\"/test\").makeAbsolute().toString(), \"/test\");\n        equal(T.Path(\"test\").makeAbsolute().toString(), \"/test\");\n        equal(T.Path(\"test.txt\").makeAbsolute().toString(), \"/test.txt\");\n        equal(T.Path(\"test/test.txt\").makeAbsolute().toString(), \"/test/test.txt\");\n    });\n\n    test(\"makeRelative\", function () {\n        equal(T.Path(\"test\").makeRelative().toString(), \"test\");\n        equal(T.Path(\"/test\").makeRelative().toString(), \"test\");\n        equal(T.Path(\"/test.txt\").makeRelative().toString(), \"test.txt\");\n        equal(T.Path(\"/test/test.txt\").makeRelative().toString(), \"test/test.txt\");\n    });\n\n    test(\"normalise\", function () {\n        equal(T.Path('test').toString(), 'test');\n        equal(T.Path('../test').toString(), '../test');\n        equal(T.Path('test1/../test2').toString(), 'test2');\n        equal(T.Path('/test1/../test2').toString(), '/test2');\n        equal(T.Path('/test1/../test2/../test3').toString(), '/test3');\n        equal(T.Path('./test').toString(), 'test');\n        equal(T.Path('test1/./test2').toString(), 'test1/test2');\n        equal(T.Path('.././test1/../test2').toString(), '../test2');\n        equal(T.Path('http://test//test.htm').toString(), 'http://test/test.htm');\n        equal(T.Path('http://test///test//test.htm').toString(), 'http://test/test/test.htm');\n        equal(T.Path('1///2//3/4/5').toString(), '1/2/3/4/5');\n    });\n\n    test(\"asPathIdentifier\", function () {\n        equal(T.Path('test.txt').asMarkupIdentifier().toString(), 'test');\n        equal(T.Path('test/test.txt').asMarkupIdentifier().toString(), 'test-test');\n    });\n\n    test(\"setExtension\", function() {\n        equal(T.Path('/test/test').setExtension('js').toString(), '/test/test.js');\n        equal(T.Path('/test/test.txt').setExtension('js').toString(), '/test/test.js');\n    });\n\n    test(\"combine\", function() {\n        equal(T.Path('/test/').combine('/test.txt').toString(), '/test/test.txt');\n        equal(T.Path('http://test/').combine('/test.txt').toString(), 'http://test/test.txt');\n        equal(T.Path('/1/').combine('/2/').combine('/test.txt').toString(), '/1/2/test.txt');\n        equal(T.Path('').combine('test.txt').toString(), 'test.txt');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/Path.tests.js");
window.eval("(function () {\n    module('Unit.Utilities.querystring');\n    \n    var querystring = T.Utils.Querystring;\n\n    test(\"stringify handles flat objects\", function() {\n        equal(querystring.stringify({ test: 't', test2: 2 }), 'test=t&test2=2');\n    });\n    \n    test(\"stringify handles nested objects\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: 't' } })), 'test[test2]=t');\n        equal(decodeURI(querystring.stringify({ test: { test2: { test3: 't' } } })), 'test[test2][test3]=t');\n    });\n\n    test(\"stringify handles arrays\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } })), 'test[test2][][test3]=t');\n    });\n\n    test(\"stringify handles arrays with arrayKey set to false\", function () {\n        equal(\n            decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } }, { arrayKey: false })),\n            'test[test2][test3]=t');\n    });\n\n    test(\"stringify raises if source contains cyclic references\", function () {\n        raises(function () {\n            var test1 = {};\n            var test2 = { test1: test1 };\n            test1.test2 = test2;\n            querystring.stringify(test1);\n        });\n    });\n\n    test(\"parse handles flat objects\", function () {\n        deepEqual(querystring.parse('test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse strips leading question mark\", function () {\n        deepEqual(querystring.parse('?test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse handles nested objects\", function () {\n        deepEqual(querystring.parse('test[test2]=t'), { test: { test2: 't' } });\n        deepEqual(querystring.parse('test[test2][test3]=t'), { test: { test2: { test3: 't' } } });\n    });\n\n    test(\"parse handles arrays\", function () {\n        deepEqual(querystring.parse('test[test2][][test3]=t'), { test: { test2: [{ test3: 't' }] } });\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/querystring.tests.js");
window.eval("(function () {\n    var history;\n    var api;\n\n    module('Unit.Types.History', {\n        setup: function () {\n            api = mockHistoryApi();\n            history = new T.Types.History(api);\n        },\n        teardown: function () {\n            history.dispose();\n        }\n    });\n\n    test(\"browser.go is raised when popstate event is raised normally\", function () {\n        if (Test.supportsHistory) {\n            expect(1);\n\n            function assert(e) {\n                equal(e.eventData.count, 1);\n            }\n\n            T.Utils.handleDocumentEvent('browser.go', assert);\n            raisePopstate();\n            T.Utils.detachDocumentEvent('browser.go', assert);\n        } else ok(true, \"Test skipped - History API is not supported.\");\n    });\n\n    test(\"browser.go is not raised when update is called and popstate is raised\", function () {\n        if (Test.supportsHistory) {\n            expect(0);\n\n            function assert(e) {\n                equal(e.eventData.count, 1);\n            }\n\n            T.Utils.handleDocumentEvent('browser.go', assert);\n            history.update(1);\n            raisePopstate();\n            T.Utils.detachDocumentEvent('browser.go', assert);\n        } else ok(true, \"Test skipped - History API is not supported.\");\n    });\n\n    test(\"window.history.go is called when go is called\", function () {\n        history.go(1);\n        ok(api.go.calledOnce);\n    });\n\n    test(\"window.history.pushState is called when navigate is called\", function() {\n        history.navigate();\n        ok(api.pushState.calledOnce);\n    });\n\n    test(\"window.history.pushState is called with url and title if urlProvider is passed\", function() {\n        history.navigate({ url: 'url1', title: 'title1' });\n        equal(api.pushState.firstCall.args[1], 'title1');\n        equal(api.pushState.firstCall.args[2], 'url1');\n    });\n\n    function mockHistoryApi() {\n        return {\n            pushState: sinon.spy(),\n            go: sinon.spy(),\n            replaceState: sinon.spy()\n        };\n    }\n\n    function raisePopstate() {\n        var e = new Event(\"popstate\");\n        e.state = 1;\n        window.dispatchEvent(e);\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/History.tests.js");
window.eval("(function() {\n    var resources;\n    var context;\n    \n    module(\"Unit.Types.Loader\", {\n        setup: function () {\n            context = Test.Unit.context();\n            resources = new T.Types.Loader();\n        }\n    });\n\n    test(\"get should call handler for file extension from passed url\", function () {\n        var spy = sinon.spy();\n        T.LoadHandlers.test = spy;\n        resources.get('test.test');\n        ok(spy.calledOnce);\n    });\n\n    test(\"get should call handler with url, resourcePath and context\", function () {\n        var spy = sinon.spy();\n        T.LoadHandlers.test = spy;\n        resources.get('test.test', 'test/test', context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'test.test');\n        equal(spy.firstCall.args[1], 'test/test');\n        equal(spy.firstCall.args[2], context);\n    });\n\n    test(\"when passed the same url, get should return the same deferred from first call to handler\", function () {\n        var deferred = $.Deferred();\n        T.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        equal(resources.get('test.test'), deferred);\n    });\n\n    test(\"get should return null after deferred from first call to handler completes\", function () {\n        var deferred = $.Deferred();\n        T.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.resolve();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return null after deferred from first call to handler fails\", function () {\n        var deferred = $.Deferred();\n        T.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.reject();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return different deferred for each unique url\", function () {\n        T.LoadHandlers.test = function () { return $.Deferred(); };\n        var result1 = resources.get('test1.test');\n        var result2 = resources.get('test2.test');\n        notEqual(result1, result2);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Types/Loader.tests.js");
window.eval("(function () {\n    var nav;\n    var node;\n\n    module('Unit.Types.Navigation', {\n        setup: function () {\n            node = nodeStub('test');\n            nav = new T.Types.Navigation(node, { transition: 'fade' });\n            T.history = { navigate: sinon.spy(), update: sinon.spy() };\n        },\n        teardown: function() {\n            nav.dispose();\n        }\n    });\n\n    test(\"forward transitions to specified pane\", function () {\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"forward accepts string transition as options\", function () {\n        nav = new T.Types.Navigation(node, 'fade');\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"back returns to initial pane with reverse transition\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n        equal(node.transitionTo.secondCall.args[2], true);\n    });\n\n    test(\"back returns to previous pane\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"back does nothing if no stack\", function () {\n        nav.go(-1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"forward does nothing if no stack\", function () {\n        nav.go(1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"back two returns to initial pane\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        equal(node.transitionTo.lastCall.args[0].path, 'test');\n    });\n\n    test(\"forward moves stack forward if stack exists\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        nav.go(1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"document navigating event is raised when navigating\", function () {\n        expect(1);\n        T.Utils.handleDocumentEvent('navigating', assert);\n        nav.navigate({ path: 'test2' });\n        T.Utils.detachDocumentEvent('navigating', assert);\n        \n        function assert(e) {\n            equal(e.eventData.options.path, 'test2');\n        }\n    });\n\n    test(\"T.history.navigate is called on navigate when browser option is set\", function() {\n        nav = new T.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        ok(T.history.navigate.calledOnce);\n    });\n\n    test(\"T.history.update is called on go when browser option is set\", function () {\n        nav = new T.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        ok(T.history.update.calledOnce);\n    });\n\n    test(\"node transitions when browser.go event is received\", function() {\n        nav = new T.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        T.Utils.raiseDocumentEvent('browser.go', { count: -1 });\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n    });\n\n    test(\"initial state is set from urlProvider if paneOptionsFrom returns paneOptions object\", function () {\n        var provider = {\n            paneOptionsFrom: function() {\n                return {\n                    path: 'test',\n                    data: { test: 'test' }\n                };\n            }\n        };\n        nav = new T.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0], provider.paneOptionsFrom());\n    });\n\n    test(\"initial state is not set from urlProvider if paneOptionsFrom returns null\", function() {\n        var provider = {\n            paneOptionsFrom: function () { return null; }\n        };\n        nav = new T.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0].path, 'test');\n    });\n\n    test(\"history url and title are set from urlProvider when navigating\", function () {\n        var provider = {\n            paneOptionsFrom: function () { return null; },\n            urlDataFrom: function() {\n                return {\n                    url: 'test',\n                    title: 'test'\n                };\n            }\n        };\n        nav = new T.Types.Navigation(node, { browser: provider });\n        nav.navigate({ path: 'test2' });\n        deepEqual(T.history.navigate.firstCall.args[0], provider.urlDataFrom());\n    });\n\n    Test.urlProvider = {\n        urlDataFrom: function() {\n            return {\n                url: 'test',\n                title: 'test'\n            };\n        },\n        paneOptionsFrom: function() {\n            return {\n                path: 'test',\n                data: { test: 'test' }\n            };\n        }\n    };\n\n    function nodeStub(path) {\n        return {\n            id: 1,\n            pane: { path: path },\n            transitionTo: sinon.spy()\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Navigation.tests.js");
window.eval("(function () {\n    module('Unit.Types.Node');\n\n    test(\"node creates Navigation if handlesNavigation is set on pane\", function() {\n        var node = new T.Types.Node(null, pane('test', true));\n        ok(node.navigation);\n    });\n\n    test(\"findNavigation returns Navigation for root node if no pane handles navigation\", function() {\n        var leaf = createTree();\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for root node if specified\", function () {\n        var leaf = createTree('root');\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for middle node if specified\", function () {\n        var leaf = createTree('middle');\n        equal(leaf.findNavigation().node, leaf.parent);\n        equal(leaf.parent.findNavigation().node, leaf.parent);\n        equal(leaf.root.findNavigation().node, leaf.parent);\n    });\n\n    test(\"findNavigation returns Navigation for leaf node if specified\", function () {\n        var leaf = createTree('leaf');\n        equal(leaf.findNavigation().node, leaf);\n        equal(leaf.parent.findNavigation().node, leaf);\n        equal(leaf.root.findNavigation().node, leaf);\n    });\n\n    test(\"findNavigation returns Navigation for root node if handling node disposed\", function () {\n        var leaf = createTree('leaf');\n        var middle = leaf.parent;\n        leaf.dispose();\n        equal(middle.findNavigation().node, middle.root);\n        equal(leaf.parent.findNavigation().node, middle.root);\n    });\n    \n    function pane(path, handlesNavigation) {\n        return new T.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    function createTree(navigationNode) {\n        var root = new T.Types.Node(null, pane('root', navigationNode === 'root'));\n        var middle = new T.Types.Node(root, pane('middle', navigationNode === 'middle'));\n        var leaf = new T.Types.Node(middle, pane('leaf', navigationNode === 'leaf'));\n        return leaf;\n    }\n})();\n//@ sourceURL=tribe://Unit/Types/Node.findNavigation.tests.js");
window.eval("(function () {\n    module('Unit.Types.Node');\n\n    function pane(path, handlesNavigation) {\n        return new T.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    test(\"setPane makes path absolute and sets pane path from pane if no parent\", function() {\n        var node = new T.Types.Node(null, pane('test'));\n        equal(node.pane.path, '/test');\n    });\n\n    test(\"setPane sets pane path from parent and relative pane path\", function () {\n        var parent = new T.Types.Node(null, pane('/path/parent'));\n        var node = new T.Types.Node(parent, pane('child'));\n        equal(node.pane.path, '/path/child');\n    });\n\n    test(\"setPane sets pane path from pane if path is absolute\", function () {\n        var parent = new T.Types.Node(null, pane('/path/parent'));\n        var node = new T.Types.Node(parent, pane('/root'));\n        equal(node.pane.path, '/root');\n    });\n\n    test(\"setPane unsets node on existing pane\", function () {\n        var existingPane = pane('test');\n        var node = new T.Types.Node(null, existingPane);\n        node.setPane(new T.Types.Pane(pane('test2')));\n        equal(existingPane.node, null);\n    });\n\n    test(\"setPane sets node.navigation when pane.handlesNavigation\", function() {\n        var node = new T.Types.Node();\n        node.setPane(pane('', 'test'));\n        ok(node.navigation.constructor, T.Types.Navigation);\n    });\n\n    test(\"node root is set correctly\", function() {\n        var one = new T.Types.Node(null, pane('one'));\n        var two = new T.Types.Node(one, pane('two'));\n        var three = new T.Types.Node(two, pane('three'));\n\n        equal(one.root, one);\n        equal(two.root, one);\n        equal(three.root, one);\n    });\n\n    test(\"dispose removes node from parent collection\", function() {\n        var parent = new T.Types.Node(null, pane('parent'));\n        var child = new T.Types.Node(parent, pane('child'));\n        equal(parent.children.length, 1);\n        child.dispose();\n        equal(parent.children.length, 0);\n    });\n\n    test(\"navigate inherits path from existing pane\", function () {\n        var node = new T.Types.Node(null, pane('/path/node1'));\n        node.transitionTo = sinon.spy();\n        node.navigate('node2');\n        ok(node.transitionTo.calledOnce);\n        equal(node.transitionTo.firstCall.args[0].path, '/path/node2');\n    });\n\n    test(\"nodeForPath returns current node if skipPath is not specified\", function() {\n        var node1 = new T.Types.Node(null, pane('/path1/node1'));\n        var node2 = new T.Types.Node(node1, pane('/path2/node2'));\n        equal(node2.nodeForPath(), node2);\n    });\n\n    test(\"nodeForPath returns parent if skipPath is specified\", function() {\n        var node1 = new T.Types.Node(null, pane('/path1/node1'));\n        var node2 = new T.Types.Node(node1, pane('/path2/node2'));\n        node2.skipPath = true;\n        equal(node2.nodeForPath(), node1);\n    });\n\n    test(\"nodeForPath recurses, skipping nodes as specified\", function () {\n        var node1 = new T.Types.Node(null, pane('/path1/node1'));\n        var node2 = new T.Types.Node(node1, pane('/path2/node2'));\n        var node3 = new T.Types.Node(node2, pane('/path2/node2'));\n        node2.skipPath = true;\n        node3.skipPath = true;\n        equal(node3.nodeForPath(), node1);\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Node.tests.js");
window.eval("(function () {\n    var operation;\n    \n    module(\"Unit.Types.Operation\", {\n        setup: function() { operation = new T.Types.Operation(); }\n    });\n\n    test(\"operation resolves when single child completes\", function () {\n        operation.add(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(1);\n        equal(operation.promise.state(), 'resolved');\n    });\n\n    test(\"operation resolves when two children complete\", function() {\n        operation.add(1);\n        operation.add(2);\n        operation.complete(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(2);\n        equal(operation.promise.state(), 'resolved');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Types/Operation.tests.js");
window.eval("(function() {\n    module('Unit.Types.Pane');\n\n    test(\"inheritPathFrom inherits path if pane path is relative\", function () {\n        var pane = new T.Types.Pane({ path: 'pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/pane2');\n    });\n\n    test(\"inheritPathFrom doesn't inherit path if pane path is absolute\", function () {\n        var pane = new T.Types.Pane({ path: '/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/pane2');\n    });\n\n    test(\"inheritPathFrom sets child folders from relative pane path\", function () {\n        var pane = new T.Types.Pane({ path: 'Test2/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/Test2/pane2');\n    });\n    \n    function wrap(pane) {\n        return {\n            nodeForPath: function() {\n                return { pane: pane };\n            }\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Pane.tests.js");
window.eval("(function () {\n    var events;\n    var pipeline;\n    var eventDeferred;\n    var context = {};\n\n    module(\"Unit.Types.Pipeline\", {\n        setup: function() {\n            events = testEvents();\n            pipeline = new T.Types.Pipeline(events, context);\n        }\n    });\n\n    test(\"event handlers specified are called\", function () {\n        pipeline.execute(['null1']);\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"event handlers are passed target and context\", function () {\n        var target = {};\n        pipeline.execute(['null1'], target);\n        ok(events.null1.calledWithExactly(target, context));\n    });\n\n    test(\"events returning null are executed synchronously\", function () {\n        pipeline.execute(['null1', 'null2']);\n        ok(events.null1.calledOnce);\n        ok(events.null2.calledOnce);\n    });\n\n    test(\"events are executed when previous event resolves\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        ok(events.null1.notCalled);\n        eventDeferred.resolve();\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"rejected events terminate pipeline execution\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        eventDeferred.reject();\n        ok(events.null1.notCalled);\n    });\n\n    test(\"execute returns deferred that resolves on completion\", function() {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.resolve();\n        equal(deferred.state(), 'resolved');\n    });\n    \n    test(\"execute returns deferred that rejects on failure\", function () {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.reject();\n        equal(deferred.state(), 'rejected');\n    });\n\n    function testEvents() {\n        eventDeferred = $.Deferred();\n        \n        return {\n            null1: sinon.spy(),\n            null2: sinon.spy(),\n            deferred: sinon.stub().returns(eventDeferred)\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Pipeline.tests.js");
window.eval("(function() {\n    var models;\n\n    module('Unit.Types.Resources', {\n        setup: function () { models = new T.Types.Resources(); }\n    });\n\n    test(\"register stores model as property with constructor and options\", function () {\n        var constructor = function () { };\n        var options = {};\n        models.register('test', constructor, options);\n        equal(models.test.constructor, constructor);\n        equal(models.test.options, options);\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Resources.tests.js");
window.eval("(function () {\n    module('Unit.Types.StringCollection');\n\n    test(\"insertBefore inserts item before matched item\", function () {\n        var c = T.Types.StringCollection(['a', 'b']);\n        deepEqual(c.insertBefore('a', 'a1'), ['a1', 'a', 'b']);\n        deepEqual(c.insertBefore('b', 'b1'), ['a1', 'a', 'b1', 'b']);\n    });\n\n    test(\"insertAfter inserts item before matched item\", function () {\n        var c = T.Types.StringCollection(['a', 'b']);\n        deepEqual(c.insertAfter('a', 'a1'), ['a', 'a1', 'b']);\n        deepEqual(c.insertAfter('b', 'b1'), ['a', 'a1', 'b', 'b1']);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Types/StringCollection.tests.js");
window.eval("(function () {\n    var templates;\n    \n    module('Unit.Types.Templates', {\n        setup: function () { templates = new T.Types.Templates(); },\n        teardown: function () { $('head script[type=\"text/template\"]').remove(); }\n    });\n\n    test(\"store wraps template in script tag with resource path as id\", function() {\n        templates.store('<br/>', 'test');\n        notEqual($('head script#template-test').html().indexOf('<br/>'), -1);\n    });\n\n    test(\"render replaces content of target with stored template\", function () {\n        $('#qunit-fixture').text('previous');\n        templates.store('content', 'test');\n        templates.render('#qunit-fixture', 'test');\n        notEqual($('#qunit-fixture').html().indexOf('content'), -1);\n    });\n    \n    test(\"loaded returns true if template has been loaded for specified path\", function () {\n        templates.store('<br/>', 'test');\n        ok(templates.loaded('test'));\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Templates.tests.js");
window.eval("(function() {\n    var originalEval = $.globalEval;\n    var url = 'test.js';\n    var resourcePath = '/test';\n    var response = \"\";\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n    \n    module(\"Unit.LoadHandlers.scripts\", {\n        setup: function() {\n            context = Test.Unit.context();\n        },\n        teardown: function () { $.globalEval = originalEval; }\n    });\n\n    test(\"script handler returns promise object\", function() {\n        ok(T.LoadHandlers.js(url, resourcePath, context).promise);\n    });\n\n    test(\"script handler executes globalEval with response\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        T.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(0, response.length), response);\n    });\n\n    test(\"script handler appends sourceURL tag\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        T.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(response.length + 1), \"//@ sourceURL=tribe://Application/test.js\");\n    });\n\n    test(\"script handler sets T.scriptEnvironment before executing scripts\", function () {\n        expect(1);\n        response = \"equal(T.scriptEnvironment.resourcePath, '\" + resourcePath + \"');\";\n        T.LoadHandlers.js(url, resourcePath, context);\n    });\n\n    test(\"script handler clears T.scriptEnvironment after executing scripts\", function () {\n        T.LoadHandlers.js(url, resourcePath, context);\n        equal(T.scriptEnvironment, undefined);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/scripts.tests.js");
window.eval("(function() {\n    var url = 'test.css';\n    var resourcePath = '/test';\n    var response = \"\";\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.stylesheets');\n    \n    test(\"stylesheet handler returns promise object\", function() {\n        ok(T.LoadHandlers.css(url, resourcePath, Test.Unit.context()).promise);\n    });\n\n    test(\"stylesheet handler adds stylesheet to page header\", function () {\n        response = \".test{}\";\n        T.LoadHandlers.css(url, resourcePath, Test.Unit.context());\n        notEqual($('#__tribeStyles').html().indexOf(\".test\"), -1);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/stylesheets.tests.js");
window.eval("(function() {\n    var url = 'test.htm';\n    var resourcePath = '/test';\n    var response = '<br/>';\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.templates', {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"template handler returns promise object\", function() {\n        ok(T.LoadHandlers.htm(url, resourcePath, context).promise);\n    });\n\n    test(\"template is stored with resource path identifier\", function() {\n        T.LoadHandlers.htm(url, resourcePath, context);\n        ok(context.templates.store.calledOnce);\n        ok(context.templates.store.calledWithExactly('<br/>', '/test'));\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/templates.tests.js");
window.eval("(function () {\n    var context;\n    \n    module(\"Unit.LoadStrategies.adhoc\", {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"loader.get is called for each resource\", function () {\n        T.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.calledThrice);\n        ok(context.loader.get.firstCall.calledWithExactly('new.js', 'new', context));\n        ok(context.loader.get.secondCall.calledWithExactly('new.htm', 'new', context));\n        ok(context.loader.get.thirdCall.calledWithExactly('new.css', 'new', context));\n    });\n\n    test(\"loader.get is called with base path combined with pane path\", function () {\n        context = Test.Unit.context();\n        context.options.basePath = 'panes';\n        T.LoadStrategies.adhoc({ path: 'test2' }, context);\n        ok(context.loader.get.firstCall.calledWithExactly('panes/test2.js', 'test2', context));\n    });\n\n    test(\"subsequent calls with the same path returns the same deferred object\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function() { return deferred; };\n        var result1 = T.LoadStrategies.adhoc({ path: 'test' }, context);\n        var result2 = T.LoadStrategies.adhoc({ path: 'test' }, context);\n        equal(result1, result2);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been resolved\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        T.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.resolve();\n        equal(T.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been rejected\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        T.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.reject();\n        equal(T.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"loader.get is not called when model has been loaded\", function () {\n        T.LoadStrategies.adhoc({ path: 'test' }, context);\n        ok(context.loader.get.notCalled);\n    });\n\n    test(\"loader.get is not called when template has been loaded\", function () {\n        context.templates.loaded = function() { return true; };\n        T.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Unit/LoadStrategies/adhoc.tests.js");
window.eval("module('Unit.LoadStrategies.preloaded');\n\ntest(\"returns rejected promise if no resources have been loaded for the specified path\", function() {\n    var context = Test.Unit.context();\n    var promise = T.LoadStrategies.preloaded({ path: 'test2' }, context);\n    equal(promise.state(), 'rejected');\n});\n//@ sourceURL=tribe://Unit/LoadStrategies/preloaded.tests.js");
window.eval("(function () {\n    var context;\n    var node;\n    \n    module(\"Unit.Events.createModel\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n        }\n    });\n\n    test(\"model is created from stored constructor\", function () {\n        T.Events.createModel(pane, context);\n        ok(context.models.test.constructor.calledOnce);\n    });\n\n    test(\"default model is created if no constructor defined\", function () {\n        context.models.test.constructor = null;\n        T.Events.createModel(pane, context);\n        equal(pane.model.pane, pane);\n    });\n})();\n//@ sourceURL=tribe://Unit/Events/createModel.tests.js");
window.eval("(function () {\n    var pane, context;\n    \n    module(\"Unit.Events.renderComplete\", {\n        setup: function() {\n            pane = new T.Types.Pane({ element: '#qunit-fixture', transition: 'test' });\n            pane.model = { renderComplete: sinon.spy() };\n            context = Test.Unit.context();\n            T.Transitions.test = { 'in': sinon.spy() };\n        }\n    });\n\n    test(\"renderComplete calls transition.in with pane element\", function () {\n        T.Events.renderComplete(pane, context);\n        ok(T.Transitions.test['in'].calledOnce);\n        equal(T.Transitions.test['in'].firstCall.args[0], pane.element);\n    });\n\n    test(\"renderComplete calls renderComplete on pane model\", function () {\n        T.Events.renderComplete(pane, context);\n        ok(pane.model.renderComplete.calledOnce);\n    });\n\n    test(\"renderComplete resolves is.rendered on pane model\", function () {\n        equal(pane.is.rendered.state(), 'pending');\n        T.Events.renderComplete(pane, context);\n        equal(pane.is.rendered.state(), 'resolved');\n    });\n\n    test(\"renderComplete raises renderComplete event on document, passing pane as data\", function () {\n        var spy = sinon.spy();\n        T.Utils.handleDocumentEvent(\"renderComplete\", spy);\n        T.Events.renderComplete(pane, context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0].eventData, pane);\n        T.Utils.detachDocumentEvent(\"renderComplete\", spy);\n    });\n})();\n//@ sourceURL=tribe://Unit/Events/renderComplete.tests.js");
window.eval("(function () {\n    var node;\n    var context;\n\n    module(\"Unit.Events.renderPane\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n            context.setTemplate('<div/>');\n        }\n    });\n\n    test(\"templates.render is called with identifier and element\", function () {\n        T.Events.renderPane(pane, context);\n        ok(context.templates.render.calledOnce);\n        ok(context.templates.render.calledWithExactly(pane.element, 'test'));\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Events/renderPane.tests.js");
window.eval("(function () {\n    var pane, node;\n    \n    module('Unit.transition', {\n        setup: function () {\n            Test.Integration.createTestElement();\n            T.Transitions.test = { 'in': sinon.spy(), out: sinon.spy(), reverse: 'test2' };\n            T.Transitions.test2 = { 'in': sinon.spy(), out: sinon.spy(), reverse: 'test' };\n            pane = new T.Types.Pane({ transition: 'test', element: '.test' });\n            node = new T.Types.Node(null, pane);\n        }\n    });\n\n    test(\"transition executes specified in transition against given element\", function () {\n        T.transition('.test', 'test')['in']();\n        equal(T.Transitions.test['in'].firstCall.args[0], '.test');\n    });\n\n    test(\"transition executes specified out transition against given element\", function () {\n        T.transition('.test', 'test').out();\n        equal(T.Transitions.test.out.firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from node\", function () {\n        T.transition(node)['in']();\n        equal(T.Transitions.test['in'].firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from pane\", function () {\n        T.transition(pane)['in']();\n        equal(T.Transitions.test['in'].firstCall.args[0], '.test');\n    });\n\n    test(\"specifying transition as argument overrides pane transition\", function() {\n        T.Transitions.test2 = { 'in': sinon.spy(), out: sinon.spy() };\n        T.transition(pane, 'test2')['in']();\n        ok(T.Transitions.test['in'].notCalled);\n        ok(T.Transitions.test2['in'].calledOnce);\n    });\n\n    test(\"transitioning out removes element by default\", function () {\n        T.transition('.test').out();\n        equal($('.test').length, 0);\n    });\n\n    test(\"transitioning out hides element if specified\", function () {\n        T.transition('.test').out(false);\n        equal($('.test').length, 1);\n    });\n\n    test(\"reverse transition is executed when specified\", function() {\n        T.transition('.test', 'test', true)['in']();\n        equal(T.Transitions.test2['in'].firstCall.args[0], '.test');\n\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Transitions/transition.tests.js");
window.eval("(function () {\n    module(\"Integration.api\", { teardown: Test.Integration.teardown });\n\n    test(\"arguments can be passed to registerModel in any order\", function () {\n        var path = 'path';\n        var options = {};\n        var constructor = function () { };\n\n        T.registerModel(path, options, constructor);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n\n        T.registerModel(options, constructor, path);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n    });\n\n    test(\"registerModel takes path from T.scriptEnvironment\", function () {\n        var constructor = function () { };\n        T.scriptEnvironment = { resourcePath: 'test' };\n        T.registerModel(constructor);\n        equal(Test.Integration.context.models.test.constructor, constructor);\n    });\n\n    test(\"registerActor takes path from T.scriptEnvironment\", function () {\n        var constructor = function () { };\n        T.scriptEnvironment = { resourcePath: 'test' };\n        T.registerActor(constructor);\n        equal(Test.Integration.context.actors.test.constructor, constructor);\n    });\n})();\n//@ sourceURL=tribe://Integration/api.tests.js");
window.eval("(function() {\n    module('Integration.bindingHandler', {\n        setup: function() {\n            T.Events.spy = sinon.spy();\n            T.options.events = ['spy'];\n        }, teardown: Test.Integration.teardown\n    });\n\n    test(\"pane path is set from string binding value\", function() {\n        executeHandler({ value: 'test' });\n        equal(pane().path, '/test');\n    });\n\n    test(\"pane properties are set from object binding value\", function() {\n        executeHandler({ value: { path: 'test', data: 'test2' } });\n        equal(pane().path, '/test');\n        equal(pane().data, 'test2');\n    });\n\n    test(\"pane data is set from other binding value\", function() {\n        executeHandler({ otherValues: { data: 'data' } });\n        equal(pane().data, 'data');\n    });\n\n    test(\"pane element is set from element argument\", function() {\n        executeHandler({ element: '#qunit-fixture' });\n        equal(pane().element, $('#qunit-fixture')[0]);\n    });\n\n    test(\"parent node is extracted from bindingContext\", function () {\n        var parentNode = Test.Unit.node();\n        executeHandler({ bindingContext: { $root: { __node: parentNode } } });\n        equal(pane().node.parent, parentNode);\n    });\n\n    function executeHandler(values) {\n        values = values || {};\n        return ko.bindingHandlers.pane.update(\n            values.element,\n            accessor(values.value || ''),\n            accessor(values.otherValues || {}),\n            values.viewModel,\n            values.bindingContext || {});\n    }\n\n    function accessor(value) {\n        return function() { return value; };\n    }\n\n    function pane() {\n        return T.Events.spy.firstCall.args[0];\n    }\n})();\n\n//@ sourceURL=tribe://Integration/bindingHandler.tests.js");
window.eval("//(function () {\n//    var history;\n\n//    module('Integration.History', {\n//        setup: function () {\n//            history = new T.Types.History(window.history);\n//            Test.Integration.createTestElement();\n//        },\n//        teardown: function() {\n//            history.dispose();\n//        }\n//    });\n\n//    test(\"History sets window state when navigating\", function () {\n//        T.createNode('.test', { path: 'History/layout' });\n//        T.nodeFor('.content1').navigate('content2');\n//        var options = JSON.parse(window.history.state.options);\n//        equal(options.path, '/History/content2');\n//    });\n\n//    // these tests sometimes seem to do strange things to the Chrome debugger. If breakpoints aren't being hit, this is the culprit.\n//    asyncTest(\"History transitions navigation node to previous state when back is called\", function () {\n//        expect(2);\n//        T.createNode('.test', { path: '/History/layout' });\n//        T.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function() {\n//            equal($('.content2').length, 0);\n//            equal($('.content1').length, 1);\n//            start();\n//        }, 50);\n//    });\n\n//    asyncTest(\"History transitions navigation node to next state when forward is called\", function () {\n//        expect(2);\n//        T.createNode('.test', { path: '/History/layout' });\n//        T.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function () {\n//            window.history.forward();\n//            setTimeout(function () {\n//                equal($('.content2').length, 1);\n//                equal($('.content1').length, 0);\n//                start();\n//            }, 50);\n//        }, 50);\n//    });\n\n//    test(\"document navigating event is raised once\", function () {\n//        expect(2);\n//        $(document).on('navigating', function(e, data) {\n//            equal(data.options.path, '/Navigate/content2');\n//            equal(data.options.data, 'test');\n//        });\n//        T.createNode('.test', { path: 'Navigate/layout' });\n//        T.nodeFor('.content1').navigate({ path: 'content2', data: 'test' });\n//        $(document).off('navigating');\n//    });\n//})();\n\n//@ sourceURL=tribe://Integration/History.tests.js");
window.eval("module('Integration.Navigate', {\n    setup: Test.Integration.createTestElement,\n    teardown: Test.Integration.teardown\n});\n\ntest(\"navigating child pane transitions node marked with handlesNavigation\", function () {\n    T.createNode('.test', { path: 'Navigate/layout' });\n    T.nodeFor('.child1').navigate('content2');\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating root pane transitions node marked with handlesNavigation\", function () {\n    T.createNode('.test', { path: 'Navigate/layout' });\n    T.nodeFor('.layout').navigate('content2');\n    equal($('.layout').length, 1);\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating back returns to previous pane\", function() {\n    T.createNode('.test', { path: 'Navigate/layout' });\n    var node = T.nodeFor('.layout');\n    node.navigate('content2');\n    equal($('.content1').length, 0);\n    node.navigateBack();\n    equal($('.content1').length, 1);\n});\n\ntest(\"setting observable on pane bindingHandler replaces node\", function () {\n    T.createNode('.test', { path: 'Navigate/observable' });\n    T.nodeFor('.observable').pane.model.currentPane('content2');\n    equal($('.observable').length, 1);\n    equal($('.content1').length, 0);\n    equal($('.content2').length, 1);\n    T.nodeFor('.observable').pane.model.currentPane('content1');\n    equal($('.content1').length, 1);\n    equal($('.content2').length, 0);\n});\n\ntest(\"setting observable on virtual pane bindingHandler replaces node\", function () {\n    T.createNode('.test', { path: 'Navigate/virtual' });\n    T.nodeFor('.virtual').pane.model.currentPane('content2');\n    equal($('.virtual').length, 1);\n    equal($('.content1').length, 0);\n    equal($('.content2').length, 1);\n    T.nodeFor('.virtual').pane.model.currentPane('content1');\n    equal($('.content1').length, 1);\n    equal($('.content2').length, 0);\n});\n\n//@ sourceURL=tribe://Integration/Navigate.tests.js");
window.eval("(function () {\n    module('Integration.nodes', { teardown: Test.Integration.teardown });\n\n    test(\"createNode binds pane to target element\", function() {\n        T.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n    });\n\n    test(\"appendNode appends wrapped pane to target element\", function() {\n        T.appendNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture div .parent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode called from paneRendered model function renders\", function() {\n        T.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode inherits context from parent element\", function () {\n        T.Events.spy = sinon.spy();\n        T.options.events = ['loadResources', 'createModel', 'initialiseModel', 'renderPane', 'paneRendered', 'renderComplete', 'spy', 'active', 'dispose'];\n\n        T.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        ok(T.Events.spy.calledTwice);\n        equal(T.Events.spy.firstCall.args[1], T.Events.spy.secondCall.args[1]);\n    });\n\n    test(\"createNode returns populated Node object\", function() {\n        var node = T.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal(node.pane.path, '/Utilities/parent');\n        equal(node.children.length, 1);\n    });\n\n    asyncTest(\"context.renderOperation resolves when render operation is complete\", function () {\n        expect(1);\n        T.options.synchronous = false;\n        var context = T.context();\n        T.createNode('#qunit-fixture', { path: 'Utilities/parent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function() {\n                equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n                start();\n            });\n    });\n\n    asyncTest(\"context.renderOperation includes dynamically added nodes\", function () {\n        expect(1);\n        T.options.synchronous = false;\n        var context = T.context();\n        T.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function () {\n                equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n                start();\n            });\n    });\n})();\n\n//@ sourceURL=tribe://Integration/nodes.tests.js");
window.eval("module('Integration.Paths', {\n    setup: Test.Integration.createTestElement,\n    teardown: Test.Integration.teardown\n});\n\ntest(\"panes created with skipPath true inherit pane path from their parent\", function() {\n    T.createNode('.test', { path: 'Paths/Subfolder/parent' });\n    equal($('.parent').length, 1);\n    equal($('.parent').children().length, 1);\n    equal($('.parent .child').length, 1);\n});\n//@ sourceURL=tribe://Integration/Paths.tests.js");
window.eval("module('Integration.PubSub', {\n    setup: function () {\n        Test.Integration.pubsubAsTribe();\n        Test.Integration.createTestElement();\n    }, teardown: Test.Integration.teardown\n});\n\ntest(\"subscription in pane is executed\", function() {\n    T.createNode('.test', { path: 'PubSub/subscriber' });\n    Test.Integration.context.pubsub.publish('test', 'message');\n    equal($('.subscriber').text(), 'message');\n});\n\ntest(\"subscription is removed when pane is removed from DOM\", function () {\n    T.createNode('.test', { path: 'PubSub/subscriber' });\n    equal(Test.Integration.context.pubsub.subscribers.get({ topic: 'test' }).length, 1);\n    $('.test').remove();\n    equal(Test.Integration.context.pubsub.subscribers.get({ topic: 'test' }).length, 0);\n});\n//@ sourceURL=tribe://Integration/PubSub.tests.js");
window.eval("module('Integration.Actors', {\n    setup: Test.Integration.createTestElement,\n    teardown: Test.Integration.teardown\n});\n\ntest(\"actors can be registered by name\", function () {\n    var func = function () { };\n    T.registerActor('test1', func);\n\n    equal(Test.Integration.context.actors.test1.constructor, func);\n});\n\ntest(\"actors can be registered using scriptEnvironment\", function () {\n    var func = function () { };\n    T.scriptEnvironment = { resourcePath: 'test2' };\n    T.registerActor(func);\n    delete T.scriptEnvironment;\n    \n    equal(Test.Integration.context.actors.test2.constructor, func);\n});\n//@ sourceURL=tribe://Integration/Sagas.tests.js");
window.eval("module('Integration.Scope', { setup: Test.Integration.pubsubAsTribe });\n\ntest(\"pane is scoped to value specified in pane options\", function () {\n    T.createNode('#qunit-fixture', { path: 'Scope/child', scope: { value: 'test' } });\n    var pubsub = T.nodeFor('#count').pane.pubsub,\n        rootPubsub = pubsub.owner;\n\n    // pubsub is the pane's pubsub, publishing is scoped too\n    pubsub.publish('topic');\n    equal($('#count').text(), '1');\n    equal($('#totalCount').text(), '1');\n\n    // using top level, unscoped pubsub\n    rootPubsub.publish('topic');\n    equal($('#count').text(), '1');\n    equal($('#totalCount').text(), '2');\n\n    rootPubsub.publish('topic', { value: 'test' });\n    equal($('#count').text(), '2');\n    equal($('#totalCount').text(), '3');\n\n    // outside of current scope\n    pubsub.publish('topic', { value: 'test2' });\n    equal($('#count').text(), '2');\n    equal($('#totalCount').text(), '4');\n});\n\n// test(\"pane is scoped to value specified in binding handler\", function () {\n//     T.createNode('#qunit-fixture', { path: 'Scope/middle' });\n//     var pubsub = T.nodeFor('#count').pane.pubsub.owner;\n//\n//     pubsub.publish('topic');\n//     equal($('#count').text(), '0');\n//\n//     pubsub.publish('topic', { value2: 'test2' });\n//     equal($('#count').text(), '1');\n// });\n//\n// test(\"scope cascades through panes\", function () {\n//     T.createNode('#qunit-fixture', { path: 'Scope/parent' });\n//     var pubsub = T.nodeFor('#count').pane.pubsub.owner;\n//\n//     pubsub.publish('topic');\n//     equal($('#count').text(), '0');\n//\n//     pubsub.publish('topic', { value: 'test' });\n//     equal($('#count').text(), '0');\n//\n//     pubsub.publish('topic', { value2: 'test2' });\n//     equal($('#count').text(), '0');\n//\n//     pubsub.publish('topic', { value: 'test', value2: 'test2' });\n//     equal($('#count').text(), '1');\n// });\n\n//@ sourceURL=tribe://Integration/Scope.tests.js");
window.eval("(function () {\n    module('Integration.Transition', {\n        setup: Test.Integration.createTestElement,\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"transitioning node replaces pane with specified pane\", function () {\n        T.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        T.transition(T.nodeFor('.pane1')).to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"transitioning element replaces pane with specified pane\", function () {\n        T.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        T.transition('.test').to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"specifying reverseTransitionIn pane option applies reverse transition\", function () {\n        if (Test.supportsTransitions) {\n            T.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n            ok($('.pane1').parent().hasClass('slideRight'));\n        } else ok(true, \"Test skipped - browser does not support CSS transitions.\");\n    });\n\n    test(\"specifying reverse argument applies reverse transition\", function () {\n        if (Test.supportsTransitions) {\n            T.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n            T.transition(T.nodeFor('.pane1'), null, true).to('Transition/pane2');\n            ok($('.pane1').parent().hasClass('slideRight'));\n            ok($('.pane2').parent().hasClass('slideRight'));\n        } else ok(true, \"Test skipped - browser does not support CSS transitions.\");\n    });\n\n    asyncTest(\"async transition to replaces pane with specified pane\", function () {\n        T.options.synchronous = false;\n        var context = T.context();\n        T.createNode('.test', { path: 'Transition/pane1' }, null, context);\n        $.when(context.renderOperation.promise).done(function() {\n            equal($('.pane1').length, 1);\n            $.when(T.transition('.test').to('Transition/pane2')).done(function() {\n                equal($('.pane1').length, 0);\n                equal($('.pane2').length, 1);\n                start();\n            });\n        });\n    });\n})();\n\n//@ sourceURL=tribe://Integration/Transition.tests.js");
window.eval("(function () {\n    var root;\n\n    module('Integration.Tree', {\n        setup: function() {\n             Test.Integration.executeDefaultEvents('Tree/1');\n             root = Test.state.pane.node.root;\n        }, teardown: Test.Integration.teardown\n    });\n\n    test(\"tree renders\", function () {\n        equal($('.111').length, 1);\n    });\n\n    test(\"node is created and attached to pane\", function () {\n        ok(Test.state.pane.node);\n        equal(Test.state.pane.path, '/Tree/1');\n    });\n\n    test(\"node is part of full node tree\", function () {\n        equal(root.children.length, 1);\n        equal(root.children[0].children.length, 2);\n        equal(root.children[0].children[1].pane.path, '/Tree/112');\n    });\n\n    test(\"node is removed from tree when pane element is remove from DOM\", function () {\n        equal(root.children[0].children.length, 2);\n        $('.111').parent().remove();\n        equal(root.children[0].children.length, 1);\n    });\n\n    test(\"pane changes when node is transitioned\", function () {\n        T.transition(T.nodeFor('.11')).to('12');\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n\n    test(\"child nodes are removed when transitioned\", function () {\n        T.transition(T.nodeFor('.11')).to('12');\n        equal(root.children[0].children.length, 0);\n    });\n\n    test(\"node is not replaced when transitioned\", function() {\n        var node = root.children[0];\n        T.transition(T.nodeFor('.11')).to('12');\n        equal(root.children[0], node);\n    });\n\n    test(\"node is replaced when element is transitioned\", function() {\n        var node = root.children[0];\n        T.transition($('.11').parent()).to('/Tree/12');\n        equal(root.children.length, 1);\n        notEqual(root.children[0], node);\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n\n    // test(\"child lifetime is ended when root lifetime is ended\", function () {\n    //     var spy = sinon.spy();\n    //     root.children[0].children[0].pane.pubsub.subscribe('topic', spy);\n    //     root.pane.pubsub.publish('topic');\n    //     equal(spy.callCount, 1);\n    //     root.pane.pubsub.end();\n    //     root.pane.pubsub.publish('topic');\n    //     equal(spy.callCount, 1);\n    // });\n    //\n    // test(\"child lifetime is ended when parent lifetime is ended\", function () {\n    //     var spy = sinon.spy();\n    //     root.children[0].children[0].pane.pubsub.subscribe('topic', spy);\n    //     root.pane.pubsub.publish('topic');\n    //     equal(spy.callCount, 1);\n    //     root.children[0].pane.pubsub.end();\n    //     root.pane.pubsub.publish('topic');\n    //     equal(spy.callCount, 1);\n    // });\n})();\n\n//@ sourceURL=tribe://Integration/Tree.tests.js");
window.eval("(function () {\n    var root;\n\n    module('Integration.Virtual', {\n        setup: function() {\n             Test.Integration.executeDefaultEvents('Virtual/parent');\n        }, teardown: Test.Integration.teardown\n    });\n\n    test(\"child pane is rendered\", function () {\n        equal($('.child').length, 1);\n    });\n\n    test(\"context can be retrieved for a virtual element\", function () {\n        ok(T.Utils.contextFor($('#qunit-fixture div')[0].childNodes[0]));\n    });\n})();\n\n//@ sourceURL=tribe://Integration/Virtual.tests.js");
window.eval("(function() {\n    module('Integration.Events.active', {\n        setup: function () { T.Events.spy = sinon.spy(); },\n        teardown: Test.Integration.teardown\n    });\n\n    var events = Test.Integration.testEventsUntil('active');\n\n    test(\"event ends when pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(T.Events.spy.notCalled);\n        $('.basic').parent().remove();\n        ok(T.Events.spy.called);\n        equal(T.Events.spy.firstCall.args[0].path, '/Events/basic');\n    });\n\n    test(\"child events end when parent pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        ok(T.Events.spy.notCalled);\n        $('.basicContainer').parent().remove();\n        ok(T.Events.spy.calledTwice);\n        equal(T.Events.spy.firstCall.args[0].path, '/Events/basicParent');\n        equal(T.Events.spy.secondCall.args[0].path, '/Events/basic');\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/active.tests.js");
window.eval("(function() {\n    module('Integration.Events.createModel', {\n        setup: function () { Test.Integration.executeEvents(Test.Integration.testEventsUntil('createModel'), 'Events/basic'); },\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"model is created and attached to pane object\", function () {\n        ok(Test.state.model);\n        ok(Test.state.pane.model);\n        equal(Test.state.model, Test.state.pane.model);\n    });\n\n})();\n//@ sourceURL=tribe://Integration/Events/createModel.tests.js");
window.eval("(function() {\n    module('Integration.Events.dispose', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('dispose');\n\n    test(\"dispose is called once on model when pane element is removed from DOM using jQuery\", function () {\n        Test.Integration.executeEvents(events, 'Events/dispose');\n        ok(!Test.state.disposeCalled);\n        $('.dispose').parent().remove();\n        equal(Test.state.disposeCallCount, 1);\n    });\n\n    // it seems DOMNodeRemoved sometimes fires asynchronously, this should probably be async - this will probably fail on other browsers\n    test(\"dispose is called once on model when pane element is removed from DOM using native functions\", function () {\n        if (Test.supportsMutationEvents) {\n            Test.Integration.executeEvents(events, 'Events/dispose');\n            ok(!Test.state.disposeCalled);\n            var element = document.querySelector('.dispose').parentNode;\n            element.parentNode.removeChild(element);\n            equal(Test.state.disposeCallCount, 1);\n        } else\n            ok(true, \"Browser does not support DOM mutation events. Only elements removed with jQuery will be properly cleaned in this browser.\");\n    });\n\n    test(\"dispose calls end on pubsub lifetime for each pane\", function () {\n        Test.Integration.pubsubAsMock();\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        $('.basicContainer').parent().remove();\n        ok(Test.Integration.context.pubsub.end.calledTwice);\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/dispose.tests.js");
window.eval("(function() {\n    module('Integration.Events.initialiseModel', { teardown: Test.Integration.teardown });\n\n    test(\"initialise function is called on model\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/basic');\n        equal(Test.state.model.message, 'test message');\n    });\n\n    test(\"returning deferred from initialise makes pipeline wait\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        ok(T.Events.spy.notCalled);\n        Test.state.deferred.resolve();\n        ok(T.Events.spy.calledOnce);\n    });\n\n    test(\"rejecting deferred returned from initialise halts pipeline\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        Test.state.deferred.reject();\n        ok(T.Events.spy.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/initialiseModel.tests.js");
window.eval("(function() {\n    module('Integration.Events.loadResources', {\n        setup: function () { Test.Integration.executeEvents(['loadResources'], 'Events/basic'); },\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"loadResources loads model\", function () {\n        ok(Test.Integration.context.models['/Events/basic']);\n    });\n\n    test(\"loadResources loads template\", function () {\n        equal($('#template--Events-basic').length, 1);\n    });\n\n    test(\"loadResources loads style\", function () {\n        notEqual($('#__tribeStyles').html().indexOf('.basic'), -1);\n    });\n\n})();\n//@ sourceURL=tribe://Integration/Events/loadResources.tests.js");
window.eval("(function() {\n    module('Integration.Events.paneRendered', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('paneRendered');\n\n    test(\"pane template is rendered and bound to model\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        equal($('.message').text(), 'test message');\n    });\n\n    test(\"paneRendered is called on model\", function() {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.paneRenderedCalled);\n    });\n\n    test(\"child panes are rendered\", function() {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        equal($('.basic').length, 1);\n    });\n\n    test(\"model is passed data\", function() {\n        Test.Integration.executeEvents(events, 'Events/data', 'test message');\n        equal($('.message').text(), 'test message');\n    });\n\n    asyncTest(\"paneRendered is called on model when in async mode\", function () {\n        expect(1);\n        T.options.synchronous = false;\n        Test.state.paneRendered = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n})();\n\n//@ sourceURL=tribe://Integration/Events/paneRendered.tests.js");
window.eval("(function() {\n    module('Integration.Events.renderComplete', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('renderComplete');\n\n    test(\"renderComplete is called on model when single pane has rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.renderCompleteCalled);\n    });\n\n    test(\"renderComplete is called on model when all panes in tree have rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/initialiseParent');\n        ok(!Test.state.parentRenderCompleteCalled);\n        Test.state.deferred.resolve();\n        ok(Test.state.parentRenderCompleteCalled);\n    });\n    \n    asyncTest(\"renderComplete is called on single model when in async mode\", function () {\n        expect(1);\n        T.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n\n    asyncTest(\"renderComplete is called on all models when in async mode\", function () {\n        expect(1);\n        T.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/asyncParent');\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/renderComplete.tests.js");
