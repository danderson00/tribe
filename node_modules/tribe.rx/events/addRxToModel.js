var Rx = require('rx'),
    actor = require('tribe.pubsub/actor'),
    store = require('tribe/client/eventStore'),
    log = require('tribe.logger')

T.Events.addRxToModel = function (pane, context) {
    if(!pane.model.hasOwnProperty('messages')) {
        pane.model.__defineGetter__('messages', function () {
            return paneActor().messages
        })
    }

    if(!pane.model.hasOwnProperty('envelopes')) {
        pane.model.__defineGetter__('envelopes', function () {
            return paneActor().envelopes
        })
    }

    if(!pane.model.topic) {
        pane.model.topic = function (topic) {
            return paneActor().envelopes
                .topic(topic)
                .select(function (x) { return x.data })
        }
    }

    if(!pane.model.query) {
        pane.model.query = function (scopeOrTopic) {
            var args = arguments;
            return Rx.Observable.create(function (observer) {
                var token = {}
                context.renderOperation.add(token);

                store.retrieve.apply(store, args).then(function (envelopes) {
                    envelopes.forEach(function (envelope) {
                        try {
                            observer.onNext(envelope)
                        } catch(error) {
                            log.error('Error processing query', error)
                        }
                    })
                    context.renderOperation.complete(token)
                })
            })
        }
    }

    function paneActor() {
        if(!pane.__generatedActor) {
            pane.__generatedActor = new actor(pane.pubsub, constructor)
            // this blocks renderComplete until completed
            context.renderOperation.add(pane.__generatedActor)
        }
        return pane.__generatedActor

        function constructor(actor) {
            actor.isDistributed && actor.isDistributed()
        }
    }
}
