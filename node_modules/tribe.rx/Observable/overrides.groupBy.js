var Rx = require('rx')

Rx.Observable.prototype.groupByUntil = function(keySelector, elementSelector, durationSelector) {
    var source = this;
    return new Rx.AnonymousObservable(function(o) {
        var Map = require('../Map')

        var map = new Map(),
            groupDisposable = new Rx.CompositeDisposable(),
            refCountDisposable = new Rx.RefCountDisposable(groupDisposable),
            handleError = function(e) {
                return function(item) {
                    item.onError(e);
                };
            };

        groupDisposable.add(
            source.subscribe(function(x) {
                var key = Rx.internals.tryCatch(keySelector)(x);
                if (key && key.e) {
                    map.forEach(handleError(key.e));
                    return o.onError(key.e);
                }

                var fireNewMapEntry = false,
                    writer = map.get(JSON.stringify(key));
                if (writer === undefined) {
                    writer = new Rx.Subject();
                    map.set(JSON.stringify(key), writer);
                    fireNewMapEntry = true;
                }

                if (fireNewMapEntry) {
                    var group = new Rx.GroupedObservable(key, writer, refCountDisposable),
                        durationGroup = new Rx.GroupedObservable(key, writer);
                    var duration = Rx.internals.tryCatch(durationSelector)(durationGroup);
                    if (duration && duration.e) {
                        map.forEach(handleError(duration.e));
                        return o.onError(duration.e);
                    }

                    o.onNext(group);

                    var md = new Rx.SingleAssignmentDisposable();
                    groupDisposable.add(md);

                    md.setDisposable(duration.take(1).subscribe(
                        Rx.helpers.noop,
                        function(e) {
                            map.forEach(handleError(e));
                            o.onError(e);
                        },
                        function() {
                            if (map['delete'](key)) {
                                writer.onCompleted();
                            }
                            groupDisposable.remove(md);
                        }));
                }

                var element = x;
                if (Rx.helpers.isFunction(elementSelector)) {
                    element = Rx.internals.tryCatch(elementSelector)(x);
                    if (element && element.e) {
                        map.forEach(handleError(element.e));
                        return o.onError(element.e);
                    }
                }

                writer.onNext(element);
            }, function(e) {
                map.forEach(handleError(e));
                o.onError(e);
            }, function() {
                map.forEach(function(item) {
                    item.onCompleted();
                });
                o.onCompleted();
            }));

        return refCountDisposable;
    }, source);
};
