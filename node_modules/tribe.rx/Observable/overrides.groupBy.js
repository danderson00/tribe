var Rx = require('rx')

Rx.Observable.prototype.groupByUntil = function (keySelector, elementSelector, durationSelector) {
  var source = this;
  return new AnonymousObservable(function (o) {
    var map = new Map(),
      groupDisposable = new CompositeDisposable(),
      refCountDisposable = new RefCountDisposable(groupDisposable),
      handleError = function (e) { return function (item) { item.onError(e); }; };

    groupDisposable.add(
      source.subscribe(function (x) {
        var key = tryCatch(keySelector)(x);
        if (key === errorObj) {
          map.forEach(handleError(key.e));
          return o.onError(key.e);
        }

        var fireNewMapEntry = false, writer = map.get(key);
        if (writer === undefined) {
          writer = new Subject();
          map.set(key, writer);
          fireNewMapEntry = true;
        }

        if (fireNewMapEntry) {
          var group = new GroupedObservable(key, writer, refCountDisposable),
            durationGroup = new GroupedObservable(key, writer);
          var duration = tryCatch(durationSelector)(durationGroup);
          if (duration === errorObj) {
            map.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }

          o.onNext(group);

          var md = new SingleAssignmentDisposable();
          groupDisposable.add(md);

          md.setDisposable(duration.take(1).subscribe(
            noop,
            function (e) {
              map.forEach(handleError(e));
              o.onError(e);
            },
            function () {
              if (map['delete'](key)) { writer.onCompleted(); }
              groupDisposable.remove(md);
            }));
        }

        var element = x;
        if (isFunction(elementSelector)) {
          element = tryCatch(elementSelector)(x);
          if (element === errorObj) {
            map.forEach(handleError(element.e));
            return o.onError(element.e);
          }
        }

        writer.onNext(element);
    }, function (e) {
      map.forEach(handleError(e));
      o.onError(e);
    }, function () {
      map.forEach(function (item) { item.onCompleted(); });
      o.onCompleted();
    }));

    return refCountDisposable;
  }, source);
};
