var Rx = require('rx')

Rx.Observable.prototype.groupByEach = function(keySelector, elementSelector, durationSelector) {
    var source = this;
    return new Rx.AnonymousObservable(function(o) {
        var Map = require('../Map')

        var map = new Map(),
            groupDisposable = new Rx.CompositeDisposable(),
            refCountDisposable = new Rx.RefCountDisposable(groupDisposable),
            handleError = function(e) {
                return function(item) {
                    item.onError(e);
                };
            };

        groupDisposable.add(
            source.subscribe(function(x) {
                var key = Rx.internals.tryCatch(keySelector)(x);
                if (key && key.e) {
                    map.forEach(handleError(key.e));
                    return o.onError(key.e);
                }

                if(key && key.constructor === Array)
                    key.forEach(processKey)
                else
                    processKey(key)

                function processKey(key) {
                    var fireNewMapEntry = false,
                        writer = map.get(JSON.stringify(key));
                    if (writer === undefined) {
                        writer = new Rx.Subject();
                        map.set(JSON.stringify(key), writer);
                        fireNewMapEntry = true;
                    }

                    if (fireNewMapEntry) {
                        var group = new Rx.GroupedObservable(key, writer, refCountDisposable),
                            durationGroup = new Rx.GroupedObservable(key, writer);

                        o.onNext(group);

                        var md = new Rx.SingleAssignmentDisposable();
                        groupDisposable.add(md);
                    }

                    var element = x;
                    if (Rx.helpers.isFunction(elementSelector)) {
                        element = Rx.internals.tryCatch(elementSelector)(x);
                        if (element && element.e) {
                            map.forEach(handleError(element.e));
                            return o.onError(element.e);
                        }
                    }

                    writer.onNext(element);
                }
            }, function(e) {
                map.forEach(handleError(e));
                o.onError(e);
            }, function() {
                map.forEach(function(item) {
                    item.onCompleted();
                });
                o.onCompleted();
            }));

        return refCountDisposable;
    }, source);
};
