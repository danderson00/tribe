var d3 = require('d3'),
    throttle = require('tribe/utilities/throttle')

require('tribe').register.model(function (pane) {    
    var margins = {
            top: 20,
            right: 10,
            bottom: 20,
            left: 20
        },
        options = {            		
            width: (pane.data.width || calculateWidth()) - margins.left - margins.right,
            height: (pane.data.height || calculateHeight() / 2) - margins.top - margins.bottom,
            colors: pane.data.colors || ['steelblue', 'sandybrown', 'cadetblue', 'chocolate', 'darkcyan', 'darkseagreen', 'goldenrod'],
            type: 'incremental'
        },

        source, groups, scaling, pathGenerator, graph, axes, paths, data = [], rendering = true,

        types = {
            incremental: require('./types/incremental') 
        },

        implementation = types[options.type]

    this.initialise = () => {
        source = pane.data.source || pane.model.envelopes 
        groups = pane.data.groups(source).asArray()
        subscribe()
    }

    this.paneRendered = () => {
        scaling = implementation.createScaling(options)
        pathGenerator = implementation.createPath(scaling)
        graph = createGraph()
        axes = createAxes()
        paths = createInitialPaths()
        draw()
        rendering = false;
    }

    function subscribe() {
        var valuesExpression = pane.data.values

        groups.subscribe(function (changes) {
            changes.forEach(function (change) {
                if(change.status === 'added') {
                    var pathValues = []
                    data.push(pathValues)

                    if(!rendering) paths.push(createPath(options.colors[paths.length]))

                    valuesExpression(change.value.underlyingObservable).subscribe(function (value) {
                        implementation.handler(value, pathValues, data)
                        if(!rendering) draw()
                    })
                }
            })
        }, null, "arrayChange")
    }

    var draw = throttle(function () {
        setScaling()
        drawAxes()
        drawPaths()
    }, 10, { leading: false })

    function createScaling() {
        return {
            x: d3.scaleLinear().range([0, options.width]),
            y: d3.scaleLinear().range([options.height, 0]),
            line: d3.line().x((d, i) => scaling.x(i)).y(d => scaling.y(d))
        }
    }

    function createGraph() {
        return d3.select(pane.element).append("svg:svg")
            .attr("width", options.width + margins.right + margins.left)
            .attr("height", options.height + margins.top + margins.bottom)
            .attr("class", "graph")
            .append("svg:g")
            .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
    }

    function createAxes() {
        var scales = implementation.createAxes(options)
        return {
            x: {
                scale: scales.x,
                element: graph.append("svg:g").attr("class", "x axis").attr("transform", "translate(0," + options.height + ")")
            },
            y: {
                scale: scales.y,
                element: graph.append("svg:g").attr("class", "y axis")
            }
        }
    }
    
    function createInitialPaths() {
        return data.map((item, index) => createPath(options.colors[index]))
    }

    function createPath(color) {
        return graph.append("svg:path").attr("class", "line").attr("style", "stroke:" + color)
    }

    function setScaling() {
        var x = d3.max(data.map(array => array.length)) - 1
        scaling.x.domain([0, x])
        axes.x.scale.scale(scaling.x).ticks(x)

        var y = d3.max(data.map(array => d3.max(array)))
        scaling.y.domain([0, y])
        axes.y.scale.scale(scaling.y).ticks(y)
    }

    function drawAxes() {
        axes.x.element.call(axes.x.scale)
        axes.y.element.call(axes.y.scale)
    }

    function drawPaths() {
        paths.forEach(drawPath)
    }

    function drawPath(path, index) {
        path.attr("d", pathGenerator(data[index]))
    }

    function calculateWidth() {
        var deviceWidth = window.document.documentElement.clientWidth,
            leftPosition = findLeftPosition(pane.element.parentElement)
        
        return deviceWidth - leftPosition * 2

        function findLeftPosition(parent) {
            if(parent.offsetLeft === -10000) // i.e. we are being rendered - this is hacky and not reliable
                return findLeftPosition(parent.parentElement)
            return parent.offsetLeft
        }
    }

    function calculateHeight() {
        var deviceWidth = window.document.documentElement.clientWidth,
            deviceHeight = window.document.documentElement.clientHeight
        
        if(deviceWidth > deviceHeight)
            return deviceWidth / 4
        return deviceWidth / 1.5
    }
}, '/graph')