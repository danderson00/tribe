var getDomain = require('./domain'),
    getOptions = require('./options'),
    d3 = require('d3'),
    throttle = require('tribe/utilities/throttle')

require('tribe').register.model(function (pane) {        
    var options = getOptions(pane),

        source, groups, scaling, pathGenerator, graph, axes, paths, currentEnvelope, data = [], rendering = true,

        types = {
            incremental: require('./types/incremental'),
            time: require('./types/time')
        },

        implementation = types[options.type](options)

    this.initialise = () => {
        source = pane.data.source || pane.model.envelopes 
        currentEnvelope = source.asScalar()
        groups = pane.data.groups(source).asArray()
        subscribe()
    }

    this.paneRendered = () => {
        scaling = implementation.createScaling(options)
        pathGenerator = createPathGenerator()
        graph = createGraph()
        axes = createAxes()
        paths = createInitialPaths()
        draw()
        rendering = false;
    }

    function subscribe() {
        var valuesExpression = pane.data.values;

        groups.subscribe(function (changes) {
            changes.forEach(function (change) {
                if(change.status === 'added') {
                    var pathValues = []
                    data.push(pathValues)

                    if(!rendering) paths.push(createPath(options.colors[paths.length]))

                    valuesExpression(change.value).subscribe(function (value) {
                        implementation.handler(value, pathValues, data, currentEnvelope())
                        if(!rendering) draw()
                    })
                }
            })
        }, null, "arrayChange")
    }

    var draw = throttle(function () {
        setScaling()
        drawAxes()
        drawPaths()
    }, 10, { leading: false })

    function createGraph() {
        return d3.select(pane.element).append("svg:svg")
            .attr("width", options.width + options.margins.right + options.margins.left)
            .attr("height", options.height + options.margins.top + options.margins.bottom)
            .attr("class", "graph")
            .append("svg:g")
            .attr("transform", "translate(" + options.margins.left + "," + options.margins.top + ")")
    }

    function createPathGenerator() {
        return d3.line().x(d => scaling.x(d[0])).y(d => scaling.y(d[1]))
    }

    function createAxes() {
        return {
            x: {
                axis: d3.axisBottom().tickSize(-options.height),
                element: graph.append("svg:g").attr("class", "x axis").attr("transform", "translate(0," + options.height + ")")
            },
            y: {
                axis: d3.axisLeft().tickSize(-options.width),
                element: graph.append("svg:g").attr("class", "y axis")
            }
        }
    }
    
    function createInitialPaths() {
        return data.map((item, index) => createPath(options.colors[index]))
    }

    function createPath(color) {
        return graph.append("svg:path").attr("class", "line").attr("style", "stroke:" + color)
    }

    function setScaling() {
        var domain = getDomain(data)

        scaling.x.domain([domain.x.min, domain.x.max])
        axes.x.axis.scale(scaling.x).tickFormat(domain.x.format)

        scaling.y.domain([domain.y.min, domain.y.max])
        axes.y.axis.scale(scaling.y).tickFormat(domain.y.format)
    }

    function drawAxes() {
        axes.x.element.call(axes.x.axis)
        axes.y.element.call(axes.y.axis)
    }

    function drawPaths() {
        paths.forEach(drawPath)
    }

    function drawPath(path, index) {
        path.attr("d", pathGenerator(data[index]))
    }

}, '/graph')