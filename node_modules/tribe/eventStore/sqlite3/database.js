var options = require('tribe/options'),
    sqlite3 = require('sqlite3'),
    Q = require('q'),
    path = require('path'),
    fs = require('fs'),
    _ = require('underscore');

var api = module.exports = {
    initialise: function (indexes) {
        var filename = options.eventStore.filename,
            inMemory = filename === ':memory:',
            fullPath = inMemory ? filename : path.resolve(options.basePath, filename),
            exists = inMemory ? api.db : fs.existsSync(fullPath);

        api.db = api.db || new sqlite3.Database(fullPath);

        return api.serialise(function (db, fail) {
            if (!exists)
                db.exec("create table messages (id int, envelope text)", fail);
             
            if (indexes)
                db.all("pragma table_info(messages)", function (err, rows) {
                    if (fail(err)) return;

                    return api.serialise(function (db, fail) {
                        var existing = _.without(_.pluck(rows, 'name'), 'id', 'envelope');

                        _.each(indexes, function (index) {
                            if (existing.indexOf(index) === -1) {
                                db.exec("alter table messages add column " + index + " string", fail);
                                db.exec("create index " + index + " on messages (" + index + ")", fail);
                                db.exec("create index id_" + index + " on messages (id, " + index + ")", fail);
                            }
                        });
                    });
                });
        });
    },
    serialise: function (callback) {
        var deferred = Q.defer();

        api.db.serialize(function () {
            var result = callback(api.db, rejectOnError);
            api.db.wait(function () {
                setTimeout(function () {
                    Q.when(result).then(deferred.resolve);
                });
            });
        });

        return deferred.promise;

        function rejectOnError(err) {
            if (err) deferred.reject(err);
            return err;
        }
    },
    close: function () {
        api.db && api.db.close();
        delete api.db;
    }
};

/*
    initialise: function (indexes) {
        var deferred = Q.defer(),
            filename = options.eventStore.filename,
            inMemory = filename === ':memory:',
            fullPath = inMemory ? filename : path.resolve(options.basePath, filename),
            exists = inMemory ? api.db : fs.existsSync(fullPath);

        api.db = api.db || new sqlite3.Database(fullPath);

        api.db.serialize(function () {
            if (!exists)
                api.db.exec("create table messages (id int, envelope text)", fail);
             
            if (indexes)
                api.db.all("pragma table_info(messages)", function (err, rows) {
                    if (fail(err)) return;

                    api.db.serialize(function () {
                        var existing = _.without(_.pluck(rows, 'name'), 'id', 'envelope');

                        _.each(indexes, function (index) {
                            if (existing.indexOf(index) === -1) {
                                api.db.exec("alter table messages add column " + index + " string", fail);
                                api.db.exec("create index " + index + " on messages (" + index + ")", fail);
                                api.db.exec("create index id_" + index + " on messages (id, " + index + ")", fail);
                            }
                        });

                        wait();
                    });
                });
            else
                wait();
        });

        return deferred.promise;

        function fail(err) {
            if (err) deferred.reject(err);
            return err;
        }

        function wait() {
            api.db.wait(function () {
                // the setTimeout gives the error callbacks a chance to execute and reject the promise first
                setTimeout(deferred.resolve);
            });
        }
    },
*/