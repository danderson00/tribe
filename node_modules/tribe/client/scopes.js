var store = require('./eventStore'),
    gateway = require('./gateway'),
    options = require('tribe/options'),
    pubsub = require('tribe.pubsub'),
    expressions = require('tribe.expressions'),
    log = require('tribe.logger'),
    sortObject = require('tribe/utilities/collections').sortObject,
    Q = require('q'),

    scopes = {};

module.exports = {
    request: function (scope) {
        var jsonScope = JSON.stringify(sortObject(scope)),
            data = getScopeData(jsonScope),
            requestRequired = data.count === 0,
            messages;

        data.count++;
        log.silly("Incremented count for " + jsonScope + " to " + data.count);

        return store.retrieve(scope)
            .then(function (localMessages) {
                messages = localMessages;

                var lastLocalSeq = messages.length > 0 && messages[messages.length - 1].seq;

                log.silly("Retrieved " + messages.length + " messages from local cache with last seq " + lastLocalSeq + " for scope " + jsonScope);

                // no existing session. request a scope from the server
                if (requestRequired)
                    return requestScope(lastLocalSeq);

                // scope is currently being requested. await result.
                if (data.promise)
                    return data.promise;

                // otherwise we're already active, just return local messages below
            })
            .then(function (scopeEnvelopes) {
                if(scopeEnvelopes) { 
                    log.silly("Retrieved " + scopeEnvelopes.length + " messages from server for scope " + jsonScope);
                    messages = messages.concat(scopeEnvelopes);
                }

                return { envelopes: messages };
            });

        function requestScope(since) {
            var scopeEnvelopes;

            data.promise = Q.when(gateway.scope.request({ scope: scope, since: since }))
                .then(function (result) {
                    data.token = module.exports.relayAndStore(scope);
                    scopeEnvelopes = result && result.envelopes;
                    if(scopeEnvelopes)
                        return store.store(scope, scopeEnvelopes);
                })
                .then(function () {
                    data.promise = null;
                    return scopeEnvelopes;
                });

            return data.promise;
        }
    },
    release: function (scope) {
        var jsonScope = JSON.stringify(sortObject(scope)),
            data = getScopeData(jsonScope);
            
        data.count--;
        // if(!data.count) {

        // POTENTIAL MEMORY LEAK HERE
        // this is a strange bug... got to fix this
        if(data.count < 0) {
            log.warn("Count for scope " + JSON.stringify(scope) + " had count " + data.count);
            data.count = 0;
        }

        if(!data.count && data.token) {

            // gateway.scope.release({ scope: scope });
            pubsub.unsubscribe(data.token);
            data.promise = null;
            data.token = null;
        }
    },
    relayAndStore: function (scope, topics) {
        return pubsub.subscribe(topics || '*', function (message, envelope) {
            if (envelope.origin !== 'server' && envelope.origin !== 'client' && !topicIsTransient()) {
                // see eventStore for discussion of unpublished
                store.storeUnpublished(envelope);
                gateway.publish(envelope)
                    .then(function (publishedEnvelope) {
                        return store.store(scope, publishedEnvelope).then(function (result) {
                            store.releaseUnpublished(envelope);
                            return result;
                        });
                    })
                    .fail(function (error) {
                        // as we're not returning the promise anywhere, we need to log our own errors
                        log.error("Exception occurred while storing or relaying message", error);
                    });
            }

            function topicIsTransient() {
                return options.transientTopics.some(function (topic) {
                    return pubsub.topicMatches(envelope.topic, topic);
                });
            }
        }, expressions.create.fromScope(scope));
    }
};

function getScopeData(key) {
    if(!scopes[key]) {
        log.silly("Creating new scope data object for " + key);
        scopes[key] = { count: 0, token: null, promise: null };
    }

    return scopes[key];
}
