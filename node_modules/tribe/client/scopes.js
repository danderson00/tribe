var store = require('./eventStore'),
    hub = require('./hub'),
    options = require('tribe/options'),
    pubsub = require('tribe.pubsub'),
    expressions = require('tribe.expressions'),
    log = require('tribe.logger'),
    sortObject = require('tribe/utilities/collections').sortObject,
    Q = require('q'),

    scopes = {};

module.exports = {
    request: function (scope) {
        var data = getScopeData(scope),
            requestRequired = data.count === 0,
            messages;

        data.count++;

        return store.retrieve(scope)
            .then(function (localMessages) {
                messages = localMessages;

                var lastLocalSeq = messages.length > 0 && messages[messages.length - 1].seq;

                // no existing session. request a scope from the server
                if (requestRequired)
                    return requestScope(lastLocalSeq);

                // scope is currently being requested. await result.
                if (data.promise)
                    return data.promise;

                // otherwise we're already active, just return local messages below
            })
            .then(function (scopeEnvelopes) {
                if(scopeEnvelopes)
                    messages = messages.concat(scopeEnvelopes);

                return { envelopes: messages };
            });

        function requestScope(since) {
            var scopeEnvelopes;

            data.promise = Q.when(hub.scope({ scope: scope, since: since }))
                .then(function (result) {
                    data.token = module.exports.relayAndStore(scope);
                    scopeEnvelopes = result && result.envelopes;
                    if(scopeEnvelopes)
                        return store.store(scope, scopeEnvelopes);
                })
                .then(function () {
                    return scopeEnvelopes;
                });

            return data.promise;
        }
    },
    release: function (scope) {
        var data = getScopeData(scope);
        data.count--;
        if(!data.count) {
            pubsub.unsubscribe(data.token);
            data.promise = null;
            data.token = null;
        }
    },
    relayAndStore: function (scope, topics) {
        return pubsub.subscribe(topics || '*', function (message, envelope) {
            if (envelope.origin !== 'server' && envelope.origin !== 'client' && !topicIsTransient()) {
                // see eventStore for discussion of unpublished
                store.storeUnpublished(envelope);
                hub.publish(envelope)
                    .then(function (publishedEnvelope) {
                        return store.store(scope, publishedEnvelope).then(function (result) {
                            store.releaseUnpublished(envelope);
                            return result;
                        });
                    })
                    .fail(function (error) {
                        // as we're not returning the promise anywhere, we need to log our own errors
                        log.error('Exception occurred while storing or relaying message', error);
                    });
            }

            function topicIsTransient() {
                return options.transientTopics.some(function (topic) {
                    return pubsub.topicMatches(envelope.topic, topic);
                });
            }
        }, expressions.create(scope, 'data'));
    }
};

function getScopeData(scope) {
  var key = JSON.stringify(sortObject(scope));;

  if(!scopes[key])
    scopes[key] = { count: 0, token: null, promise: null };

    return scopes[key];
}
