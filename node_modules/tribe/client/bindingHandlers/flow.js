ko.virtualElements.allowedBindings.flow = true;
ko.bindingHandlers.flow = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var paneHandler = ko.bindingHandlers.pane,
            pane = T.Utils.extractNode(bindingContext).pane,
            pubsub = pane.pubsub,
            context = T.Utils.extractContext(bindingContext),
            path = flowPath(),
            scope = allBindingsAccessor().scope,
            transition = allBindingsAccessor().transition,
            token = {}

        context.renderOperation.add(token);

        pubsub.obtainActor(path, scope).then(function (actor) {
            actor.pane.subscribe(updateBinding)
            updateBinding()

            T.nodeFor(element).pane.is.disposed.then(function () {
                actor.__actor.release();
            });

            context.renderOperation.complete(token)

            function updateBinding() {
                var value = actor.pane()
                if(value) {
                    value.data = (value && value.data) || pane.data
                    paneHandler.update(element, actor.pane, function () { return { handlesNavigation: transition || true, scope: scope } }, viewModel, bindingContext)
                } // probably should clear the pane here if the value is undefined
            }
        }).fail(function (err) {
            T.logger.error('Failed to retrieve flow', err);
        })

        return { controlsDescendantBindings: true }

        function flowPath() {
            var boundPath = ko.unwrap(valueAccessor());
            if(boundPath[0] !== '/')
                boundPath = '/' + boundPath;
            return '/__flows' + boundPath;
        }
    }
}
