var storage = require('tribe.storage'),
    expressions = require('tribe.expressions'),
    facets = require('tribe/facets'),
    log = require('tribe.logger'),
    options = require('tribe/options'),
    getArguments = require('tribe/utilities/arguments'),
    Q = require('q'),
    messages, db,
    unpublished = [];

module.exports = {
    store: function (scope, envelopes) {
        return Q.when(initialise()).then(function () {
            if(envelopes.constructor === Array)
                return messages.store(envelopes.map(createContainer));
            return messages.store(createContainer(envelopes));
        }).fail(function (error) {
            log.error('Failed to store message', error);
        });

        function createContainer(envelope) {
            return {
                envelope: envelope,
                topic: envelope.topic,
                scope: JSON.stringify(scope)
            };
        }
    },
    retrieve: function (scopeOrTopic) {
        var args = getArguments(arguments);
        return Q.when(initialise())
            .then(function () {
                var expressions = [];
                if(args.string)
                    expressions.push({ p: 'topic', v: args.string });
                if(args.object)
                    expressions.push({ p: 'scope', v: JSON.stringify(args.object) });
                return messages.retrieve(expressions);
            })
            .then(function (messages) {
                return messages.map(function (message) {
                    return message.envelope;
                })
                .concat(unpublished.filter(function (envelope) {
                    if (scopeOrTopic.constructor === String)
                        return expressions.evaluate(expressions.create({ topic: scopeOrTopic }), envelope);
                    return expressions.evaluate(expressions.create(scopeOrTopic), envelope.data);
                }));
            })
            .fail(function (error) {
                log.error('Failed to retrieve messages', error);
            });
    },

    // this is a bit of a hack to work around the fact we may request a scope before messages have been published to the server (e.g. after navigation caused by a message)
    // in the long term, we need a better solution to cater for offline sync and purely local applications,
    // i.e. messages persisted in their own store with similar functionality to the server side store

    // there are potential race conditions here, similar to other places
    storeUnpublished: function (envelope) {
        unpublished.push(envelope);
    },
    releaseUnpublished: function (envelope) {
        unpublished.splice(unpublished.indexOf(envelope), 1);
    },

    clear: function () {
        return Q.when(initialise())
            .then(function () {
                return messages.clear();
            });
    },
    close: function () {
        db && db.close();
        db = undefined;
    }
}

function initialise() {
    if(!db)
        return storage.open([{ name: 'messages', indexes: [['scope'], ['topic'], ['topic', 'scope']], keyPath: 'clientSeq', autoIncrement: true }], { type: module.exports.type, name: options.appName })
            .then(function (provider) {
                db = provider;
                messages = provider.entity('messages');
            })
}
