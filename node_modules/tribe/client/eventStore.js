var storage = require('tribe.storage'),
    expressions = require('tribe.expressions'),
    actors = require('tribe/actors'),
    log = require('tribe.logger'),
    options = require('tribe/options'),
    Q = require('q'),
    messages, db, unpublished = [];

module.exports = {
    store: function (scope, envelopes) {
        return Q.when(initialise()).then(function () {
            if(envelopes.constructor === Array)
                return messages.store(envelopes.map(createContainer));
            return messages.store(createContainer(envelopes));
        }).fail(function (error) {
            log.error('Failed to store message', error);
        });

        function createContainer(envelope) {
            return {
                envelope: envelope,
                scope: JSON.stringify(scope)
            };
        }
    },
    retrieve: function (scope) {
        return Q.when(initialise())
            .then(function () {
                return messages
                    .retrieve([
                        //{ p: 'clientSeq', o: '>', v: 0 }, // we should be sorting by this to be sure, but there is some bug in storage here
                        { p: 'scope', v: JSON.stringify(scope) }
                    ])
            })
            .then(function (messages) {
                return messages.map(function (message) {
                    return message.envelope;
                }).concat(unpublished.filter(function (envelope) {
                    return expressions.evaluate(expressions.create(scope), envelope.data);
                }));
            })
            .fail(function (error) {
                log.error('Failed to retrieve messages', error);
            });
    },

    // this is a bit of a hack to work around the fact we may request a scope before messages have been published to the server (e.g. after navigation caused by a message)
    // in the long term, we need a better solution to cater for offline sync and purely local applications,
    // i.e. messages persisted in their own store with similar functionality to the server side store

    // there are potential race conditions here, similar to other places
    storeUnpublished: function (envelope) {
        unpublished.push(envelope);
    },
    releaseUnpublished: function (envelope) {
        unpublished.splice(unpublished.indexOf(envelope), 1);
    },

    clear: function () {
        return Q.when(initialise())
            .then(function () {
                return messages.clear();
            });
    },
    close: function () {
        db && db.close();
        db = undefined;
    }
}

function initialise() {
    if(!db)
        return storage.open([{ name: 'messages', indexes: [['scope']], keyPath: 'clientSeq', autoIncrement: true }], { type: module.exports.type, name: options.appName })
            .then(function (provider) {
                db = provider;
                messages = provider.entity('messages');
            })
}
