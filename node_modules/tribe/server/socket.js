module.exports = {
    start: function (server) {
        // a bit of a mess...
        var server = require('./http').server,
            io = require('socket.io').listen(server),
            log = require('tribe.logger'),
            pubsub = require('tribe.pubsub'),
            eventStore = require('tribe/storage').entity('messages'),
            actors = require('tribe/actors'),
            uuid = require('node-uuid');

        module.exports.io = io;

        io.sockets.on('connection', function (socket) {
            var clientId = uuid.v4(),
                address = socket.handshake.address,
                lifetime = pubsub.createLifetime();

            log.debug('Client connected - ' + address.address + ':' + address.port);
            // possibly log the client id with an internal message
            
            // these should probably be refactored out and hooked up by configuration
            socket.on('message', function (envelope, ack) {
                envelope.sourceId = clientId;
                eventStore
                    .store(envelope)
                    .then(function (messageId) {
                        ack(messageId);
                        lifetime.publish(envelope);
                    })
                    .fail(function (err) {
                        log.error('Failed to store message', err);
                        ack(null, err);
                    });
            });

            // this seriously needs tests... correction. this code needs to be taken out the back and shot
            socket.on('subscribe', function (options, ack) {
                //{ actor: '/path', id: 'id' } || { topics: 'topic' || ['topic1','topic2'], expression: expression }
                // authenticate and authorise!
                if (options.actor) {
                    var actor = actors.actors[options.actor],
                        expression = actor.definition.expression;

                    if(expression) {
                        subscribe(actor.definition.topics, { p: expression.p, v: options.id });
                        returnMessages({ p: expression.p, v: options.id });
                    } else {
                        subscribe(actor.definition.topics);
                        ack({});
                    }
                } else if (options.topics) {
                    subscribe(options.topics, options.filter);
                    ack({});
                }
                else
                    ack(null, 'Invalid arguments to subscribe');

                function subscribe(topics, expression) {
                    lifetime.subscribe(topics, function (data, envelope) {
                        if (envelope.sourceId !== clientId)
                            socket.emit('message', envelope);
                    }, expression);
                }

                function returnMessages(expression) {
                    return eventStore.retrieve(expression)
                        .then(function (envelopes) {
                            ack({ envelopes: envelopes });
                        })
                        .fail(function (err) {
                            log.error('Failed to retrieve actor messages', err);
                            ack(null, err);
                        });
                }
            });

            socket.on('disconnect', function () {
                lifetime.end();
            });
        });

        log.info('Accepting socket connections');
    }
};