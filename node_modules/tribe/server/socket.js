module.exports = {
    start: function (server) {
        // a bit of a mess...
        var server = require('./http').server,
            io = require('socket.io').listen(server),
            log = require('tribe/logger'),
            pubsub = require('tribe.pubsub'),
            eventStore = require('tribe/eventStore'),
            actors = require('tribe/actors'),
            uuid = require('node-uuid');

        module.exports.io = io;

        io.sockets.on('connection', function (socket) {
            var clientId = uuid.v4(),
                address = socket.handshake.address,
                lifetime = pubsub.createLifetime();

            log.debug('Client connected - ' + address.address + ':' + address.port);
            // possibly log the client id with an internal message
            
            // these should probably be refactored out and hooked up by configuration
            socket.on('message', function (envelope, ack) {
                envelope.sourceId = clientId;
                eventStore
                    .store(envelope)
                    .then(function (messageId) {
                        ack(messageId);
                        lifetime.publish(envelope);
                    })
                    .fail(function (err) {
                        log.error('Failed to store message', err);
                        ack(null, err);
                    });
            });

            socket.on('subscribe', function (options, ack) {
                var actor = actors.actors[options.actor];

                if (actor) {
                    var definition = actor.definition;

                    lifetime.subscribe(definition.topics, function (data, envelope) {
                        if(envelope.sourceId !== clientId)
                            socket.emit('message', envelope);
                    }, definition.messageFilter);

                    if (definition.messageFilter)
                        return eventStore.retrieve({
                            indexName: definition.messageFilter.options.property,
                            indexValue: options.id
                        }).then(function (envelopes) {
                            ack({ envelopes: envelopes });
                        })
                        .fail(function (err) {
                            log.error('Failed to retrieve actor messages', err);
                            ack(null, err);
                        });
                }
            });

            socket.on('disconnect', function () {
                lifetime.end();
            });
        });

        log.info('Accepting socket connections');
    }
};