module.exports = {
    start: function (server) {
        // a bit of a mess...
        var server = require('./http').server,
            io = require('socket.io').listen(server),
            log = require('tribe/logger'),
            pubsub = require('tribe.pubsub'),
            eventStore = require('tribe/eventStore'),
            actors = require('tribe/actors'),
            uuid = require('node-uuid');

        module.exports.io = io;

        io.sockets.on('connection', function (socket) {
            var clientId = uuid.v4(),
                address = socket.handshake.address,
                lifetime = pubsub.createLifetime();

            log.debug('Client connected - ' + address.address + ':' + address.port);
            // possibly log the client id with an internal message
            
            // these should probably be refactored out and hooked up by configuration
            socket.on('message', function (envelope, ack) {
                envelope.sourceId = clientId;
                eventStore
                    .store(envelope)
                    .then(function (messageId) {
                        ack(messageId);
                        lifetime.publish(envelope);
                    })
                    .fail(function (err) {
                        log.error('Failed to store message', err);
                        ack(null, err);
                    });
            });

            socket.on('subscribe', function (options, ack) {
                // authenticate and authorise!
                if (options.actor) {
                    var actor = actors.actors[options.actor];
                    subscribe(actor.definition.topics, actor.definition.messageFilter, options.id);
                } else if (options.topics)
                    subscribe(options.topics, options.filter, options.value);

                function subscribe(topics, filter, value) {
                    lifetime.subscribe(topics, function (data, envelope) {
                        if (envelope.sourceId !== clientId)
                            socket.emit('message', envelope);
                    }, filter);

                    if (filter)
                        return eventStore.retrieve({
                            indexName: filter.options.property,
                            indexValue: value
                        }).then(function (envelopes) {
                            ack({ envelopes: envelopes });
                        })
                        .fail(function (err) {
                            log.error('Failed to retrieve actor messages', err);
                            ack(null, err);
                        });
                    else
                        ack();
                }
            });

            socket.on('disconnect', function () {
                lifetime.end();
            });
        });

        log.info('Accepting socket connections');
    }
};