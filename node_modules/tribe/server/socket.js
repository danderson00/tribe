module.exports = {
    start: function (server) {
        // a bit of a mess...
        var server = require('./http').server,
            io = require('socket.io').listen(server),
            log = require('tribe.logger'),
            pubsub = require('tribe.pubsub'),
            eventStore = require('tribe/eventStore'),
            actors = require('tribe/actors'),
            uuid = require('node-uuid');

        module.exports.io = io;

        io.sockets.on('connection', function (socket) {
            var clientId = uuid.v4(),
                address = socket.handshake.address,
                lifetime = pubsub.createLifetime();

            log.debug('Client connected - ' + address.address + ':' + address.port);
            // possibly log the client id with an internal message
            
            // these should probably be refactored out and hooked up by configuration
            socket.on('message', function (envelope, ack) {
                envelope.sourceId = clientId;
                eventStore
                    .store(envelope)
                    .then(function (messageId) {
                        ack(messageId);
                        lifetime.publish(envelope);
                    })
                    .fail(function (err) {
                        log.error('Failed to store message', err);
                        ack(null, err);
                    });
            });

            // this seriously needs tests...
            socket.on('subscribe', function (options, ack) {
                //{ actor: '/path', id: 'id' } || { topics: 'topic' || ['topic1','topic2'], filter: messageFilter, value: filterValue, replay: false }
                // authenticate and authorise!
                if (options.actor) {
                    var actor = actors.actors[options.actor],
                        indexName = actor.definition.messageFilter ? actor.definition.messageFilter.options.property : 'topic',
                        indexValue = actor.definition.messageFilter ? options.id : actor.definition.topics;

                    subscribe(actor.definition.topics, actor.definition.messageFilter, indexName, indexValue, options.replay !== false);
                } else if (options.topics)
                    subscribe(options.topics, options.filter, null, null, options.replay);
                else
                    ack(null, 'Invalid arguments to subscribe');

                function subscribe(topics, messageFilter, indexName, indexValue, replay) {
                    lifetime.subscribe(topics, function (data, envelope) {
                        if (envelope.sourceId !== clientId)
                            socket.emit('message', envelope);
                    }, messageFilter);

                    if (indexName && replay)
                        return eventStore.retrieve({
                            indexName: indexName,
                            indexValue: indexValue
                        }).then(function (envelopes) {
                            ack({ envelopes: envelopes });
                        })
                        .fail(function (err) {
                            log.error('Failed to retrieve actor messages', err);
                            ack(null, err);
                        });
                    else
                        ack({ });
                }
            });

            socket.on('disconnect', function () {
                lifetime.end();
            });
        });

        log.info('Accepting socket connections');
    }
};