suite('tribe.browser.integration.scopes', function () {
    var scopes = require('tribe/client/scopes'),
        gateway = require('tribe/client/gateway'),
        eventStore = require('tribe/client/eventStore'),
        pubsub = require('tribe.pubsub'),
        uuid = require('node-uuid').v4,
        Q = require('q'),

        scope;

    setup(function () {
        scope = { facetId: uuid() };
    });

    test("messages are retrieved from server store and persisted locally", function () {
        return eventStore.clear()
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(0);
                pubsub.publish({ topic: 'topic', data: scope });
                // allow the message a chance to be published and persisted on the server side
                return delay(100)();
            })
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(1);
                return eventStore.retrieve(scope);
            })
            .then(function (messages) {
                expect(messages.length).to.equal(1);
            });
    });

    test("unpublished messages are included in local cache", function () {
        // the only difference between this test and the previous is the removal of the delay
        // messages are persisted into local scope storage only when provided with the server seq number
        // unpublished messages are stored in a separate storage and appended to scope messages
        return eventStore.clear()
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(0);
                pubsub.publish({ topic: 'topic', data: scope });
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(1);
                return eventStore.retrieve(scope);
            })
            .then(function (messages) {
                expect(messages.length).to.equal(1);
            });
    });

    test("messages are persisted locally", function () {
        return eventStore.clear()
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                pubsub.publish('topic', scope);
                return delay(100)();
            })
            .then(function () {
                return eventStore.retrieve(scope);
            })
            .then(function (messages) {
                expect(messages.length).to.equal(1);
            });
    });

    test("messages are retrieved from local store", function () {
        return eventStore.clear()
            .then(function () {
                return eventStore.store(scope, { topic: 'topic', data: scope });
            })
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(1);
            });
    });

    test("messages stored locally are combined with server messages", function () {
        return eventStore.clear()
            .then(function () {
                return eventStore.store(scope, { topic: 'topic', data: scope });
            })
            .then(function () {
                return gateway.publish({ topic: 'topic', data: scope });
            })
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(2);
            });
    });

    test("messages with transient topics are not relayed or stored", function () {
        return eventStore.clear()
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                pubsub.publish('topic', scope);
                pubsub.publish('ui.topic', scope);
                return delay(100)();
            })
            .then(function () {
                return scopes.request(scope);
            })
            .then(function (data) {
                expect(data.envelopes.length).to.equal(1);
                return eventStore.retrieve(scope);
            })
            .then(function (messages) {
                expect(messages.length).to.equal(1);
            });
    });

    test("only server messages with seq later than requested are returned", function () {
        var first;
        return eventStore.clear()
            .then(function () {
                return gateway.publish({ topic: 'topic', data: scope })
            })
            .then(function (envelope) {
                first = envelope;
                return gateway.publish({ topic: 'topic', data: scope })
            })
            .then(function () {
                return eventStore.store(scope, first);
            })
            .then(function () {
                return gateway.scope.request({ scope: scope, since: first.seq });
            })
            .then(function (result) {
                expect(result.envelopes.length).to.equal(1);
                expect(result.envelopes[0].seq).to.be.greaterThan(first.seq);
            });
    });

    test("messages can participate in multiple scopes", function () {
        var ids = [uuid.v4(), uuid.v4(), uuid.v4()]
        return eventStore.clear()
            .then(function () {
                return gateway.publish({ topic: 'topic', data: { facetId: [ids[0], ids[1]] } })
            })
            .then(function () {
                return gateway.publish({ topic: 'topic', data: { facetId: [ids[1], ids[2]] } })
            })
            .then(function () {
                return gateway.scope.request({ scope: { facetId: ids[0] } });
            })
            .then(function (result) {
                expect(result.envelopes.length).to.equal(1);
            })
            .then(function () {
                return gateway.scope.request({ scope: { facetId: ids[1] } });
            })
            .then(function (result) {
                expect(result.envelopes.length).to.equal(2);
            });
    });

    test("scopes can contain single topics", function () {
        var topic = uuid.v4();
        return gateway.publish({ topic: topic })
            .then(function (envelope) {
                return gateway.publish({ topic: uuid.v4() })
            })
            .then(function () {
                return gateway.scope.request({ scope: { topic: topic } });
            })
            .then(function (result) {
                expect(result.envelopes.length).to.equal(1);
            });
    });

    // test("messages are no longer published to server after scope is released", function () {
    //     var scope = { facetId: uuid() };
    //     return scopes.request(scope)
    //         .then(function () {
    //             pubsub.publish('topic', scope);
    //             scopes.release(scope);
    //             pubsub.publish('topic', scope);
    //             return scopes.request(scope);
    //         })
    //         .then(function (data) {
    //             expect(data.envelopes.length).to.equal(1);
    //             scopes.release(scope);
    //         });
    // });

    function delay(ms) {
        return function () {
            var promise = Q.defer();
            setTimeout(promise.resolve, ms);
            return promise.promise;
        }
    }
});
