$.mockjax({
    url: 'Integration/Panes/Events/async.htm',
    responseText: '<div class="async">\n    <span data-bind="text: message" class="message"></span>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/async.js',
    responseText: 'TC.registerModel(function (pane) {\n    this.message = \'test message\';\n    \n    this.paneRendered = function() {\n        if (Test.state.paneRendered) Test.state.paneRendered();\n    };\n\n    this.renderComplete = function() {\n        if (Test.state.renderComplete) Test.state.renderComplete();\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/asyncParent.htm',
    responseText: '<div data-bind="pane: \'async\'">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/asyncParent.js',
    responseText: 'TC.registerModel(function (pane) {\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/basic.css',
    responseText: '.basic {}',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/basic.htm',
    responseText: '<div class="basic">\n    <span data-bind="text: message" class="message"></span>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/basic.js',
    responseText: 'TC.registerModel(function (pane) {\n    var self = this;\n    \n    Test.state.model = this;\n    Test.state.pane = pane;\n\n    this.message = \'\';\n    this.paneRenderedCalled = false;\n    this.renderCompleteCalled = false;\n    this.disposeCalled = false;\n    \n    this.initialise = function() {\n        self.message = \'test message\';\n    };\n\n    this.paneRendered = function() {\n        self.paneRenderedCalled = true;\n    };\n\n    this.renderComplete = function() {\n        self.renderCompleteCalled = true;\n    };\n\n    this.dispose = function() {\n        self.disposeCalled = true;\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/basicParent.htm',
    responseText: '<div data-bind="pane: \'basic\'" class="basicContainer">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/data.htm',
    responseText: '<div class="data">\n    <span class="message" data-bind="text: message"></span>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/data.js',
    responseText: 'TC.registerModel(function(pane) {\n    this.message = pane.data;\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/dispose.htm',
    responseText: '<div class="dispose">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/dispose.js',
    responseText: 'TC.registerModel(function (pane) {\n    Test.state.disposeCallCount = 0;\n    Test.state.disposed = $.Deferred();\n    \n    this.dispose = function() {\n        Test.state.disposed.resolve();\n        Test.state.disposeCallCount++;\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/initialise.htm',
    responseText: '<div class="initialise"></div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/initialise.js',
    responseText: 'TC.registerModel(function (pane) {\n    this.initialise = function() {\n        return Test.state.deferred = $.Deferred();\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/initialiseParent.htm',
    responseText: '<div data-bind="pane: \'initialise\'">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Events/initialiseParent.js',
    responseText: 'TC.registerModel(function (pane) {\n    this.renderComplete = function() {\n        Test.state.parentRenderCompleteCalled = true;\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/History/content1.htm',
    responseText: '<div class="content1">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/History/content2.htm',
    responseText: '<div class="content2">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/History/layout.htm',
    responseText: '<div class="layout">\n    <div data-bind="pane: \'content1\', handlesNavigation: true"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Navigate/child1.htm',
    responseText: '<div class="child1">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Navigate/child2.htm',
    responseText: '<div class="child2">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Navigate/content1.htm',
    responseText: '<div class="content1">\n    <div data-bind="pane: \'child1\'"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Navigate/content2.htm',
    responseText: '<div class="content2">\n    <div data-bind="pane: \'child2\'"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Navigate/layout.htm',
    responseText: '<div class="layout">\n    <div data-bind="pane: \'content1\', handlesNavigation: true"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Paths/common.htm',
    responseText: '<div class="common">\n    <div data-bind="pane: pane"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Paths/common.js',
    responseText: 'TC.registerModel(function(pane) {\n    pane.node.skipPath = true;\n    this.pane = pane.data.pane;\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Paths/Subfolder/child.htm',
    responseText: '<div class="child">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Paths/Subfolder/parent.htm',
    responseText: '<div class="parent">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Paths/Subfolder/parent.js',
    responseText: 'TC.registerModel(function(pane) {\n    this.renderComplete = function() {\n        TC.createNode(\'.parent\', { path: \'/Paths/common\', data: { pane: \'child\' } });\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/PubSub/subscriber.htm',
    responseText: '<div class="subscriber">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/PubSub/subscriber.js',
    responseText: 'TC.registerModel(function(pane) {\n    pane.pubsub.subscribe(\'test\', function(data) {\n        $(\'.subscriber\').text(data);\n    });\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Transition/pane1.htm',
    responseText: '<div class="pane1">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Transition/pane2.htm',
    responseText: '<div class="pane2">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/1.htm',
    responseText: '<div class="1" data-bind="pane: \'11\'">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/1.js',
    responseText: 'TC.registerModel(function (pane) {\n    Test.state.pane = pane;\n\n    this.renderComplete = function() {\n        if (Test.state.renderComplete) Test.state.renderComplete();\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/11.htm',
    responseText: '<div class="11">\n    <div data-bind="pane: \'111\'"></div>\n    <div data-bind="pane: \'112\'"></div>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/111.htm',
    responseText: '<div class="111">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/112.htm',
    responseText: '<div class="112">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Tree/12.htm',
    responseText: '<div class="12">\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Utilities/child.htm',
    responseText: '<div class="child">\n    <span class="message" data-bind="text: message"></span>\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Utilities/child.js',
    responseText: 'TC.registerModel(function(pane) {\n    this.message = "test message";\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Utilities/dynamicParent.htm',
    responseText: '<div class="dynamicParent">\n\n</div>',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Utilities/dynamicParent.js',
    responseText: 'TC.registerModel(function(pane) {\n    this.paneRendered = function() {\n        TC.createNode(\'.dynamicParent\', { path: \'child\' });\n    };\n});',
    responseTime: 0
});
$.mockjax({
    url: 'Integration/Panes/Utilities/parent.htm',
    responseText: '<div class="parent" data-bind="pane: \'child\'">\n\n</div>',
    responseTime: 0
});

$.mockjax({ url: 'Integration/Panes/Events/async.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/asyncParent.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/basicParent.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/basicParent.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/data.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/dispose.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/initialise.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Events/initialiseParent.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/content1.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/content1.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/content2.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/content2.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/layout.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/History/layout.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/child1.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/child1.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/child2.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/child2.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/content1.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/content1.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/content2.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/content2.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/layout.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Navigate/layout.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Paths/common.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Paths/Subfolder/child.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Paths/Subfolder/child.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Paths/Subfolder/parent.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/PubSub/subscriber.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Transition/pane1.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Transition/pane1.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Transition/pane2.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Transition/pane2.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/1.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/11.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/11.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/111.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/111.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/112.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/112.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/12.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Tree/12.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Utilities/child.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Utilities/dynamicParent.css', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Utilities/parent.js', status: 404, responseTime: 0 });
$.mockjax({ url: 'Integration/Panes/Utilities/parent.css', status: 404, responseTime: 0 });
(function () {
    var moduleFunction = module;
    module = function(name, lifecycle) {
        return moduleFunction('Tribe.Forms.' + name, lifecycle);
    };
    
window.eval("TF.Tests = {\n    renderTemplate: function (name, model) {\n        var $qunit = $('#qunit-fixture');\n        ko.cleanNode($qunit[0]);\n        $qunit.append($('#template--' + name).html());\n        ko.applyBindings(model, $qunit[0]);\n    }\n}\n//@ sourceURL=tribe://Tests/Infrastructure/helpers.js");
window.eval("(function () {\n    var model;\n    var list = [\n        { value: 1, text: 'One' },\n        { value: 2, text: 'Two' },\n        { value: 3, text: 'Three' }\n    ];\n\n    module('fields', {\n        setup: function () {\n            model = createModel();\n            TF.Tests.renderTemplate('fields', model);\n        }\n    });\n\n    test(\"Labels are rendered correctly\", function () {\n        expect(8);\n        $.each($('.label'), function () {\n            equal(this.innerText, 'label');\n        });\n    });\n\n    test(\"Existing values are rendered correctly\", function () {\n        equal(getDisplay(0, 'span').html(), 'value');\n        equal(getDisplay(1, 'input').val(), 'text');\n        equal(getDisplay(2, 'input').val(), '01/01/2001');\n        equal(getDisplay(3, 'input').val(), 'password');\n        equal(getDisplay(4, 'select').val(), '2');\n        equal(getDisplay(5, 'select option:checked').text(), 'Two');\n        equal(getDisplay(6, 'input:checked').val(), '2');\n        equal(getDisplay(7, 'input').is(':checked'), true);\n    });\n\n    test(\"Model values are updated\", function () {\n        getDisplay(1, 'input').val('new').change();\n        getDisplay(2, 'input').val('02/02/2002').change();\n        getDisplay(3, 'input').val('abc123').change();\n        getDisplay(4, 'select').val('3').change();\n        getDisplay(5, 'select').prop('selectedIndex', 2).change();\n        getDisplay(6, 'input:eq(2)').click().click(); // not sure, but it works...\n        getDisplay(7, 'input').click();\n\n        equal(model.text(), 'new');\n        equal(model.date(), '02/02/2002');\n        equal(model.password(), 'abc123');\n        equal(model.simpleSelect(), '3');\n        equal(model.objectSelect(), list[2]);\n        equal(model.radio(), '3');\n        equal(model.boolean(), false);\n    });\n\n    test(\"Displayed values are updated\", function () {\n        model.display('new');\n        model.text('new');\n        model.date('02/02/2002');\n        model.password('abc123');\n        model.simpleSelect('3');\n        model.objectSelect(list[2]);\n        model.radio('3');\n        model.boolean(false);\n\n        equal(getDisplay(0, 'span').html(), 'new');\n        equal(getDisplay(1, 'input').val(), 'new');\n        equal(getDisplay(2, 'input').val(), '02/02/2002');\n        equal(getDisplay(3, 'input').val(), 'abc123');\n        equal(getDisplay(4, 'select').val(), '3');\n        equal(getDisplay(5, 'select option:checked').text(), 'Three');\n        equal(getDisplay(6, 'input:checked').val(), '3');\n        equal(getDisplay(7, 'input').is(':checked'), false);\n    });\n\n    function getDisplay(index, tag) {\n        return $('#qunit-fixture .field:eq(' + index + ') .display ' + tag);\n    }\n\n    function createModel() {\n        return {\n            display: ko.observable('value'),\n            text: ko.observable('text'),\n            date: ko.observable('01/01/2001'),\n            password: ko.observable('password'),\n            simpleSelect: ko.observable('2'),\n            objectSelect: ko.observable(list[1]),\n            radio: ko.observable('2'),\n            boolean: ko.observable(true),\n            list: list\n        };\n    };\n})();\n\n//@ sourceURL=tribe://Tests/fields.tests.js");
window.eval("(function () {\n    var model;\n    \n    module('forms', {\n        setup: function () {\n            model = {\n                data: { text: ko.observable('test') },\n            };\n            TF.Tests.renderTemplate('forms', model);\n        }\n    });\n\n    test(\"Existing field renders\", function () {\n        equal($('.existing input').val(), 'test');\n    });\n    \n    test(\"properties are created on existing objects in create mode\", function() {\n        equal(model.data.text2(), 'test');\n    });\n\n    test(\"objects are created on existing objects in create mode\", function() {\n        equal(model.data.created.text3(), 'test');\n    });\n    \n    test(\"new objects are created\", function () {\n        expect(2);\n        $('#testButton').click();\n        delete window.testCreatedObject;\n    });\n\n    window.testCreatedObject = function (model) {\n        equal(model.text4(), 'test');\n        equal(model.text5.text6(), 'test');\n    };\n\n})();\n\n//@ sourceURL=tribe://Tests/forms.tests.js");
window.eval("(function () {\n    module('Utils');\n\n    var utils = TF.Utils;\n\n    test(\"normaliseBindings evaluates function passed as value\", function () {\n        equal(utils.normaliseBindings(value, function () { return {}; }).value, 'test');\n\n        function value() {\n            return function () {\n                return 'test';\n            };\n        }\n    });\n\n    test(\"evaluateProperty\", function () {\n        var target = {\n            test1: {\n                test11: 'test',\n                test12: {\n                    test121: 'test'\n                }\n            },\n            test2: 'test'\n        };\n\n        equal(utils.evaluateProperty(target, 'test3'), undefined);\n        equal(utils.evaluateProperty(target, 'test3.test4'), undefined);\n        equal(utils.evaluateProperty(target, 'test1.test4'), undefined);\n        equal(utils.evaluateProperty(target, ''), target);\n        equal(utils.evaluateProperty(target, 'test1'), target.test1);\n        equal(utils.evaluateProperty(target, 'test2'), 'test');\n        equal(utils.evaluateProperty(target, 'test1.test11'), 'test');\n        equal(utils.evaluateProperty(target, 'test1.test12.test121'), 'test');\n        equal(utils.evaluateProperty(target, '.test1'), target.test1);\n        equal(utils.evaluateProperty(target, 'test1.'), target.test1);\n        equal(utils.evaluateProperty(target, 'test1..test11'), 'test');\n\n        var container = {};\n        equal(utils.evaluateProperty(target, 'test3', container), container);\n        equal(target.test3, container);\n        utils.evaluateProperty(target, 'test3.test4', 'test');\n        equal(target.test3.test4, 'test');\n\n        utils.evaluateProperty(target, 'test4.test5.test6', 'test');\n        equal(target.test4.test5.test6, 'test');\n    });\n\n    test(\"cloneData\", function () {\n        var object = {};\n        var result = utils.cloneData({\n            func: function () { },\n            string: 'string',\n            object: object,\n            observable: ko.observable('test'),\n            except1: 'except1',\n            except2: 'except2'\n        }, 'except1', 'except2');\n\n        equal(result.func, undefined);\n        equal(result.string, 'string');\n        equal(result.object, object);\n        equal(result.observable, 'test');\n        equal(result.except1, undefined);\n        equal(result.except2, undefined);\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Utils.tests.js");
$('head')
    .append('<script type="text/template" id="template--fields"><div data-bind="display: display, displayText: \'label\'"></div>\n<div data-bind="textField: text, displayText: \'label\'"></div>\n<div data-bind="dateField: date, displayText: \'label\'"></div>\n<div data-bind="passwordField: password, displayText: \'label\'"></div>\n<div data-bind="selectField: simpleSelect, displayText: \'label\', items: [\'1\', \'2\', \'3\']"></div>\n<div data-bind="selectField: objectSelect, displayText: \'label\', items: list, optionsText: \'text\'"></div>\n<div data-bind="radioField: radio, displayText: \'label\', items: [\'1\', \'2\', \'3\']"></div>\n<div data-bind="booleanField: boolean, displayText: \'label\'"></div>\n</script>');
$('head')
    .append('<script type="text/template" id="template--forms"><div class="existing" data-bind="form: data">\n    <div data-bind="textField: text"></div>\n</div>\n\n<div class="createProperties" data-bind="form: data, create: true">\n    <div data-bind="textField: \'text2\', defaultValue: \'test\'"></div>    \n</div>\n\n<div class="createObject" data-bind="form: \'data.created\', create: true">\n    <div data-bind="textField: \'text3\', defaultValue: \'test\'"></div>        \n</div>\n\n<div class="newObject" data-bind="form: {}, create: true">\n    <div data-bind="textField: \'text4\', defaultValue: \'test\'"></div>\n    <div data-bind="textField: \'text5.text6\', defaultValue: \'test\'"></div>\n    <button id="testButton" data-bind="click: testCreatedObject"></button>\n</div></script>');

        
    module = moduleFunction;
})();(function () {
    var moduleFunction = module;
    module = function(name, lifecycle) {
        return moduleFunction('Tribe.Composite.' + name, lifecycle);
    };
    
Test = {
    Unit: {},
    Integration: {},
    state: {}
};

Test.defaultOptions = function() {
    return {
        synchronous: true,
        handleExceptions: false,
        basePath: 'Integration/Panes/',
        loadStrategy: 'adhoc',
        events: TC.defaultOptions().events,
        defaultUrlProvider: TC.options.defaultUrlProvider
    };
};
TC.options = Test.defaultOptions();


QUnit.testDone(function () {
    ko.cleanNode(document.getElementById('qunit-fixture'));
    Test.state = {};
    TC.options = Test.defaultOptions();
});

TC.history.dispose();window.eval("TC.context = function (state) {\n    Test.Integration.context = $.extend({\n        models: new TC.Types.Models(),\n        loader: new TC.Types.Loader(),\n        options: TC.options,\n        templates: new TC.Types.Templates(),\n        loadedPanes: {},\n        renderOperation: new TC.Types.Operation(),\n        pubsub: Test.Integration.pubsub()\n    }, state);\n    return Test.Integration.context;\n};\n//@ sourceURL=tribe://Integration/Infrastructure/context.js");
window.eval("(function () {\n    var helpers = Test.Integration;\n\n    helpers.executeEvents = function (events, pane, data) {\n        TC.options.events = events;\n        TC.options.basePath = 'Integration/Panes';\n\n        var $element = $('#qunit-fixture');\n        $element.append('<div data-bind=\"pane: \\'' + pane + '\\', data: \\'' + data + '\\'\"></div>');\n        ko.applyBindings(null, $element.children()[0]);\n    };\n\n    helpers.executeDefaultEvents = function (pane) {\n        helpers.executeEvents(TC.defaultOptions().events, pane);\n    };\n\n    helpers.createTestElement = function() {\n        $('#qunit-fixture').append('<div class=\"test\"/>');\n    };\n\n    helpers.testEventsUntil = function(event) {\n        var events = [];\n        var defaultEvents = TC.defaultOptions().events;\n        for (var i = 0, l = defaultEvents.length; i < l; i++) {\n            events.push(defaultEvents[i]);\n            if (defaultEvents[i] === event)\n                break;\n        }\n        TC.Events.spy = sinon.spy();\n        events.push('spy');\n        return events;\n    };\n\n    helpers.teardown = function() {\n        $('.__tribe').remove();\n    };\n})();\n\n//@ sourceURL=tribe://Integration/Infrastructure/helpers.js");
window.eval("Test.Integration.pubsubAsMock = function() {\n    Test.Integration.pubsub = function() {\n        var pubsub = { end: sinon.spy(), createLifetime: function () { return pubsub; } };\n        sinon.spy(pubsub, 'createLifetime');\n        return pubsub;\n    };\n};\n\nTest.Integration.pubsubAsTribe = function () {\n    Test.Integration.pubsub = function () {\n        return new Tribe.PubSub({ sync: true });\n    };\n};\n\nTest.Integration.pubsubAsMock();\n//@ sourceURL=tribe://Integration/Infrastructure/pubsub.js");
window.eval("Test.Unit.context = function () {\n    var template = '';\n    var context = {\n        loader: {\n            get: sinon.spy()\n        },\n        models: {\n            test: { constructor: sinon.spy() }\n        },\n        options: {\n            synchronous: true,\n            basePath: '',\n            events: ['test']\n        },\n        templates: {\n            template: '',\n            store: sinon.spy(),\n            loaded: sinon.spy(),\n            render: function() {\n                $('#qunit-fixture').append(template);\n            }\n        },\n        setTemplate: function(value) {\n            template = value;\n        },\n        loadedPanes: {},\n        rootNode: null,\n        renderOperation: {\n            promise: $.Deferred(),\n            complete: function () { }\n        }\n    };\n    sinon.spy(context.templates, 'render');\n    return context;\n};\n//@ sourceURL=tribe://Unit/Infrastructure/context.js");
window.eval("Test.Unit.node = function () {\n    var pane = Test.pane();\n    return {\n        pane: pane,\n        path: pane.path,\n        children: [],\n        nodeForPath: function() { return this; }\n    };\n};\n//@ sourceURL=tribe://Unit/Infrastructure/node.js");
window.eval("Test.pane = function () {\n    return {\n        path: 'test',\n        element: '#qunit-fixture',\n        model: {\n            initialise: sinon.spy(),\n            paneRendered: sinon.spy()\n        },\n        startRender: function () { },\n        endRender: function () { },\n        dispose: function () { }\n    };\n};\n//@ sourceURL=tribe://Unit/Infrastructure/pane.js");
window.eval("(function() {\n    module('Unit.Utilities.bindingHandlers');\n\n    test(\"enterPressed executes callback when enter keyup event occurs in specified element, passing element value\", function () {\n        var element = $('<input/>').appendTo('#qunit-fixture');\n        var spy = sinon.spy();\n        ko.bindingHandlers.enterPressed.init(element[0], function () { return spy; });\n    \n        ok(spy.notCalled);\n        element.val('value');\n        element.trigger(keyEvent('keyup', 13));\n        ok(spy.calledOnce);\n        ok(spy.calledWithExactly('value'));\n    });\n    \n    function keyEvent(eventName, which) {\n        var event = jQuery.Event(eventName);\n        event.which = which;\n        return event;\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/bindingHandlers.tests.js");
window.eval("module('Unit.Utilities.collections');\n\ntest(\"each executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.each(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"each executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.each({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.map(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"map executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.map({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map does not flatten arrays\", function() {\n    var result = T.map([1, 2], function () { return [3, 4]; });\n    equal(result.length, 2);\n    deepEqual(result[0], [3, 4]);\n    deepEqual(result[1], [3, 4]);\n});\n\ntest(\"map returns empty array for undefined input\", function() {\n    var spy = sinon.spy();\n    deepEqual(T.map(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"filter executes once for each item of array\", function() {\n    var spy = sinon.spy();\n    T.filter(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"filter executes once for each property of object\", function () {\n    var spy = sinon.spy();\n    T.filter({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"filter returns array of values filtered by iterator function\", function() {\n    var result = T.filter(['1', '2'], function (item) { return item !== '1'; });\n    equal(result.length, 1);\n    equal(result[0], '2');\n});\n\ntest(\"filter returns empty array for undefined input\", function () {\n    var spy = sinon.spy();\n    deepEqual(T.filter(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"pluck returns property value from each object in array\", function() {\n    var result = T.pluck([\n        { one: 'a', two: 'b' },\n        { one: 'c', two: 'd' },\n        { one: 'e', two: 'f' }\n    ], 'one');\n    equal(result.length, 3);\n    equal(result.join(''), 'ace');\n});\n\ntest(\"reduce executes reduceFunction with expected arguments\", function() {\n    var spy = sinon.spy();\n    var list = [1, 2];\n    T.reduce(list, 'initial', spy);\n\n    equal(spy.callCount, 2);\n    deepEqual(spy.firstCall.args, ['initial', 1, 0, list]);\n    deepEqual(spy.secondCall.args, [undefined, 2, 1, list]);\n});\n\ntest(\"reduce returns expected result\", function() {\n    var result = T.reduce([1, 2, 3, 4], 10, function(memo, value) {\n        return memo + value;\n    });\n    equal(result, 20);\n});\n//@ sourceURL=tribe://Unit/Utilities/collections.tests.js");
window.eval("module('Unit.Utilities.elementDestroyed');\n\ntest(\"promise resolves when element is removed using jQuery\", function () {\n    expect(1);\n    var element = $('<div/>').appendTo('#qunit-fixture');\n    $.when(TC.Utils.elementDestroyed(element)).done(function() {\n        ok(true);\n    });\n    element.remove();\n});\n\nasyncTest(\"promise resolves when element is removed using native functions\", function () {\n    expect(1);\n    var element = $('<div/>').appendTo('#qunit-fixture');\n    $.when(TC.Utils.elementDestroyed(element)).done(function () {\n        ok(true);\n        start();\n    });\n    element[0].parentNode.removeChild(element[0]);\n});\n\n//@ sourceURL=tribe://Unit/Utilities/elementDestroyed.tests.js");
window.eval("(function () {\n    module('Unit.Utilities.idGenerator');\n\n    test(\"idGenerator starts at 0 and generates sequential numbers\", function () {\n        var generator = TC.Utils.idGenerator();\n        equal(generator.next(), 0);\n        equal(generator.next(), 1);\n        equal(generator.next(), 2);\n        equal(generator.next(), 3);\n        equal(generator.next(), 4);\n    });\n\n    test(\"getUniqueId is a static generator\", function() {\n        equal(TC.Utils.getUniqueId(), 0);\n        equal(TC.Utils.getUniqueId(), 1);\n        equal(TC.Utils.getUniqueId(), 2);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/idGenerator.tests.js");
window.eval("(function () {\n    var deferreds;\n\n    module(\"Unit.Utilities.jquery.complete\", {\n        setup: function() { deferreds = [ $.Deferred(), $.Deferred() ]; }\n    });\n\n    test(\"complete resolves when at least one deferred resolves\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].resolve();\n        equal(result.state(), 'resolved');\n    });\n\n    test(\"complete rejects when all passed deferreds reject\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].reject();\n        equal(result.state(), 'rejected');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/jquery.complete.tests.js");
window.eval("(function() {\n    module('Unit.Utilities.nodes', {\n        setup: function () {\n            TC.Events.spy = sinon.spy();\n            TC.options.events = ['spy'];\n        }\n    });\n\n    test(\"createNode executes events specified in options with new node\", function () {\n        TC.createNode('#qunit-fixture');\n        ok(TC.Events.spy.calledOnce);\n        ok(pane());\n    });\n\n    test(\"appendNode appends wrapper to target element\", function() {\n        TC.appendNode('#qunit-fixture');\n        equal($('#qunit-fixture div').length, 1);\n    });\n\n    function pane() {\n        return TC.Events.spy.firstCall.args[0];\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/nodes.tests.js");
window.eval("(function() {\n    var utils = TC.Utils;\n    module('Unit.Utilities.objects');\n\n    test(\"arguments.byConstructor\", function() {\n        var argsToPass = [\"\", {}, function() {\n        }, [], 2.2];\n\n        (function() {\n            var args = utils.arguments(arguments);\n            equal(args.string, argsToPass[0]);\n            equal(args.object, argsToPass[1]);\n            equal(args.function, argsToPass[2]);\n            equal(args.array, argsToPass[3]);\n            equal(args.number, argsToPass[4]);\n\n        }).apply(null, argsToPass);\n    });\n\n    test(\"removeItem removes matching item from array\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 2);\n        deepEqual(array, [1, 3]);\n    });\n\n    test(\"removeItem does not affect array if item does not exist\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 4);\n        deepEqual(array, [1, 2, 3]);\n    });\n\n    test(\"inheritOptions\", function() {\n        var source = { test1: 'test', test2: 2 };\n        equal(TC.Utils.inheritOptions(source, {}, ['test1']).test1, 'test');\n        equal(TC.Utils.inheritOptions(source, {}, ['test2']).test2, 2);\n        equal(TC.Utils.inheritOptions(source, {}, ['test1', 'test2', 'test3']).test3, undefined);\n    });\n})();\n//@ sourceURL=tribe://Unit/Utilities/objects.tests.js");
window.eval("(function () {\n    var utils = TC.Utils;\n    \n    module('Unit.Utilities.panes');\n\n    test(\"getPaneOptions\", function () {\n        deepEqual(utils.getPaneOptions('test'), { path: 'test' }, \"accepts string value as path\");\n        deepEqual(utils.getPaneOptions('test', { data: 'data' }), { path: 'test', data: 'data' }, \"accepts string value as path and merges other options\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }), { path: 'test' }, \"accepts options object\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }, { data: 'data' }), { path: 'test', data: 'data' }, \"accepts options object and merges other options\");\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/panes.tests.js");
window.eval("(function () {\n    module(\"Unit.Utilities.Path\");\n\n    test('Path handles empty arguments', function () {\n        equal(TC.Path('').toString(), '');\n        equal(TC.Path(undefined).toString(), '');\n        equal(TC.Path(null).toString(), '');\n    });\n\n    test(\"withoutFilename\", function () {\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").withoutFilename().toString(), \"/folder/subfolder/\", \"Path with slashes\");\n    });\n\n    test(\"filename\", function () {\n        equal(TC.Path(\"filename.ext\").filename().toString(), \"filename.ext\", \"Filename\");\n        equal(TC.Path(\"/filename.ext\").filename().toString(), \"filename.ext\", \"Root path filename\");\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").filename().toString(), \"filename.ext\", \"Path with slashes\");\n    });\n\n    test(\"extension\", function () {\n        equal(TC.Path(\"filename.ext\").extension().toString(), \"ext\", \"Filename\");\n        equal(TC.Path(\"/filename.ext\").extension().toString(), \"ext\", \"Root path filename\");\n        equal(TC.Path(\"filename\").extension().toString(), \"\", \"Filename without extension\");\n        equal(TC.Path(\"/filename\").extension().toString(), \"\", \"Root path filename without extension\");\n        equal(TC.Path(\"filename.\").extension().toString(), \"\", \"Empty extension\");\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").extension().toString(), \"ext\", \"Path with slashes\");\n    });\n\n    test(\"withoutExtension\", function () {\n        equal(TC.Path(\"filename.ext\").withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"filename\").withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"/test/filename.ext\").withoutExtension().toString(), \"/test/filename\");\n        equal(TC.Path(\"/test/filename\").withoutExtension().toString(), \"/test/filename\");\n        equal(TC.Path(\"/test/filename.ext\").filename().withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"/test/filename\").filename().withoutExtension().toString(), \"filename\");\n    });\n\n    test(\"Path objects can be concatenated with strings\", function () {\n        equal(TC.Path('/folder/filename.ext').withoutFilename() + 'new.ext', '/folder/new.ext');\n    });\n\n    test(\"isAbsolute\", function () {\n        ok(TC.Path(\"/test/\").isAbsolute());\n        ok(TC.Path(\"http://test/\").isAbsolute());\n        ok(!TC.Path(\"test/\").isAbsolute());\n        ok(!TC.Path(\"test.txt\").isAbsolute());\n        ok(!TC.Path(\"../test.txt\").isAbsolute());\n    });\n\n    test(\"makeAbsolute\", function () {\n        equal(TC.Path(\"/test\").makeAbsolute().toString(), \"/test\");\n        equal(TC.Path(\"test\").makeAbsolute().toString(), \"/test\");\n        equal(TC.Path(\"test.txt\").makeAbsolute().toString(), \"/test.txt\");\n        equal(TC.Path(\"test/test.txt\").makeAbsolute().toString(), \"/test/test.txt\");\n    });\n\n    test(\"makeRelative\", function () {\n        equal(TC.Path(\"test\").makeRelative().toString(), \"test\");\n        equal(TC.Path(\"/test\").makeRelative().toString(), \"test\");\n        equal(TC.Path(\"/test.txt\").makeRelative().toString(), \"test.txt\");\n        equal(TC.Path(\"/test/test.txt\").makeRelative().toString(), \"test/test.txt\");\n    });\n\n    test(\"normalise\", function () {\n        equal(TC.Path('test').toString(), 'test');\n        equal(TC.Path('../test').toString(), '../test');\n        equal(TC.Path('test1/../test2').toString(), 'test2');\n        equal(TC.Path('/test1/../test2').toString(), '/test2');\n        equal(TC.Path('/test1/../test2/../test3').toString(), '/test3');\n        equal(TC.Path('./test').toString(), 'test');\n        equal(TC.Path('test1/./test2').toString(), 'test1/test2');\n        equal(TC.Path('.././test1/../test2').toString(), '../test2');\n        equal(TC.Path('http://test//test.htm').toString(), 'http://test/test.htm');\n        equal(TC.Path('http://test///test//test.htm').toString(), 'http://test/test/test.htm');\n        equal(TC.Path('1///2//3/4/5').toString(), '1/2/3/4/5');\n    });\n\n    test(\"asPathIdentifier\", function () {\n        equal(TC.Path('test.txt').asMarkupIdentifier().toString(), 'test');\n        equal(TC.Path('test/test.txt').asMarkupIdentifier().toString(), 'test-test');\n    });\n\n    test(\"setExtension\", function() {\n        equal(TC.Path('/test/test').setExtension('js').toString(), '/test/test.js');\n        equal(TC.Path('/test/test.txt').setExtension('js').toString(), '/test/test.js');\n    });\n\n    test(\"combine\", function() {\n        equal(TC.Path('/test/').combine('/test.txt').toString(), '/test/test.txt');\n        equal(TC.Path('http://test/').combine('/test.txt').toString(), 'http://test/test.txt');\n        equal(TC.Path('/1/').combine('/2/').combine('/test.txt').toString(), '/1/2/test.txt');\n        equal(TC.Path('').combine('test.txt').toString(), 'test.txt');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/Path.tests.js");
window.eval("(function () {\n    module('Unit.Utilities.querystring');\n    \n    var querystring = TC.Utils.Querystring;\n\n    test(\"stringify handles flat objects\", function() {\n        equal(querystring.stringify({ test: 't', test2: 2 }), 'test=t&test2=2');\n    });\n    \n    test(\"stringify handles nested objects\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: 't' } })), 'test[test2]=t');\n        equal(decodeURI(querystring.stringify({ test: { test2: { test3: 't' } } })), 'test[test2][test3]=t');\n    });\n\n    test(\"stringify handles arrays\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } })), 'test[test2][][test3]=t');\n    });\n\n    test(\"stringify handles arrays with arrayKey set to false\", function () {\n        equal(\n            decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } }, { arrayKey: false })),\n            'test[test2][test3]=t');\n    });\n\n    test(\"stringify raises if source contains cyclic references\", function () {\n        raises(function () {\n            var test1 = {};\n            var test2 = { test1: test1 };\n            test1.test2 = test2;\n            querystring.stringify(test1);\n        });\n    });\n\n    test(\"parse handles flat objects\", function () {\n        deepEqual(querystring.parse('test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse strips leading question mark\", function () {\n        deepEqual(querystring.parse('?test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse handles nested objects\", function () {\n        deepEqual(querystring.parse('test[test2]=t'), { test: { test2: 't' } });\n        deepEqual(querystring.parse('test[test2][test3]=t'), { test: { test2: { test3: 't' } } });\n    });\n\n    test(\"parse handles arrays\", function () {\n        deepEqual(querystring.parse('test[test2][][test3]=t'), { test: { test2: [{ test3: 't' }] } });\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Utilities/querystring.tests.js");
window.eval("(function () {\n    var spy;\n    var pubsub;\n    var pane;\n    var node;\n    \n    module('Unit.Types.Flow', {\n        setup: function () {\n            spy = sinon.spy();\n            pubsub = new Tribe.PubSub({ sync: true });\n            pane = new TC.Types.Pane({ pubsub: pubsub });\n            node = new TC.Types.Node(null, pane);\n            node.findNavigation = function () { return { node: { navigate: spy, pane: pane } }; };\n        }\n    });\n    \n    test(\"constructor arguments are passed to definition constructor\", function () {\n        expect(2);\n        var f = new TC.Types.Flow(node, constructor, 'arg1', 'arg2');\n        function constructor(flow, arg1, arg2) {\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n\n    test(\"arguments to Node.startFlow are passed to definition constructor\", function () {\n        expect(2);\n        var f = node.startFlow(constructor, 'arg1', 'arg2');\n        function constructor(flow, arg1, arg2) {\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n\n    test(\"arguments to Pane.startFlow are passed to definition constructor\", function () {\n        expect(2);\n        var f = pane.startFlow(constructor, 'arg1', 'arg2');\n        function constructor(flow, arg1, arg2) {\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n\n    test(\"Flow calls navigate on navigation pane when navigatesTo is called\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        f.navigatesTo('path', 'data')();\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'path');\n        equal(spy.firstCall.args[1], 'data');\n    });\n\n    test(\"Flow calls navigate on navigation pane when message is received for navigatesTo event\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('navigatesTo');\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'path');\n        equal(spy.firstCall.args[1], 'data');\n    });\n\n    test(\"No handlers are executed after flow ends\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('navigatesTo');\n        pubsub.publish('end');\n        pubsub.publish('navigatesTo');\n        ok(spy.calledOnce);\n    });\n\n    test(\"No handlers are executed after flow ends with null handler\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('navigatesTo');\n        pubsub.publish('null');\n        pubsub.publish('navigatesTo');\n        ok(spy.calledOnce);\n    });\n\n    test(\"Child onstart handler is executed when start child message is received\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('startChild');\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'child');\n    });\n\n    test(\"Child handlers are executed after start child message is received\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('navigateChild');\n        pubsub.publish('startChild');\n        pubsub.publish('navigateChild');\n        ok(spy.calledTwice);\n    });\n\n    test(\"Child handlers are not executed after end child message is received\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('startChild');\n        pubsub.publish('navigateChild');\n        pubsub.publish('endChild');\n        pubsub.publish('navigateChild');\n        ok(spy.calledTwice);\n    });\n\n    test(\"Child handlers are not executed after end flow message is received\", function () {\n        var f = new TC.Types.Flow(node, TestFlow).start();\n        pubsub.publish('startChild');\n        pubsub.publish('navigateChild');\n        pubsub.publish('end');\n        pubsub.publish('navigateChild');\n        ok(spy.calledTwice);\n    });\n\n    function TestFlow(flow) {\n        this.handles = {\n            'navigatesTo': flow.navigatesTo('path', 'data'),\n            'startChild': {\n                onstart: flow.navigatesTo('child'),\n                'navigateChild': flow.navigatesTo('child2'),\n                'endChild': null\n            },\n            'end': flow.end,\n            'null': null\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Flow.tests.js");
window.eval("(function () {\n    var history;\n    var api;\n\n    module('Unit.Types.History', {\n        setup: function () {\n            api = mockHistoryApi();\n            history = new TC.Types.History(api);\n        },\n        teardown: function () {\n            history.dispose();\n        }\n    });\n\n    test(\"browser.go is raised when popstate event is raised normally\", function () {\n        expect(1);\n\n        document.addEventListener('browser.go', assert);\n        raisePopstate();\n        document.removeEventListener('browser.go', assert);\n\n        function assert(e) {\n            equal(e.data.count, 1);\n        }\n    });\n\n    test(\"browser.go is not raised when update is called and popstate is raised\", function () {\n        expect(0);\n        \n        document.addEventListener('browser.go', assert);\n        history.update(1);\n        raisePopstate();\n        document.removeEventListener('browser.go', assert);\n\n        function assert(e) {\n            equal(e.data.count, 1);\n        }\n    });\n\n    test(\"window.history.go is called when go is called\", function () {\n        history.go(1);\n        ok(api.go.calledOnce);\n    });\n\n    test(\"window.history.pushState is called when navigate is called\", function() {\n        history.navigate();\n        ok(api.pushState.calledOnce);\n    });\n\n    test(\"window.history.pushState is called with url and title if urlProvider is passed\", function() {\n        history.navigate({ url: 'url1', title: 'title1' });\n        equal(api.pushState.firstCall.args[1], 'title1');\n        equal(api.pushState.firstCall.args[2], 'url1');\n    });\n\n    function mockHistoryApi() {\n        return {\n            pushState: sinon.spy(),\n            go: sinon.spy(),\n            replaceState: sinon.spy()\n        };\n    }\n\n    function raisePopstate() {\n        var event = document.createEvent(\"Event\");\n        event.initEvent('popstate', true, false);\n        event.state = 1;\n        window.dispatchEvent(event);\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/History.tests.js");
window.eval("(function() {\n    var resources;\n    var context;\n    \n    module(\"Unit.Types.Loader\", {\n        setup: function () {\n            context = Test.Unit.context();\n            resources = new TC.Types.Loader();\n        }\n    });\n\n    test(\"get should call handler for file extension from passed url\", function () {\n        var spy = sinon.spy();\n        TC.LoadHandlers.test = spy;\n        resources.get('test.test');\n        ok(spy.calledOnce);\n    });\n\n    test(\"get should call handler with url, resourcePath and context\", function () {\n        var spy = sinon.spy();\n        TC.LoadHandlers.test = spy;\n        resources.get('test.test', 'test/test', context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'test.test');\n        equal(spy.firstCall.args[1], 'test/test');\n        equal(spy.firstCall.args[2], context);\n    });\n\n    test(\"when passed the same url, get should return the same deferred from first call to handler\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        equal(resources.get('test.test'), deferred);\n    });\n\n    test(\"get should return null after deferred from first call to handler completes\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.resolve();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return null after deferred from first call to handler fails\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.reject();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return different deferred for each unique url\", function () {\n        TC.LoadHandlers.test = function () { return $.Deferred(); };\n        var result1 = resources.get('test1.test');\n        var result2 = resources.get('test2.test');\n        notEqual(result1, result2);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Types/Loader.tests.js");
window.eval("(function() {\n    var logger;\n\n    module(\"Unit.Types.Logger\", {\n        setup: function () {\n            TC.Loggers.test = sinon.spy();\n            logger = new TC.Types.Logger();\n            logger.setLogger('test');\n        }\n    });\n\n    test(\"logger is called with level and message\", function() {\n        logger.warn('test');\n        ok(TC.Loggers.test.calledOnce);\n        ok(TC.Loggers.test.calledWithExactly('warn', 'test'));\n    });\n\n    test(\"default log level logs everything\", function() {\n        logger.debug();\n        logger.info();\n        logger.warn();\n        logger.error();\n        equal(TC.Loggers.test.callCount, 4);\n    });\n\n    test(\"only levels equal or higher than the set value are logged\", function () {\n        logger.setLogLevel('warn');\n        logger.debug();\n        logger.info();\n        ok(TC.Loggers.test.notCalled);\n        logger.warn();\n        logger.error();\n        ok(TC.Loggers.test.calledTwice);\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Logger.tests.js");
window.eval("(function() {\n    var models;\n\n    module('Unit.Types.Models', {\n        setup: function() { models = new TC.Types.Models(); }\n    });\n\n    test(\"register stores model as property with constructor and options\", function () {\n        var constructor = function () { };\n        var options = {};\n        models.register('test', constructor, options);\n        equal(models.test.constructor, constructor);\n        equal(models.test.options, options);\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Models.tests.js");
window.eval("(function () {\n    var nav;\n    var node;\n\n    module('Unit.Types.Navigation', {\n        setup: function () {\n            node = nodeStub('test');\n            nav = new TC.Types.Navigation(node, { transition: 'fade' });\n            TC.history = { navigate: sinon.spy(), update: sinon.spy() };\n        },\n        teardown: function() {\n            nav.dispose();\n        }\n    });\n\n    test(\"forward transitions to specified pane\", function () {\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"forward accepts string transition as options\", function () {\n        nav = new TC.Types.Navigation(node, 'fade');\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"back returns to initial pane with reverse transition\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n        equal(node.transitionTo.secondCall.args[2], true);\n    });\n\n    test(\"back returns to previous pane\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"back does nothing if no stack\", function () {\n        nav.go(-1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"forward does nothing if no stack\", function () {\n        nav.go(1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"back two returns to initial pane\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        equal(node.transitionTo.lastCall.args[0].path, 'test');\n    });\n\n    test(\"forward moves stack forward if stack exists\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        nav.go(1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"document navigating event is raised when navigating\", function () {\n        expect(1);\n        document.addEventListener('navigating', assert);\n        nav.navigate({ path: 'test2' });\n        document.removeEventListener('navigating', assert);\n        \n        function assert(e) {\n            equal(e.data.options.path, 'test2');\n        }\n    });\n\n    test(\"TC.history.navigate is called on navigate when browser option is set\", function() {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        ok(TC.history.navigate.calledOnce);\n    });\n\n    test(\"TC.history.update is called on go when browser option is set\", function () {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        ok(TC.history.update.calledOnce);\n    });\n\n    test(\"node transitions when browser.go event is received\", function() {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        TC.Utils.raiseDocumentEvent('browser.go', { count: -1 });\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n    });\n\n    test(\"initial state is set from urlProvider if paneOptionsFrom returns paneOptions object\", function () {\n        var provider = {\n            paneOptionsFrom: function() {\n                return {\n                    path: 'test',\n                    data: { test: 'test' }\n                };\n            }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0], provider.paneOptionsFrom());\n    });\n\n    test(\"initial state is not set from urlProvider if paneOptionsFrom returns null\", function() {\n        var provider = {\n            paneOptionsFrom: function () { return null; }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0].path, 'test');\n    });\n\n    test(\"history url and title are set from urlProvider when navigating\", function () {\n        var provider = {\n            paneOptionsFrom: function () { return null; },\n            urlDataFrom: function() {\n                return {\n                    url: 'test',\n                    title: 'test'\n                };\n            }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        nav.navigate({ path: 'test2' });\n        deepEqual(TC.history.navigate.firstCall.args[0], provider.urlDataFrom());\n    });\n\n    Test.urlProvider = {\n        urlDataFrom: function() {\n            return {\n                url: 'test',\n                title: 'test'\n            };\n        },\n        paneOptionsFrom: function() {\n            return {\n                path: 'test',\n                data: { test: 'test' }\n            };\n        }\n    };\n\n    function nodeStub(path) {\n        return {\n            id: 1,\n            pane: { path: path },\n            transitionTo: sinon.spy()\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Navigation.tests.js");
window.eval("(function () {\n    module('Unit.Types.Node');\n\n    test(\"node creates Navigation if handlesNavigation is set on pane\", function() {\n        var node = new TC.Types.Node(null, pane('test', true));\n        ok(node.navigation);\n    });\n\n    test(\"findNavigation returns Navigation for root node if no pane handles navigation\", function() {\n        var leaf = createTree();\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for root node if specified\", function () {\n        var leaf = createTree('root');\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for middle node if specified\", function () {\n        var leaf = createTree('middle');\n        equal(leaf.findNavigation().node, leaf.parent);\n        equal(leaf.parent.findNavigation().node, leaf.parent);\n        equal(leaf.root.findNavigation().node, leaf.parent);\n    });\n\n    test(\"findNavigation returns Navigation for leaf node if specified\", function () {\n        var leaf = createTree('leaf');\n        equal(leaf.findNavigation().node, leaf);\n        equal(leaf.parent.findNavigation().node, leaf);\n        equal(leaf.root.findNavigation().node, leaf);\n    });\n\n    test(\"findNavigation returns Navigation for root node if handling node disposed\", function () {\n        var leaf = createTree('leaf');\n        var middle = leaf.parent;\n        leaf.dispose();\n        equal(middle.findNavigation().node, middle.root);\n        equal(leaf.parent.findNavigation().node, middle.root);\n    });\n    \n    function pane(path, handlesNavigation) {\n        return new TC.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    function createTree(navigationNode) {\n        var root = new TC.Types.Node(null, pane('root', navigationNode === 'root'));\n        var middle = new TC.Types.Node(root, pane('middle', navigationNode === 'middle'));\n        var leaf = new TC.Types.Node(middle, pane('leaf', navigationNode === 'leaf'));\n        return leaf;\n    }\n})();\n//@ sourceURL=tribe://Unit/Types/Node.findNavigation.tests.js");
window.eval("(function () {\n    module('Unit.Types.Node');\n\n    function pane(path, handlesNavigation) {\n        return new TC.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    test(\"setPane makes path absolute and sets pane path from pane if no parent\", function() {\n        var node = new TC.Types.Node(null, pane('test'));\n        equal(node.pane.path, '/test');\n    });\n\n    test(\"setPane sets pane path from parent and relative pane path\", function () {\n        var parent = new TC.Types.Node(null, pane('/path/parent'));\n        var node = new TC.Types.Node(parent, pane('child'));\n        equal(node.pane.path, '/path/child');\n    });\n\n    test(\"setPane sets pane path from pane if path is absolute\", function () {\n        var parent = new TC.Types.Node(null, pane('/path/parent'));\n        var node = new TC.Types.Node(parent, pane('/root'));\n        equal(node.pane.path, '/root');\n    });\n\n    test(\"setPane unsets node on existing pane\", function () {\n        var existingPane = pane('test');\n        var node = new TC.Types.Node(null, existingPane);\n        node.setPane(new TC.Types.Pane(pane('test2')));\n        equal(existingPane.node, null);\n    });\n\n    test(\"setPane sets node.navigation when pane.handlesNavigation\", function() {\n        var node = new TC.Types.Node();\n        node.setPane(pane('', 'test'));\n        ok(node.navigation.constructor, TC.Types.Navigation);\n    });\n\n    test(\"node root is set correctly\", function() {\n        var one = new TC.Types.Node(null, pane('one'));\n        var two = new TC.Types.Node(one, pane('two'));\n        var three = new TC.Types.Node(two, pane('three'));\n\n        equal(one.root, one);\n        equal(two.root, one);\n        equal(three.root, one);\n    });\n\n    test(\"dispose removes node from parent collection\", function() {\n        var parent = new TC.Types.Node(null, pane('parent'));\n        var child = new TC.Types.Node(parent, pane('child'));\n        equal(parent.children.length, 1);\n        child.dispose();\n        equal(parent.children.length, 0);\n    });\n\n    test(\"navigate inherits path from existing pane\", function () {\n        var node = new TC.Types.Node(null, pane('/path/node1'));\n        node.transitionTo = sinon.spy();\n        node.navigate('node2');\n        ok(node.transitionTo.calledOnce);\n        equal(node.transitionTo.firstCall.args[0].path, '/path/node2');\n    });\n\n    test(\"nodeForPath returns current node if skipPath is not specified\", function() {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        equal(node2.nodeForPath(), node2);\n    });\n\n    test(\"nodeForPath returns parent if skipPath is specified\", function() {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        node2.skipPath = true;\n        equal(node2.nodeForPath(), node1);\n    });\n\n    test(\"nodeForPath recurses, skipping nodes as specified\", function () {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        var node3 = new TC.Types.Node(node2, pane('/path2/node2'));\n        node2.skipPath = true;\n        node3.skipPath = true;\n        equal(node3.nodeForPath(), node1);\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Node.tests.js");
window.eval("(function () {\n    var operation;\n    \n    module(\"Unit.Types.Operation\", {\n        setup: function() { operation = new TC.Types.Operation(); }\n    });\n\n    test(\"operation resolves when single child completes\", function () {\n        operation.add(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(1);\n        equal(operation.promise.state(), 'resolved');\n    });\n\n    test(\"operation resolves when two children complete\", function() {\n        operation.add(1);\n        operation.add(2);\n        operation.complete(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(2);\n        equal(operation.promise.state(), 'resolved');\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Types/Operation.tests.js");
window.eval("(function() {\n    module('Unit.Types.Pane');\n\n    test(\"inheritPathFrom inherits path if pane path is relative\", function () {\n        var pane = new TC.Types.Pane({ path: 'pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/pane2');\n    });\n\n    test(\"inheritPathFrom doesn't inherit path if pane path is absolute\", function () {\n        var pane = new TC.Types.Pane({ path: '/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/pane2');\n    });\n\n    test(\"inheritPathFrom sets child folders from relative pane path\", function () {\n        var pane = new TC.Types.Pane({ path: 'Test2/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/Test2/pane2');\n    });\n    \n    function wrap(pane) {\n        return {\n            nodeForPath: function() {\n                return { pane: pane };\n            }\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Pane.tests.js");
window.eval("(function () {\n    var events;\n    var pipeline;\n    var eventDeferred;\n    var context = {};\n\n    module(\"Unit.Types.Pipeline\", {\n        setup: function() {\n            events = testEvents();\n            pipeline = new TC.Types.Pipeline(events, context);\n        }\n    });\n\n    test(\"event handlers specified are called\", function () {\n        pipeline.execute(['null1']);\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"event handlers are passed target and context\", function () {\n        var target = {};\n        pipeline.execute(['null1'], target);\n        ok(events.null1.calledWithExactly(target, context));\n    });\n\n    test(\"events returning null are executed synchronously\", function () {\n        pipeline.execute(['null1', 'null2']);\n        ok(events.null1.calledOnce);\n        ok(events.null2.calledOnce);\n    });\n\n    test(\"events are executed when previous event resolves\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        ok(events.null1.notCalled);\n        eventDeferred.resolve();\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"rejected events terminate pipeline execution\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        eventDeferred.reject();\n        ok(events.null1.notCalled);\n    });\n\n    test(\"execute returns deferred that resolves on completion\", function() {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.resolve();\n        equal(deferred.state(), 'resolved');\n    });\n    \n    test(\"execute returns deferred that rejects on failure\", function () {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.reject();\n        equal(deferred.state(), 'rejected');\n    });\n\n    function testEvents() {\n        eventDeferred = $.Deferred();\n        \n        return {\n            null1: sinon.spy(),\n            null2: sinon.spy(),\n            deferred: sinon.stub().returns(eventDeferred),\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Unit/Types/Pipeline.tests.js");
window.eval("(function () {\n    var templates;\n    \n    module('Unit.Types.Templates', {\n        setup: function () { templates = new TC.Types.Templates(); },\n        teardown: function () { $('head script[type=\"text/template\"]').remove(); }\n    });\n\n    test(\"store wraps template in script tag with resource path as id\", function() {\n        templates.store('<br/>', 'test');\n        equal($('head script#template-test').text(), '<br/>');\n    });\n\n    test(\"store appends multiple wrapped templates\", function () {\n        templates.store('<script type=\"text/template\" id=\"test1\">test1</script><script type=\"text/template\" id=\"test2\">test2</script>');\n        equal($('head script#test1').text(), 'test1');\n        equal($('head script#test2').text(), 'test2');\n    });\n\n    test(\"store ignores unwrapped templates\", function () {\n        templates.store('<script type=\"text/template\" id=\"test1\">test1</script>blah<br/><script type=\"text/template\" id=\"test2\">test2</script>');\n        equal($('head script#test1').text(), 'test1');\n        equal($('head script#test2').text(), 'test2');\n    });\n\n    test(\"render replaces content of target with stored template\", function () {\n        $('#qunit-fixture').text('previous');\n        templates.store('content', 'test');\n        templates.render('#qunit-fixture', 'test');\n        equal($('#qunit-fixture').text(), 'content');\n    });\n    \n    test(\"loaded returns true if template has been loaded for specified path\", function () {\n        templates.store('<br/>', 'test');\n        ok(templates.loaded('test'));\n    });\n})();\n//@ sourceURL=tribe://Unit/Types/Templates.tests.js");
window.eval("(function() {\n    var originalEval = $.globalEval;\n    var url = 'test.js';\n    var resourcePath = '/test';\n    var response = \"\";\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n    \n    module(\"Unit.LoadHandlers.scripts\", {\n        setup: function() {\n            context = Test.Unit.context();\n        },\n        teardown: function () { $.globalEval = originalEval; }\n    });\n\n    test(\"script handler returns promise object\", function() {\n        ok(TC.LoadHandlers.js(url, resourcePath, context).promise);\n    });\n\n    test(\"script handler executes globalEval with response\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(0, response.length), response);\n    });\n\n    test(\"script handler appends sourceURL tag\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(response.length + 1), \"//@ sourceURL=tribe://Application/test.js\");\n    });\n\n    test(\"script handler sets TC.scriptEnvironment before executing scripts\", function () {\n        expect(1);\n        response = \"equal(TC.scriptEnvironment.resourcePath, '\" + resourcePath + \"');\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n    });\n\n    test(\"script handler clears TC.scriptEnvironment after executing scripts\", function () {\n        TC.LoadHandlers.js(url, resourcePath, context);\n        equal(TC.scriptEnvironment, undefined);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/scripts.tests.js");
window.eval("(function() {\n    var url = 'test.css';\n    var resourcePath = '/test';\n    var response = \"\";\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.stylesheets');\n    \n    test(\"stylesheet handler returns promise object\", function() {\n        ok(TC.LoadHandlers.css(url, resourcePath, Test.Unit.context()).promise);\n    });\n\n    test(\"stylesheet handler adds stylesheet to page header\", function () {\n        response = \"body{}\";\n        TC.LoadHandlers.css(url, resourcePath, Test.Unit.context());\n        equal($('head style').last().text(), response);\n    });\n\n    test(\"stylesheet is added with id of resource\", function () {\n        response = \"body{}\";\n        TC.LoadHandlers.css(url, resourcePath, Test.Unit.context());\n        equal($('head style#style--test').last().text(), response);\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/stylesheets.tests.js");
window.eval("(function() {\n    var url = 'test.htm';\n    var resourcePath = '/test';\n    var response = '<br/>';\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.templates', {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"template handler returns promise object\", function() {\n        ok(TC.LoadHandlers.htm(url, resourcePath, context).promise);\n    });\n\n    test(\"template is stored with resource path identifier\", function() {\n        TC.LoadHandlers.htm(url, resourcePath, context);\n        ok(context.templates.store.calledOnce);\n        ok(context.templates.store.calledWithExactly('<br/>', '/test'));\n    });\n})();\n\n//@ sourceURL=tribe://Unit/LoadHandlers/templates.tests.js");
window.eval("(function () {\n    var context;\n    \n    module(\"Unit.LoadStrategies.adhoc\", {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"loader.get is called for each resource\", function () {\n        TC.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.calledThrice);\n        ok(context.loader.get.firstCall.calledWithExactly('new.js', 'new', context));\n        ok(context.loader.get.secondCall.calledWithExactly('new.htm', 'new', context));\n        ok(context.loader.get.thirdCall.calledWithExactly('new.css', 'new', context));\n    });\n\n    test(\"loader.get is called with base path combined with pane path\", function () {\n        context = Test.Unit.context();\n        context.options.basePath = 'panes';\n        TC.LoadStrategies.adhoc({ path: 'test2' }, context);\n        ok(context.loader.get.firstCall.calledWithExactly('panes/test2.js', 'test2', context));\n    });\n\n    test(\"subsequent calls with the same path returns the same deferred object\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function() { return deferred; };\n        var result1 = TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        var result2 = TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        equal(result1, result2);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been resolved\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.resolve();\n        equal(TC.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been rejected\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.reject();\n        equal(TC.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"loader.get is not called when model has been loaded\", function () {\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        ok(context.loader.get.notCalled);\n    });\n\n    test(\"loader.get is not called when template has been loaded\", function () {\n        context.templates.loaded = function() { return true; };\n        TC.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Unit/LoadStrategies/adhoc.tests.js");
window.eval("module('Unit.LoadStrategies.preloaded');\n\ntest(\"returns rejected promise if no resources have been loaded for the specified path\", function() {\n    var context = Test.Unit.context();\n    var promise = TC.LoadStrategies.preloaded({ path: 'test2' }, context);\n    equal(promise.state(), 'rejected');\n});\n//@ sourceURL=tribe://Unit/LoadStrategies/preloaded.tests.js");
window.eval("(function () {\n    var context;\n    var node;\n    \n    module(\"Unit.Events.createModel\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n        }\n    });\n\n    test(\"model is created from stored constructor\", function () {\n        TC.Events.createModel(pane, context);\n        ok(context.models.test.constructor.calledOnce);\n    });\n\n    test(\"default model is created if no constructor defined\", function () {\n        context.models.test.constructor = null;\n        TC.Events.createModel(pane, context);\n        equal(pane.model.pane, pane);\n    });\n})();\n//@ sourceURL=tribe://Unit/Events/createModel.tests.js");
window.eval("(function () {\n    var pane, context;\n    \n    module(\"Unit.Events.renderComplete\", {\n        setup: function() {\n            pane = new TC.Types.Pane({ element: '#qunit-fixture', transition: 'test' });\n            pane.model = { renderComplete: sinon.spy() };\n            context = Test.Unit.context();\n            TC.Transitions.test = { in: sinon.spy() };\n        }\n    });\n\n    test(\"renderComplete calls transition.in with pane element\", function () {\n        TC.Events.renderComplete(pane, context);\n        ok(TC.Transitions.test.in.calledOnce);\n        equal(TC.Transitions.test.in.firstCall.args[0], pane.element);\n    });\n\n    test(\"renderComplete calls renderComplete on pane model\", function () {\n        TC.Events.renderComplete(pane, context);\n        ok(pane.model.renderComplete.calledOnce);\n    });\n\n    test(\"renderComplete resolves is.rendered on pane model\", function () {\n        equal(pane.is.rendered.state(), 'pending');\n        TC.Events.renderComplete(pane, context);\n        equal(pane.is.rendered.state(), 'resolved');\n    });\n\n    test(\"renderComplete raises renderComplete event on document, passing pane as data\", function () {\n        var spy = sinon.spy();\n        window.document.addEventListener(\"renderComplete\", spy);\n        TC.Events.renderComplete(pane, context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0].data, pane);\n        window.document.removeEventListener(\"renderComplete\", spy);\n    });\n})();\n//@ sourceURL=tribe://Unit/Events/renderComplete.tests.js");
window.eval("(function () {\n    var node;\n    var context;\n\n    module(\"Unit.Events.renderPane\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n            context.setTemplate('<div/>');\n        }\n    });\n\n    test(\"templates.render is called with identifier and element\", function () {\n        TC.Events.renderPane(pane, context);\n        ok(context.templates.render.calledOnce);\n        ok(context.templates.render.calledWithExactly(pane.element, 'test'));\n    });\n\n    test(\"paneRendered function is called on the model\", function () {\n        TC.Events.renderPane(pane, context);\n        ok(pane.model.paneRendered.calledOnce);\n    });\n})();\n//@ sourceURL=tribe://Unit/Events/renderPane.tests.js");
window.eval("(function () {\n    var pane, node;\n    \n    module('Unit.transition', {\n        setup: function () {\n            Test.Integration.createTestElement();\n            TC.Transitions.test = { in: sinon.spy(), out: sinon.spy(), reverse: 'test2' };\n            TC.Transitions.test2 = { in: sinon.spy(), out: sinon.spy(), reverse: 'test' };\n            pane = new TC.Types.Pane({ transition: 'test', element: '.test' });\n            node = new TC.Types.Node(null, pane);\n        }\n    });\n\n    test(\"transition executes specified in transition against given element\", function () {\n        TC.transition('.test', 'test').in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"transition executes specified out transition against given element\", function () {\n        TC.transition('.test', 'test').out();\n        equal(TC.Transitions.test.out.firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from node\", function () {\n        TC.transition(node).in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from pane\", function () {\n        TC.transition(pane).in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"specifying transition as argument overrides pane transition\", function() {\n        TC.Transitions.test2 = { in: sinon.spy(), out: sinon.spy() };\n        TC.transition(pane, 'test2').in();\n        ok(TC.Transitions.test.in.notCalled);\n        ok(TC.Transitions.test2.in.calledOnce);\n    });\n\n    test(\"transitioning out removes element by default\", function () {\n        TC.transition('.test').out();\n        equal($('.test').length, 0);\n    });\n\n    test(\"transitioning out hides element if specified\", function () {\n        TC.transition('.test').out(false);\n        equal($('.test').length, 1);\n    });\n\n    test(\"reverse transition is executed when specified\", function() {\n        TC.transition('.test', 'test', true).in();\n        equal(TC.Transitions.test2.in.firstCall.args[0], '.test');\n\n    });\n})();\n\n//@ sourceURL=tribe://Unit/Transitions/transition.tests.js");
window.eval("(function () {\n    module(\"Integration.api\", { teardown: Test.Integration.teardown });\n\n    test(\"arguments can be passed to registerModel in any order\", function () {\n        var path = 'path';\n        var options = {};\n        var constructor = function () { };\n\n        TC.registerModel(path, options, constructor);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n\n        TC.registerModel(options, constructor, path);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n    });\n\n    test(\"registerModel takes path from TC.scriptEnvironment\", function () {\n        var constructor = function () { };\n        TC.scriptEnvironment = { resourcePath: 'test' };\n        TC.registerModel(constructor);\n        equal(Test.Integration.context.models.test.constructor, constructor);\n    });\n})();\n//@ sourceURL=tribe://Integration/api.tests.js");
window.eval("(function() {\n    module('Integration.bindingHandler', {\n        setup: function() {\n            TC.Events.spy = sinon.spy();\n            TC.options.events = ['spy'];\n        }, teardown: Test.Integration.teardown\n    });\n\n    test(\"pane path is set from string binding value\", function() {\n        executeHandler({ value: 'test' });\n        equal(pane().path, '/test');\n    });\n\n    test(\"pane properties are set from object binding value\", function() {\n        executeHandler({ value: { path: 'test', data: 'test2' } });\n        equal(pane().path, '/test');\n        equal(pane().data, 'test2');\n    });\n\n    test(\"pane data is set from other binding value\", function() {\n        executeHandler({ otherValues: { data: 'data' } });\n        equal(pane().data, 'data');\n    });\n\n    test(\"pane element is set from element argument\", function() {\n        executeHandler({ element: '#qunit-fixture' });\n        equal(pane().element, $('#qunit-fixture')[0]);\n    });\n\n    test(\"parent node is extracted from bindingContext\", function () {\n        var parentNode = Test.Unit.node();\n        executeHandler({ bindingContext: { $root: { __node: parentNode } } });\n        equal(pane().node.parent, parentNode);\n    });\n\n    function executeHandler(values) {\n        values = values || {};\n        return ko.bindingHandlers.pane.init(\n            values.element,\n            accessor(values.value || ''),\n            accessor(values.otherValues || {}),\n            values.viewModel,\n            values.bindingContext || {});\n    }\n    \n    function accessor(value) {\n        return function() { return value; };\n    }\n    \n    function pane() {\n        return TC.Events.spy.firstCall.args[0];\n    }\n})();\n//@ sourceURL=tribe://Integration/bindingHandler.tests.js");
window.eval("//(function () {\n//    var history;\n\n//    module('Integration.History', {\n//        setup: function () {\n//            history = new TC.Types.History(window.history);\n//            Test.Integration.createTestElement();\n//        },\n//        teardown: function() {\n//            history.dispose();\n//        }\n//    });\n\n//    test(\"History sets window state when navigating\", function () {\n//        TC.createNode('.test', { path: 'History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        var options = JSON.parse(window.history.state.options);\n//        equal(options.path, '/History/content2');\n//    });\n\n//    // these tests sometimes seem to do strange things to the Chrome debugger. If breakpoints aren't being hit, this is the culprit.\n//    asyncTest(\"History transitions navigation node to previous state when back is called\", function () {\n//        expect(2);\n//        TC.createNode('.test', { path: '/History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function() {\n//            equal($('.content2').length, 0);\n//            equal($('.content1').length, 1);\n//            start();\n//        }, 50);\n//    });\n\n//    asyncTest(\"History transitions navigation node to next state when forward is called\", function () {\n//        expect(2);\n//        TC.createNode('.test', { path: '/History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function () {\n//            window.history.forward();\n//            setTimeout(function () {\n//                equal($('.content2').length, 1);\n//                equal($('.content1').length, 0);\n//                start();\n//            }, 50);\n//        }, 50);\n//    });\n\n//    test(\"document navigating event is raised once\", function () {\n//        expect(2);\n//        $(document).on('navigating', function(e, data) {\n//            equal(data.options.path, '/Navigate/content2');\n//            equal(data.options.data, 'test');\n//        });\n//        TC.createNode('.test', { path: 'Navigate/layout' });\n//        TC.nodeFor('.content1').navigate({ path: 'content2', data: 'test' });\n//        $(document).off('navigating');\n//    });\n//})();\n\n//@ sourceURL=tribe://Integration/History.tests.js");
window.eval("module('Integration.Navigate', {\n    setup: Test.Integration.createTestElement,\n    teardown: Test.Integration.teardown\n});\n\ntest(\"navigating child pane transitions node marked with handlesNavigation\", function () {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    TC.nodeFor('.child1').navigate('content2');\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating root pane transitions node marked with handlesNavigation\", function () {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    TC.nodeFor('.layout').navigate('content2');\n    equal($('.layout').length, 1);\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating back returns to previous pane\", function() {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    var node = TC.nodeFor('.layout');\n    node.navigate('content2');\n    equal($('.content1').length, 0);\n    node.navigateBack();\n    equal($('.content1').length, 1);\n});\n//@ sourceURL=tribe://Integration/Navigate.tests.js");
window.eval("(function () {\n    module('Integration.nodes', { teardown: Test.Integration.teardown });\n\n    test(\"createNode binds pane to target element\", function() {\n        TC.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n    });\n\n    test(\"appendNode appends wrapped pane to target element\", function() {\n        TC.appendNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture div .parent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode called from paneRendered model function renders\", function() {\n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode inherits context from parent element\", function () {\n        TC.Events.spy = sinon.spy();\n        TC.options.events = ['loadResources', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'spy', 'active', 'dispose'];\n        \n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        ok(TC.Events.spy.calledTwice);\n        equal(TC.Events.spy.firstCall.args[1], TC.Events.spy.secondCall.args[1]);\n    });\n\n    test(\"createNode returns populated Node object\", function() {\n        var node = TC.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal(node.pane.path, '/Utilities/parent');\n        equal(node.children.length, 1);\n    });\n\n    asyncTest(\"context.renderOperation resolves when render operation is complete\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('#qunit-fixture', { path: 'Utilities/parent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function() {\n                equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n                start();\n            });\n    });\n\n    asyncTest(\"context.renderOperation includes dynamically added nodes\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function () {\n                equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n                start();\n            });\n    });\n})();\n\n//@ sourceURL=tribe://Integration/nodes.tests.js");
window.eval("module('Integration.Paths', {\n    setup: Test.Integration.createTestElement,\n    teardown: Test.Integration.teardown\n});\n\ntest(\"panes created with skipPath true inherit pane path from their parent\", function() {\n    TC.createNode('.test', { path: 'Paths/Subfolder/parent' });\n    equal($('.parent').length, 1);\n    equal($('.parent').children().length, 1);\n    equal($('.parent .child').length, 1);\n});\n//@ sourceURL=tribe://Integration/Paths.tests.js");
window.eval("module('Integration.PubSub', {\n    setup: function () {\n        Test.Integration.pubsubAsTribe();\n        Test.Integration.createTestElement();\n    }, teardown: Test.Integration.teardown\n});\n\ntest(\"subscription in pane is executed\", function() {\n    TC.createNode('.test', { path: 'PubSub/subscriber' });\n    Test.Integration.context.pubsub.publish('test', 'message');\n    equal($('.subscriber').text(), 'message');\n});\n\ntest(\"subscription is removed when pane is removed from DOM\", function () {\n    TC.createNode('.test', { path: 'PubSub/subscriber' });\n    equal(Test.Integration.context.pubsub.subscribers.get('test').length, 1);\n    $('.test').remove();\n    equal(Test.Integration.context.pubsub.subscribers.get('test').length, 0);\n});\n//@ sourceURL=tribe://Integration/PubSub.tests.js");
window.eval("(function () {\n    module('Integration.Transition', {\n        setup: Test.Integration.createTestElement,\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"transitioning node replaces pane with specified pane\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        TC.transition(TC.nodeFor('.pane1')).to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"transitioning element replaces pane with specified pane\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        TC.transition('.test').to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"specifying reverseTransitionIn pane option applies reverse transition\", function () {        \n        TC.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n        ok($('.pane1').parent().hasClass('slideRight'));\n    });\n\n    test(\"specifying reverse argument applies reverse transition\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n        TC.transition(TC.nodeFor('.pane1'), null, true).to('Transition/pane2');\n        ok($('.pane1').parent().hasClass('slideRight'));\n        ok($('.pane2').parent().hasClass('slideRight'));\n    });\n\n    asyncTest(\"async transition to replaces pane with specified pane\", function () {\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('.test', { path: 'Transition/pane1' }, null, context);\n        $.when(context.renderOperation.promise).done(function() {\n            equal($('.pane1').length, 1);\n            $.when(TC.transition('.test').to('Transition/pane2')).done(function() {\n                equal($('.pane1').length, 0);\n                equal($('.pane2').length, 1);\n                start();\n            });\n        });\n    });\n})();\n\n//@ sourceURL=tribe://Integration/Transition.tests.js");
window.eval("(function () {\n    var root;\n\n    module('Integration.Tree', {\n        setup: function() {\n             Test.Integration.executeDefaultEvents('Tree/1');\n             root = Test.state.pane.node.root;\n        }, teardown: Test.Integration.teardown\n    });\n\n    test(\"tree renders\", function () {\n        equal($('.111').length, 1);\n    });\n\n    test(\"node is created and attached to pane\", function () {\n        ok(Test.state.pane.node);\n        equal(Test.state.pane.path, '/Tree/1');\n    });\n\n    test(\"node is part of full node tree\", function () {\n        equal(root.children.length, 1);\n        equal(root.children[0].children.length, 2);\n        equal(root.children[0].children[1].pane.path, '/Tree/112');\n    });\n\n    test(\"node is removed from tree when pane element is remove from DOM\", function () {\n        equal(root.children[0].children.length, 2);\n        $('.111').parent().remove();\n        equal(root.children[0].children.length, 1);\n    });\n\n    test(\"pane changes when node is transitioned\", function () {\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n\n    test(\"child nodes are removed when transitioned\", function () {\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0].children.length, 0);\n    });\n\n    test(\"node is not replaced when transitioned\", function() {\n        var node = root.children[0];\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0], node);\n    });\n\n    test(\"node is replaced when element is transitioned\", function() {\n        var node = root.children[0];\n        TC.transition($('.11').parent()).to('/Tree/12');\n        equal(root.children.length, 1);\n        notEqual(root.children[0], node);\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n})();\n\n//@ sourceURL=tribe://Integration/Tree.tests.js");
window.eval("(function() {\n    module('Integration.Events.active', {\n        setup: function () { TC.Events.spy = sinon.spy(); },\n        teardown: Test.Integration.teardown\n    });\n\n    var events = Test.Integration.testEventsUntil('active');\n\n    test(\"event ends when pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(TC.Events.spy.notCalled);\n        $('.basic').parent().remove();\n        ok(TC.Events.spy.called);\n        equal(TC.Events.spy.firstCall.args[0].path, '/Events/basic');\n    });\n\n    test(\"child events end when parent pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        ok(TC.Events.spy.notCalled);\n        $('.basicContainer').parent().remove();\n        ok(TC.Events.spy.calledTwice);\n        equal(TC.Events.spy.firstCall.args[0].path, '/Events/basicParent');\n        equal(TC.Events.spy.secondCall.args[0].path, '/Events/basic');\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/active.tests.js");
window.eval("(function() {\n    module('Integration.Events.createModel', {\n        setup: function () { Test.Integration.executeEvents(Test.Integration.testEventsUntil('createModel'), 'Events/basic'); },\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"model is created and attached to pane object\", function () {\n        ok(Test.state.model);\n        ok(Test.state.pane.model);\n        equal(Test.state.model, Test.state.pane.model);\n    });\n\n})();\n//@ sourceURL=tribe://Integration/Events/createModel.tests.js");
window.eval("(function() {\n    module('Integration.Events.dispose', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('dispose');\n\n    test(\"dispose is called once on model when pane element is removed from DOM using jQuery\", function () {\n        Test.Integration.executeEvents(events, 'Events/dispose');\n        ok(!Test.state.disposeCalled);\n        $('.dispose').parent().remove();\n        equal(Test.state.disposeCallCount, 1);\n    });\n\n    // it seems DOMNodeRemoved sometimes fires asynchronously, this should probably be async - this will probably fail on other browsers\n    test(\"dispose is called once on model when pane element is removed from DOM using native functions\", function () {\n        Test.Integration.executeEvents(events, 'Events/dispose');\n        ok(!Test.state.disposeCalled);\n        var element = document.querySelector('.dispose').parentNode;\n        element.parentNode.removeChild(element);\n        equal(Test.state.disposeCallCount, 1);\n    });\n\n    test(\"dispose calls end on pubsub lifetime for each pane\", function () {\n        Test.Integration.pubsubAsMock();\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        $('.basicContainer').parent().remove();\n        ok(Test.Integration.context.pubsub.end.calledTwice);\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/dispose.tests.js");
window.eval("(function() {\n    module('Integration.Events.initialiseModel', { teardown: Test.Integration.teardown });\n\n    test(\"initialise function is called on model\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/basic');\n        equal(Test.state.model.message, 'test message');\n    });\n\n    test(\"returning deferred from initialise makes pipeline wait\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        ok(TC.Events.spy.notCalled);\n        Test.state.deferred.resolve();\n        ok(TC.Events.spy.calledOnce);\n    });\n\n    test(\"rejecting deferred returned from initialise halts pipeline\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        Test.state.deferred.reject();\n        ok(TC.Events.spy.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/initialiseModel.tests.js");
window.eval("(function() {\n    module('Integration.Events.loadResources', {\n        setup: function () { Test.Integration.executeEvents(['loadResources'], 'Events/basic'); },\n        teardown: Test.Integration.teardown\n    });\n\n    test(\"loadResources loads model\", function () {\n        ok(Test.Integration.context.models['/Events/basic']);\n    });\n\n    test(\"loadResources loads template\", function () {\n        equal($('#template--Events-basic').length, 1);\n    });\n\n    test(\"loadResources loads style\", function () {\n        equal($('#style--Events-basic').length, 1);\n    });\n\n})();\n//@ sourceURL=tribe://Integration/Events/loadResources.tests.js");
window.eval("(function() {\n    module('Integration.Events.renderComplete', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('renderComplete');\n\n    test(\"renderComplete is called on model when single pane has rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.renderCompleteCalled);\n    });\n\n    test(\"renderComplete is called on model when all panes in tree have rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/initialiseParent');\n        ok(!Test.state.parentRenderCompleteCalled);\n        Test.state.deferred.resolve();\n        ok(Test.state.parentRenderCompleteCalled);\n    });\n    \n    asyncTest(\"renderComplete is called on single model when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n\n    asyncTest(\"renderComplete is called on all models when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/asyncParent');\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/renderComplete.tests.js");
window.eval("(function() {\n    module('Integration.Events.renderPane', { teardown: Test.Integration.teardown });\n\n    var events = Test.Integration.testEventsUntil('renderPane');\n\n    test(\"pane template is rendered and bound to model\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        equal($('.message').text(), 'test message');\n    });\n\n    test(\"paneRendered is called on model\", function() {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.paneRenderedCalled);\n    });\n\n    test(\"child panes are rendered\", function() {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        equal($('.basic').length, 1);\n    });\n\n    test(\"model is passed data\", function() {\n        Test.Integration.executeEvents(events, 'Events/data', 'test message');\n        equal($('.message').text(), 'test message');\n    });\n\n    asyncTest(\"paneRendered is called on model when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.paneRendered = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n})();\n//@ sourceURL=tribe://Integration/Events/renderPane.tests.js");

        
    module = moduleFunction;
})();(function () {
    var moduleFunction = module;
    module = function(name, lifecycle) {
        return moduleFunction('Tribe.MessageHub.' + name, lifecycle);
    };
    
window.eval("function mockSignalR() {\n    $.connection = {\n        hubImplementation: {\n            client: {},\n            server: {\n                publish: sinon.spy(),\n                joinChannel: sinon.spy(),\n                replayChannel: sinon.spy()\n            },\n            connection: {\n                state: 1,\n                stateChanged: sinon.spy()\n            }\n        },\n        hub: {\n            start: function() {\n                return {\n                    done: function(callback) {\n                        callback();\n                    }\n                };\n            }\n        }\n    };\n    $.signalR = {\n        connectionState: {\n            connected: 1\n        }\n    };\n    $.hubConnection = function (){ return { createHubProxies: function() { } }};\n};\n\nfunction mockPubSub() {\n    return {\n        publish: sinon.spy(),\n        publishSync: sinon.spy(),\n        subscribe: sinon.spy(),\n        createLifetime: function () { return this; }\n    };\n}\n\nfunction mockPublisher() {\n    return { publishToServer: sinon.spy() };\n}\n\n//Tribe = window.Tribe || {};\n//Tribe.PubSub = function() { };\n//Tribe.PubSub.Lifetime = function() { };\n//@ sourceURL=tribe://Resources/helpers.js");
window.eval("(function() {\n    var hub;\n    var pubsub;\n    var publisher;\n\n    var testMessage = { test: 'message' };\n    var stringified = JSON.stringify(testMessage);\n\n    module('Client', {\n        setup: function () {\n            mockSignalR();\n            pubsub = mockPubSub();\n            publisher = mockPublisher();\n            hub = new Tribe.MessageHub.Client(pubsub, $.connection.hubImplementation, publisher);\n        }\n    });\n\n    test(\"acceptServerMessage publishes message to pubsub\", function() {\n        $.connection.hubImplementation.client.acceptServerMessage(stringified);\n        ok(pubsub.publish.calledOnce);\n        ok(pubsub.publish.firstCall.args[0].server);\n        equal(pubsub.publish.firstCall.args[0].test, 'message');\n    });\n\n    test(\"joinChannel subscribes to specified messages\", function () {\n        var options = { serverEvents: ['test', 'test2'] };\n        TMH.initialise(pubsub);\n        TMH.joinChannel('', options);\n        ok(pubsub.subscribe.calledOnce);\n        equal(pubsub.subscribe.firstCall.args[0], options.serverEvents);\n    });\n\n    test(\"joinChannel joins server channel\", function () {\n        TMH.initialise(pubsub);\n        TMH.joinChannel('channel', true);\n        ok($.connection.hubImplementation.server.joinChannel.calledOnce);\n        equal($.connection.hubImplementation.server.joinChannel.args[0], 'channel');\n    });\n\n    test(\"joinChannel replays messages when second argument is true\", function () {\n        TMH.initialise(pubsub);\n        TMH.joinChannel('channel', true);\n        ok($.connection.hubImplementation.server.replayChannel.calledOnce);\n        equal($.connection.hubImplementation.server.replayChannel.args[0], 'channel');\n    });\n\n    test(\"joinChannel replays messages when option passed\", function() {\n        var options = { replay: true };\n        TMH.initialise(pubsub);\n        TMH.joinChannel('channel', options);\n        ok($.connection.hubImplementation.server.replayChannel.calledOnce);\n        equal($.connection.hubImplementation.server.replayChannel.args[0], 'channel');\n    });\n\n    test(\"channel publishes specified messages to server\", function () {\n        var subscriber = getChannelSubscriber();\n        subscriber(null, testMessage);\n        ok(publisher.publishToServer.calledOnce);\n        equal(publisher.publishToServer.firstCall.args[1], testMessage);\n        equal(publisher.publishToServer.firstCall.args[2], undefined);\n    });\n    \n    test(\"channel sets record option on server envelopes if option is set\", function () {\n        var subscriber = getChannelSubscriber(true);\n        subscriber(null, testMessage);\n        ok(publisher.publishToServer.calledOnce);\n        equal(publisher.publishToServer.firstCall.args[2], true);\n    });\n\n    test(\"joinChannel and publishToServer calls are queued until connected\", function () {\n        var deferred = $.Deferred();\n        $.connection.hub.start = function () { return deferred; };\n        TMH.initialise(pubsub);\n        TMH.joinChannel('channel');\n        TMH.publishToServer('channel', {});\n        ok($.connection.hubImplementation.server.joinChannel.notCalled);\n        ok($.connection.hubImplementation.server.publish.notCalled);\n        deferred.resolve();\n        ok($.connection.hubImplementation.server.joinChannel.calledOnce);\n        ok($.connection.hubImplementation.server.publish.calledOnce);\n    });\n\n    function getChannelSubscriber(record) {\n        hub.joinChannel('1', { serverEvents: ['test'], record: record });\n        return pubsub.subscribe.firstCall.args[1];\n    }\n})();\n//@ sourceURL=tribe://Client.tests.js");
window.eval("(function() {\n    var hub;\n    var pubsub;\n    var publisher;\n\n    module('Publisher', {\n        setup: function () {\n            mockSignalR();\n            pubsub = mockPubSub();\n            publisher = new Tribe.MessageHub.Publisher($.connection.hubImplementation);\n        }\n    });\n\n    test(\"message is not published if not connected\", function() {\n        $.connection.hubImplementation.connection.state = 0;\n        publisher.publishToServer('', {});\n        ok($.connection.hubImplementation.server.publish.notCalled);\n    });\n    \n    test(\"queued messages are published when reconnected\", function () {\n        $.connection.hubImplementation.connection.state = 0;\n        publisher.publishToServer('', {});\n        publisher.publishToServer('', {});\n        ok($.connection.hubImplementation.server.publish.notCalled);\n        executeStateChanged(1);\n        ok($.connection.hubImplementation.server.publish.calledTwice);\n    });\n\n    test(\"publishToServer ignores server messages\", function () {\n        publisher.publishToServer('', { server: true });\n        ok($.connection.hubImplementation.server.publish.notCalled);\n    });\n\n\n    function executeStateChanged(newState) {\n        $.connection.hubImplementation.connection.state = newState;\n        var handler = $.connection.hubImplementation.connection.stateChanged.firstCall.args[0];\n        return handler({ newState: newState });\n    }\n})();\n//@ sourceURL=tribe://Publisher.tests.js");

        
    module = moduleFunction;
})();(function () {
    var moduleFunction = module;
    module = function(name, lifecycle) {
        return moduleFunction('Tribe.PubSub.' + name, lifecycle);
    };
    
window.eval("(function () {\n    var pubsub;\n\n    module('exceptions', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    test(\"when handleExceptions is true, publishSync should call all subscribers, even if there are exceptions\", function () {\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", errorFunction);\n        pubsub.subscribe(\"0\", spy);\n\n        pubsub.publishSync(\"0\");\n\n        ok(spy.called);\n    });\n\n    test(\"when handleExceptions is true, exceptionHandler is called when exception occurs in subscriber\", function () {\n        var oldHandler = Tribe.PubSub.options.exceptionHandler;\n        Tribe.PubSub.options.exceptionHandler = sinon.spy();\n\n        pubsub.subscribe(\"0\", errorFunction);\n        pubsub.publishSync(\"0\");\n\n        ok(Tribe.PubSub.options.exceptionHandler.called);\n        Tribe.PubSub.options.exceptionHandler = oldHandler;\n    });\n\n    test(\"when handleExceptions is false, exceptions thrown in subscribers will be unhandled\", function() {\n        Tribe.PubSub.options.handleExceptions = false;\n\n        raises(function() {\n            pubsub.subscribe(\"0\", errorFunction);\n            pubsub.publishSync(\"0\");\n        });\n\n        Tribe.PubSub.options.handleExceptions = true;\n    });\n    \n    function errorFunction() {\n        throw ('some error');\n    }\n})();\n\n//@ sourceURL=tribe://exceptions.tests.js");
window.eval("(function () {\n    var pubsub;\n\n    module('Lifetime', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    test(\"lifetime subscribers are called as normal\", function() {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy1);\n        var lifetime = pubsub.createLifetime();\n        lifetime.subscribe(\"0\", spy2);\n        pubsub.publishSync(\"0\");\n\n        ok(spy1.called);\n        ok(spy2.called);\n    });\n    \n    test(\"lifetime subscribers are not called after end\", function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy1);\n        var lifetime = pubsub.createLifetime();\n        lifetime.subscribe(\"0\", spy2);\n        lifetime.end();\n        pubsub.publishSync(\"0\");\n\n        ok(spy1.called);\n        ok(spy2.notCalled);\n    });\n\n    test(\"lifetime handles hash of subscribers\", function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n\n        var lifetime = pubsub.createLifetime();\n        lifetime.subscribe({ \"0\": spy1, \"1\": spy2 });\n        lifetime.end();\n        pubsub.publishSync(\"0\");\n        pubsub.publishSync(\"1\");\n\n        ok(spy1.notCalled);\n        ok(spy2.notCalled);\n    });\n\n    test(\"messages published through lifetime are published to other subscribers\", function() {\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy);\n        var lifetime = pubsub.createLifetime();\n        lifetime.publishSync(\"0\");\n\n        ok(spy.calledOnce);\n    });\n\n    test(\"nested lifetime subscribers are removed by parent\", function() {\n        var spy = sinon.spy();\n\n        var lifetime1 = pubsub.createLifetime();\n        var lifetime2 = lifetime1.createLifetime();\n        lifetime2.subscribe(\"0\", spy);\n        lifetime1.end();\n        pubsub.publishSync(\"0\");\n\n        ok(spy.notCalled);\n    });\n\n    test(\"parent lifetime subscribers are not removed by nested lifetimes\", function() {\n        var spy = sinon.spy();\n\n        var lifetime1 = pubsub.createLifetime();\n        var lifetime2 = lifetime1.createLifetime();\n        lifetime1.subscribe(\"0\", spy);\n        lifetime2.end();\n        pubsub.publishSync(\"0\");\n\n        ok(spy.calledOnce);\n    });\n\n    test(\"publishing through nested lifetimes triggers subscribers on owner\", function() {\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy);\n        var lifetime1 = pubsub.createLifetime();\n        var lifetime2 = lifetime1.createLifetime();\n        lifetime2.publishSync(\"0\");\n\n        ok(spy.calledOnce);\n    });\n\n    test(\"lifetime.owner returns containing PubSub object\", function() {\n        var lifetime1 = pubsub.createLifetime();\n        var lifetime2 = lifetime1.createLifetime();\n        equal(lifetime1.owner, pubsub);\n        equal(lifetime2.owner, pubsub);\n    });\n})();\n\n//@ sourceURL=tribe://Lifetime.tests.js");
window.eval("(function () {\n    var pubsub;\n\n    module('core.publish', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    test(\"publish should call all subscribers for a message exactly once\", function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy1);\n        pubsub.subscribe(\"0\", spy2);\n\n        pubsub.publishSync(\"0\", \"test\");\n\n        ok(spy1.calledOnce);\n        ok(spy2.calledOnce);\n    });\n\n    test(\"publish should only call subscribers of the published message\", function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy1);\n        pubsub.subscribe(\"1\", spy2);\n\n        pubsub.publishSync(\"0\", \"test\");\n\n        ok(spy1.called);\n        equal(spy2.callCount, 0);\n    });\n\n    test(\"publish should call subscribers with data as first argument\", function () {\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy);\n        pubsub.publishSync(\"0\", \"1\");\n\n        ok(spy.calledWith(\"1\"));\n    });\n\n    test(\"publish should publish asynchronously\", function () {\n        var setTimeout = sinon.stub(window, 'setTimeout');\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy);\n        pubsub.publish(\"0\", \"1\");\n        ok(setTimeout.calledOnce);\n\n        setTimeout.restore();\n    });\n\n    test(\"publishSync should publish synchronously\", function () {\n        var setTimeout = sinon.stub(window, 'setTimeout');\n        var spy = sinon.spy();\n\n        pubsub.subscribe(\"0\", spy);\n        pubsub.publishSync(\"0\", \"1\");\n        ok(setTimeout.notCalled);\n\n        setTimeout.restore();\n    });\n\n    test(\"publish accepts evelope as first parameter\", function () {\n        var spy = sinon.spy();\n\n        pubsub.subscribe('testMessage', spy);\n        pubsub.publish({ topic: 'testMessage', data: 'test', sync: true });\n\n        ok(spy.calledWith('test'));\n    });\n})();\n\n//@ sourceURL=tribe://PubSub.publish.tests.js");
window.eval("(function () {\n    var pubsub;\n\n    module('core.subscribe', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    test(\"subscribe method should return different tokens\", function () {\n        var token1 = pubsub.subscribe(\"0\", function () { });\n        var token2 = pubsub.subscribe(\"1\", function () { });\n        notEqual(token1, token2);\n    });\n\n    test('passing map of handlers to subscribe returns correct number of string tokens', function () {\n        var tokens = pubsub.subscribe({\n            'test': function () { },\n            'test2': function () { }\n        });\n        equal(tokens.length, 2, 'Return type has correct length');\n        ok(tokens[0].constructor === String);\n        ok(tokens[1].constructor === String);\n    });\n\n    test('passing map of handlers to subscribe correctly subscribes messages', function () {\n        var spy1 = sinon.spy(), spy2 = sinon.spy();\n        pubsub.subscribe({\n            'test': spy1,\n            'test2': spy2\n        });\n\n        pubsub.publishSync('test');\n        ok(spy1.called, \"First subscription successful\");\n\n        pubsub.publishSync('test2');\n        ok(spy2.called, \"Second subscription successful\");\n    });\n\n    test('passing array of handlers to subscribe returns correct number of string tokens', function () {\n        var tokens = pubsub.subscribe(['test', 'test2'], function () { });\n        equal(tokens.length, 2, 'Return type has correct length');\n        ok(tokens[0].constructor === String);\n        ok(tokens[1].constructor === String);\n    });\n\n    test('passing array of handlers to subscribe correctly subscribes messages', function () {\n        var spy = sinon.spy();\n        pubsub.subscribe(['test', 'test2'], spy);\n\n        pubsub.publishSync('test');\n        pubsub.publishSync('test2');\n        ok(spy.calledTwice, \"Both subscriptions triggered\");\n    });\n})();\n\n//@ sourceURL=tribe://PubSub.subscribe.tests.js");
window.eval("(function () {\n    var pubsub;\n\n    module('core.unsubscribe', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    test(\"unsubscribe method should return token when successful\", function () {\n        var token = pubsub.subscribe(\"0\");\n        var result = pubsub.unsubscribe(token);\n        equal(result, token);\n    });\n\n    test(\"unsubscribe method should return false when unsuccesful\", function () {\n        var result = pubsub.unsubscribe(\"0\");\n        equal(result, false);\n\n        // now let's try unsubscribing the same method twice\n        var token = pubsub.subscribe(\"0\");\n        pubsub.unsubscribe(token);\n        equal(pubsub.unsubscribe(token), false);\n    });\n\n    test('passing array of tokens to unsubscribe correctly unsubscribes messages', function () {\n        var spy1 = sinon.spy(), spy2 = sinon.spy();\n        var tokens = pubsub.subscribe({\n            'test': spy1,\n            'test2': spy2\n        });\n        pubsub.unsubscribe(tokens);\n\n        pubsub.publishSync('test');\n        ok(!spy1.called, \"First subscription successful\");\n\n        pubsub.publishSync('test2');\n        ok(!spy2.called, \"Second subscription successful\");\n    });\n})();\n\n//@ sourceURL=tribe://PubSub.unsubscribe.tests.js");
window.eval("(function () {\n    var spy;\n    var definition;\n    var pubsub;\n\n    module('Saga', {\n        setup: function () {\n            pubsub = new Tribe.PubSub({ sync: true });\n            definition = createDefinition();\n            spy = sinon.spy();\n        }\n    });\n\n    test(\"constructor arguments are passed to definition constructor\", function () {\n        expect(3);\n        var s = new Tribe.PubSub.Saga(pubsub, constructor, 'arg1', 'arg2');\n        function constructor(saga, arg1, arg2) {\n            equal(saga.pubsub.owner, pubsub);\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n\n    test(\"arguments passed to pubsub.startSaga are passed to definition constructor\", function () {\n        expect(3);\n        var s = pubsub.startSaga(constructor, 'arg1', 'arg2');\n        function constructor(saga, arg1, arg2) {\n            equal(saga.pubsub.owner, pubsub);\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n\n    test(\"handler is executed with correct arguments when topic is published\", function () {\n        definition.handles = { 'testTopic': spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('testTopic', 'data');\n\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'data');\n        equal(spy.firstCall.args[1].data, 'data');\n        equal(spy.firstCall.args[2], saga);\n    });\n\n    test(\"onstart handler is executed when saga is started\", function () {\n        definition.handles = { onstart: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition);\n        ok(spy.notCalled);\n        saga.start();\n        ok(spy.calledOnce);\n    });\n\n    test(\"onstart is called with argument passed to start\", function () {\n        definition.handles = { onstart: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start('arg');\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'arg');\n        equal(spy.firstCall.args[1], saga);\n    });\n\n    test(\"onend handler is executed when saga is ended\", function () {\n        definition.handles = { onend: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        ok(spy.notCalled);\n        saga.end();\n        ok(spy.calledOnce);\n    });\n\n    test(\"onend handler is called wtih argument passed to end\", function () {\n        definition.handles = { onend: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        saga.end('arg');\n        equal(spy.firstCall.args[0], 'arg');\n        equal(spy.firstCall.args[1], saga);\n    });\n\n    test(\"onstart and onend handlers are not executed when topics are published\", function () {\n        definition.handles = { onstart: spy, onend: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('onstart');\n        pubsub.publish('onend');\n        ok(spy.calledOnce);\n    });\n\n    test(\"startChild starts child and adds to children\", function () {\n        var child = createDefinition({ onstart: spy });\n        var saga = new Tribe.PubSub.Saga(pubsub, definition);\n        saga.startChild(child);\n        ok(spy.calledOnce);\n        equal(saga.children.length, 1);\n    });\n\n    test(\"startChild calls onstart with data passed\", function () {\n        var child = createDefinition({ onstart: spy });\n        var saga = new Tribe.PubSub.Saga(pubsub, definition);\n        saga.startChild(child, 'arg');\n        ok(spy.firstCall.args[0], 'arg');\n    });\n\n    test(\"end calls end on any children with data passed\", function () {\n        var child = createDefinition({ onend: spy });\n        var saga = new Tribe.PubSub.Saga(pubsub, definition);\n        saga.startChild(child);\n        saga.end('arg');\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'arg');\n    });\n\n    test(\"Saga ends when null handler is executed\", function () {\n        definition.handles = { 'endTopic': null, onend: spy };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('endTopic');\n        ok(definition.handles.onend.calledOnce);\n    });\n\n    test(\"Child saga is started when child handler is executed\", function () {\n        definition.handles = {\n            'startChild': {\n                'childTopic': spy\n            }\n        };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('childTopic');\n        ok(spy.notCalled);\n        pubsub.publish('startChild');\n        pubsub.publish('childTopic');\n        ok(spy.calledOnce);\n    });\n\n    test(\"Children are ended when parent message is received\", function () {\n        definition.handles = {\n            'startChild': {\n                'childTopic': spy\n            },\n            'parentTopic': function () { }\n        };\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('startChild');\n        pubsub.publish('childTopic');\n        pubsub.publish('parentTopic');\n        pubsub.publish('childTopic');\n        ok(spy.calledOnce);\n    });\n\n    test(\"Children are not ended when parent message is received if endsChildrenExplicitly is set\", function () {\n        definition.handles = {\n            'startChild': {\n                'childTopic': spy\n            },\n            'parentTopic': function () { }\n        };\n        definition.endsChildrenExplicitly = true;\n        var saga = new Tribe.PubSub.Saga(pubsub, definition).start();\n        pubsub.publish('startChild');\n        pubsub.publish('childTopic');\n        pubsub.publish('parentTopic');\n        pubsub.publish('childTopic');\n        ok(spy.calledTwice);\n    });\n\n    function createDefinition(handlers) {\n        return {\n            pubsub: pubsub,\n            handles: handlers\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Saga.tests.js");
window.eval("(function () {\n    var pubsub;\n\n    module('subscribeOnce', {\n        setup: function () { pubsub = new Tribe.PubSub(); }\n    });\n\n    // add some subscribers around the subscribeOnce to ensure it is unsubscribed correctly.\n    test('subscribeOnce publishes message to single subscriber only once', function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n        var spy3 = sinon.spy();\n\n        pubsub.subscribe('test', spy1);\n        pubsub.subscribeOnce('test', spy2);\n        pubsub.subscribe('test', spy3);\n        pubsub.publishSync('test');\n        pubsub.publishSync('test');\n        ok(spy1.calledTwice);\n        ok(spy2.calledOnce);\n        ok(spy3.calledTwice);\n    });\n\n    test(\"subscribeOnce publishes message to map of subscribers only once\", function () {\n        var spy = sinon.spy();\n        pubsub.subscribeOnce({ 'test1': spy, 'test2': spy });\n        pubsub.publishSync('test1');\n        pubsub.publishSync('test1');\n        pubsub.publishSync('test2');\n        ok(spy.calledOnce);\n    });\n\n    test(\"subscribeOnce publishes message to array of subscribers only once\", function () {\n        var spy = sinon.spy();\n        pubsub.subscribeOnce([ 'test1', 'test2'], spy);\n        pubsub.publishSync('test1');\n        pubsub.publishSync('test1');\n        pubsub.publishSync('test2');\n        ok(spy.calledOnce);\n    });\n\n    test(\"subscribeOnce functions correctly in a lifetime\", function () {\n        var spy1 = sinon.spy();\n        var spy2 = sinon.spy();\n        var spy3 = sinon.spy();\n\n        pubsub.subscribe('test', spy1);\n        var lifetime = pubsub.createLifetime();\n        lifetime.subscribeOnce('test', spy2);\n        lifetime.subscribe('test', spy3);\n        \n        pubsub.publishSync('test');\n        pubsub.publishSync('test');\n        lifetime.end();\n        pubsub.publishSync('test');\n        \n        ok(spy1.calledThrice);\n        ok(spy2.calledOnce);\n        ok(spy3.calledTwice);\n    });\n})();\n\n//@ sourceURL=tribe://subscribeOnce.tests.js");
window.eval("(function() {\n    var list;\n\n    module(\"SubscriberList\", {\n        setup: function () { list = new Tribe.PubSub.SubscriberList(); }\n    });\n\n    test(\"add returns consecutive tokens\", function () {\n        equal(list.add(), \"0\");\n        equal(list.add(), \"1\");\n    });\n\n    test(\"remove returns token if removed\", function() {\n        var token = list.add(\"0\");\n        equal(list.remove(token), token);\n    });\n\n    test(\"remove returns false if not removed\", function () {\n        list.add(\"0\");\n        equal(list.remove(\"1\"), false);\n    });\n\n    test(\"get returns subscribers to specific topic\", function() {\n        list.add(\"0\", \"0\");\n        list.add(\"0\", \"1\");\n        list.add(\"2\", \"2\");\n\n        var subscribers = list.get(\"0\");\n        equal(subscribers.length, 2);\n        equal(subscribers[0].handler, \"0\");\n        equal(subscribers[1].handler, \"1\");\n    });\n\n    test(\"get includes global wildcard\", function () {\n        list.add(\"0\", \"0\");\n        list.add(\"*\", \"1\");\n        list.add(\"1\", \"2\");\n\n        var subscribers = list.get(\"0\");\n        equal(subscribers.length, 2);\n        equal(subscribers[0].handler, \"0\");\n        equal(subscribers[1].handler, \"1\");\n    });\n\n    test(\"global wildcard matches all topics\", function() {\n        list.add(\"*\", \"1\");\n        equal(list.get(\"0\").length, 1);\n        equal(list.get(\"00\").length, 1);\n        equal(list.get(\"0.0\").length, 1);\n        equal(list.get(\"0.0.0\").length, 1);\n    });\n\n    test(\"get includes child wildcard\", function () {\n        list.add(\"0.0\", \"0\");\n        list.add(\"0.*\", \"1\");\n        list.add(\"0.1\", \"2\");\n\n        var subscribers = list.get(\"0.0\");\n        equal(subscribers.length, 2);\n        equal(subscribers[0].handler, \"0\");\n        equal(subscribers[1].handler, \"1\");\n    });\n\n    test(\"get includes embedded wildcard\", function () {\n        list.add(\"0.0.0\", \"0\");\n        list.add(\"0.*.0\", \"1\");\n        list.add(\"0.1.0\", \"2\");\n\n        var subscribers = list.get(\"0.0.0\");\n        equal(subscribers.length, 2);\n        equal(subscribers[0].handler, \"0\");\n        equal(subscribers[1].handler, \"1\");\n    });\n\n    test(\"publish matches topics correctly\", function () {\n        list.add(\"test\", {});\n        list.add(\"testtest\", {});\n        list.add(\"1test\", {});\n        list.add(\"test1\", {});\n        list.add(\"1test1\", {});\n\n        equal(list.get(\"test\").length, 1);\n        equal(list.get(\"testtest\").length, 1);\n        equal(list.get(\"1test\").length, 1);\n        equal(list.get(\"test1\").length, 1);\n        equal(list.get(\"1test1\").length, 1);\n    });\n})();\n\n//@ sourceURL=tribe://SubscriberList.tests.js");
window.eval("(function () {\n    module(\"utils\");\n\n    var utils = Tribe.PubSub.utils;\n    // these tests taken from the underscore library. Licensing at http://underscorejs.org.\n\n    test(\"each\", function () {\n        utils.each([1, 2, 3], function (num, i) {\n            equal(num, i + 1, 'each iterators provide value and iteration count');\n        });\n\n        var answers = [];\n        utils.each([1, 2, 3], function (num) { answers.push(num * this.multiplier); }, { multiplier: 5 });\n        equal(answers.join(', '), '5, 10, 15', 'context object property accessed');\n\n        answers = [];\n        var obj = { one: 1, two: 2, three: 3 };\n        obj.constructor.prototype.four = 4;\n        utils.each(obj, function (value, key) { answers.push(key); });\n        equal(answers.join(\", \"), 'one, two, three', 'iterating over objects works, and ignores the object prototype.');\n        delete obj.constructor.prototype.four;\n\n        //var answer = null;\n        //utils.each([1, 2, 3], function (num, index, arr) { if (utils.include(arr, num)) answer = true; });\n        //ok(answer, 'can reference the original collection from inside the iterator');\n\n        answers = 0;\n        utils.each(null, function () { ++answers; });\n        equal(answers, 0, 'handles a null properly');\n    });\n\n    test('map', function () {\n        var doubled = utils.map([1, 2, 3], function (num) { return num * 2; });\n        equal(doubled.join(', '), '2, 4, 6', 'doubled numbers');\n\n        var tripled = utils.map([1, 2, 3], function (num) { return num * this.multiplier; }, { multiplier: 3 });\n        equal(tripled.join(', '), '3, 6, 9', 'tripled numbers with context');\n\n        //if (document.querySelectorAll) {\n        //    var ids = utils.map(document.querySelectorAll('#map-test *'), function (n) { return n.id; });\n        //    deepEqual(ids, ['id1', 'id2'], 'Can use collection methods on NodeLists.');\n        //}\n\n        //var ids = utils.map($('#map-test').children(), function (n) { return n.id; });\n        //deepEqual(ids, ['id1', 'id2'], 'Can use collection methods on jQuery Array-likes.');\n\n        //var ids = utils.map(document.images, function (n) { return n.id; });\n        //ok(ids[0] == 'chart_image', 'can use collection methods on HTMLCollections');\n\n        var ifnull = utils.map(null, function () { });\n        ok(utils.isArray(ifnull) && ifnull.length === 0, 'handles a null properly');\n    });\n\n    test('applyToConstructor', function () {\n        expect(3);\n        deepEqual(\n            utils.applyToConstructor(Date, [2008, 10, 8, 00, 16, 34, 254]),\n            new Date(2008, 10, 8, 00, 16, 34, 254));\n\n        utils.applyToConstructor(constructor, ['arg1', 'arg2']);\n        \n        function constructor(arg1, arg2) {\n            equal(arg1, 'arg1');\n            equal(arg2, 'arg2');\n        }\n    });\n})();\n\n//@ sourceURL=tribe://utils.tests.js");

        
    module = moduleFunction;
})();