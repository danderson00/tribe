window.eval("\nTest = {\n    Unit: {},\n    Integration: {},\n    state: {}\n};\n\nTest.defaultOptions = function() {\n    return {\n        synchronous: true,\n        splitScripts: true,\n        handleExceptions: false,\n        basePath: 'Integration/Panes/',\n        loadStrategy: 'adhoc',\n        events: TC.defaultOptions().events,\n        defaultUrlProvider: TC.options.defaultUrlProvider\n    };\n};\nTC.options = Test.defaultOptions();\n\nsinon.spy(ko, 'applyBindings');\n\nQUnit.testDone(function () {\n    $('.__tribe').remove();\n    Test.state = {};\n    TC.options = Test.defaultOptions();\n    ko.applyBindings.reset();\n    stop();\n    setTimeout(start);\n});\n\nTC.history.dispose();\n//@ sourceURL=tribe://Tests/setup.js\n");
window.eval("\nTC.context = function (state) {\n    Test.Integration.context = $.extend({\n        models: new TC.Types.Models(),\n        loader: new TC.Types.Loader(),\n        options: TC.options,\n        templates: new TC.Types.Templates(),\n        loadedPanes: {},\n        renderOperation: new TC.Types.Operation(),\n        pubsub: Test.Integration.pubsub()\n    }, state);\n    return Test.Integration.context;\n};\n//@ sourceURL=tribe://Tests/Integration/Infrastructure/context.js\n");
window.eval("\n(function () {\n    var helpers = Test.Integration;\n\n    helpers.executeEvents = function (events, pane, data) {\n        TC.options.events = events;\n        TC.options.basePath = 'Integration/Panes';\n        $('#qunit-fixture').append('<div data-bind=\"pane: \\'' + pane + '\\', data: \\'' + data + '\\'\"></div>');\n        ko.applyBindings();\n    };\n\n    helpers.executeDefaultEvents = function (pane) {\n        helpers.executeEvents(TC.defaultOptions().events, pane);\n    };\n\n    helpers.createTestElement = function() {\n        $('#qunit-fixture').append('<div class=\"test\"/>');\n    };\n\n    helpers.testEventsUntil = function(event) {\n        var events = [];\n        var defaultEvents = TC.defaultOptions().events;\n        for (var i = 0; i < defaultEvents.length; i++) {\n            events.push(defaultEvents[i]);\n            if (defaultEvents[i] === event)\n                break;\n        }\n        TC.Events.spy = sinon.spy();\n        events.push('spy');\n        return events;\n    };\n})();\n\n//@ sourceURL=tribe://Tests/Integration/Infrastructure/helpers.js\n");
window.eval("\nTest.Integration.pubsubAsMock = function() {\n    Test.Integration.pubsub = function() {\n        var pubsub = { end: sinon.spy(), createLifetime: function () { return pubsub; } };\n        sinon.spy(pubsub, 'createLifetime');\n        return pubsub;\n    };\n};\n\nTest.Integration.pubsubAsTribe = function () {\n    Test.Integration.pubsub = function () {\n        return new Tribe.PubSub({ sync: true });\n    };\n};\n\nTest.Integration.pubsubAsMock();\n//@ sourceURL=tribe://Tests/Integration/Infrastructure/pubsub.js\n");
window.eval("\nTest.Unit.context = function () {\n    var template = '';\n    var context = {\n        loader: {\n            get: sinon.spy()\n        },\n        models: {\n            test: { constructor: sinon.spy() }\n        },\n        options: {\n            synchronous: true,\n            splitScripts: true,\n            basePath: '',\n            events: ['test']\n        },\n        templates: {\n            template: '',\n            store: sinon.spy(),\n            loaded: sinon.spy(),\n            render: function() {\n                $('#qunit-fixture').append(template);\n            }\n        },\n        setTemplate: function(value) {\n            template = value;\n        },\n        loadedPanes: {},\n        rootNode: null,\n        renderOperation: {\n            promise: $.Deferred(),\n            complete: function () { }\n        }\n    };\n    sinon.spy(context.templates, 'render');\n    return context;\n};\n//@ sourceURL=tribe://Tests/Unit/Infrastructure/context.js\n");
window.eval("\nTest.Unit.node = function () {\n    var pane = Test.pane();\n    return {\n        pane: pane,\n        path: pane.path,\n        children: [],\n        nodeForPath: function() { return this; }\n    };\n};\n//@ sourceURL=tribe://Tests/Unit/Infrastructure/node.js\n");
window.eval("\nTest.pane = function() {\n    return {\n        path: 'test',\n        element: '#qunit-fixture',\n        model: {\n            initialise: sinon.spy(),\n            paneRendered: sinon.spy()\n        },\n        startRender: function () { },\n        endRender: function () { },\n        dispose: function () { }\n    };\n}\n//@ sourceURL=tribe://Tests/Unit/Infrastructure/pane.js\n");
window.eval("\n(function() {\n    module('Unit.Utilities.bindingHandlers');\n\n    test(\"enterPressed executes callback when enter keyup event occurs in specified element, passing element value\", function () {\n        var element = $('<input/>').appendTo('#qunit-fixture');\n        var spy = sinon.spy();\n        ko.bindingHandlers.enterPressed.init(element[0], function () { return spy; });\n    \n        ok(spy.notCalled);\n        element.val('value');\n        element.trigger(keyEvent('keyup', 13));\n        ok(spy.calledOnce);\n        ok(spy.calledWithExactly('value'));\n    });\n    \n    function keyEvent(eventName, which) {\n        var event = jQuery.Event(eventName);\n        event.which = which;\n        return event;\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/bindingHandlers.tests.js\n");
window.eval("\nmodule('Unit.Utilities.collections');\n\ntest(\"each executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.each(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"each executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.each({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map executes iterator for each item of array, passing value and index\", function () {\n    var spy = sinon.spy();\n    T.map(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"map executes iterator for each property of object, passing value and property name\", function () {\n    var spy = sinon.spy();\n    T.map({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"map does not flatten arrays\", function() {\n    var result = T.map([1, 2], function () { return [3, 4]; });\n    equal(result.length, 2);\n    deepEqual(result[0], [3, 4]);\n    deepEqual(result[1], [3, 4]);\n});\n\ntest(\"map returns empty array for undefined input\", function() {\n    var spy = sinon.spy();\n    deepEqual(T.map(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"filter executes once for each item of array\", function() {\n    var spy = sinon.spy();\n    T.filter(['1', '2'], spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 0);\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 1);\n});\n\ntest(\"filter executes once for each property of object\", function () {\n    var spy = sinon.spy();\n    T.filter({ test1: '1', test2: '2' }, spy);\n    ok(spy.calledTwice);\n    equal(spy.firstCall.args[0], '1');\n    equal(spy.firstCall.args[1], 'test1');\n    equal(spy.secondCall.args[0], '2');\n    equal(spy.secondCall.args[1], 'test2');\n});\n\ntest(\"filter returns array of values filtered by iterator function\", function() {\n    var result = T.filter(['1', '2'], function (item) { return item !== '1'; });\n    equal(result.length, 1);\n    equal(result[0], '2');\n});\n\ntest(\"filter returns empty array for undefined input\", function () {\n    var spy = sinon.spy();\n    deepEqual(T.filter(undefined, spy), []);\n    ok(spy.notCalled);\n});\n\ntest(\"pluck returns property value from each object in array\", function() {\n    var result = T.pluck([\n        { one: 'a', two: 'b' },\n        { one: 'c', two: 'd' },\n        { one: 'e', two: 'f' }\n    ], 'one');\n    equal(result.length, 3);\n    equal(result.join(''), 'ace');\n});\n\ntest(\"reduce executes reduceFunction with expected arguments\", function() {\n    var spy = sinon.spy();\n    var list = [1, 2];\n    T.reduce(list, 'initial', spy);\n\n    equal(spy.callCount, 2);\n    deepEqual(spy.firstCall.args, ['initial', 1, 0, list]);\n    deepEqual(spy.secondCall.args, [undefined, 2, 1, list]);\n});\n\ntest(\"reduce returns expected result\", function() {\n    var result = T.reduce([1, 2, 3, 4], 10, function(memo, value) {\n        return memo + value;\n    });\n    equal(result, 20);\n});\n//@ sourceURL=tribe://Tests/Unit/Utilities/collections.tests.js\n");
window.eval("\nmodule('Unit.Utilities.elementDestroyed');\n\ntest(\"promise resolves when element is removed using jQuery\", function () {\n    expect(1);\n    var element = $('<div/>').appendTo('#qunit-fixture');\n    $.when(TC.Utils.elementDestroyed(element)).done(function() {\n        ok(true);\n    });\n    element.remove();\n});\n\nasyncTest(\"promise resolves when element is removed using native functions\", function () {\n    expect(1);\n    var element = $('<div/>').appendTo('#qunit-fixture');\n    $.when(TC.Utils.elementDestroyed(element)).done(function () {\n        ok(true);\n        start();\n    });\n    element[0].parentNode.removeChild(element[0]);\n});\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/elementDestroyed.tests.js\n");
window.eval("\n(function () {\n    module('Unit.Utilities.idGenerator');\n\n    test(\"idGenerator starts at 0 and generates sequential numbers\", function () {\n        var generator = TC.Utils.idGenerator();\n        equal(generator.next(), 0);\n        equal(generator.next(), 1);\n        equal(generator.next(), 2);\n        equal(generator.next(), 3);\n        equal(generator.next(), 4);\n    });\n\n    test(\"getUniqueId is a static generator\", function() {\n        equal(TC.Utils.getUniqueId(), 0);\n        equal(TC.Utils.getUniqueId(), 1);\n        equal(TC.Utils.getUniqueId(), 2);\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/idGenerator.tests.js\n");
window.eval("\n(function () {\n    var deferreds;\n\n    module(\"Unit.Utilities.jquery.complete\", {\n        setup: function() { deferreds = [ $.Deferred(), $.Deferred() ]; }\n    });\n\n    test(\"complete resolves when at least one deferred resolves\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].resolve();\n        equal(result.state(), 'resolved');\n    });\n\n    test(\"complete rejects when all passed deferreds reject\", function () {\n        var result = $.complete(deferreds);\n        equal(result.state(), 'pending');\n        deferreds[0].reject();\n        equal(result.state(), 'pending');\n        deferreds[1].reject();\n        equal(result.state(), 'rejected');\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/jquery.complete.tests.js\n");
window.eval("\n(function() {\n    module('Unit.Utilities.nodes', {\n        setup: function () {\n            TC.Events.spy = sinon.spy();\n            TC.options.events = ['spy'];\n        }\n    });\n\n    test(\"createNode executes events specified in options with new node\", function () {\n        TC.createNode('#qunit-fixture');\n        ok(TC.Events.spy.calledOnce);\n        ok(pane());\n    });\n\n    test(\"appendNode appends wrapper to target element\", function() {\n        TC.appendNode('#qunit-fixture');\n        equal($('#qunit-fixture div').length, 1);\n    });\n\n    function pane() {\n        return TC.Events.spy.firstCall.args[0];\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/nodes.tests.js\n");
window.eval("\n(function() {\n    var utils = TC.Utils;\n    module('Unit.Utilities.objects');\n\n    test(\"arguments.byConstructor\", function() {\n        var argsToPass = [\"\", {}, function() {\n        }, [], 2.2];\n\n        (function() {\n            var args = utils.arguments(arguments);\n            equal(args.string, argsToPass[0]);\n            equal(args.object, argsToPass[1]);\n            equal(args.function, argsToPass[2]);\n            equal(args.array, argsToPass[3]);\n            equal(args.number, argsToPass[4]);\n\n        }).apply(null, argsToPass);\n    });\n\n    test(\"removeItem removes matching item from array\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 2);\n        deepEqual(array, [1, 3]);\n    });\n\n    test(\"removeItem does not affect array if item does not exist\", function() {\n        var array = [1, 2, 3];\n        utils.removeItem(array, 4);\n        deepEqual(array, [1, 2, 3]);\n    });\n\n    test(\"inheritOptions\", function() {\n        var source = { test1: 'test', test2: 2 };\n        equal(TC.Utils.inheritOptions(source, {}, ['test1']).test1, 'test');\n        equal(TC.Utils.inheritOptions(source, {}, ['test2']).test2, 2);\n        equal(TC.Utils.inheritOptions(source, {}, ['test1', 'test2', 'test3']).test3, undefined);\n    });\n\n    test(\"evaluateProperty\", function() {\n        var target = {\n            test1: {\n                test11: 'test',\n                test12: {\n                    test121: 'test'\n                }\n            },\n            test2: 'test'\n        };\n\n        equal(utils.evaluateProperty(target, ''), target);\n        equal(utils.evaluateProperty(target, 'test1'), target.test1);\n        equal(utils.evaluateProperty(target, 'test2'), 'test');\n        equal(utils.evaluateProperty(target, 'test1.test11'), 'test');\n        equal(utils.evaluateProperty(target, 'test1.test12.test121'), 'test');\n        equal(utils.evaluateProperty(target, '.test1'), target.test1);\n        equal(utils.evaluateProperty(target, 'test1.'), target.test1);\n        equal(utils.evaluateProperty(target, 'test1..test11'), 'test');\n\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Utilities/objects.tests.js\n");
window.eval("\n(function () {\n    var utils = TC.Utils;\n    \n    module('Unit.Utilities.panes');\n\n    test(\"getPaneOptions\", function () {\n        deepEqual(utils.getPaneOptions('test'), { path: 'test' }, \"accepts string value as path\");\n        deepEqual(utils.getPaneOptions('test', { data: 'data' }), { path: 'test', data: 'data' }, \"accepts string value as path and merges other options\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }), { path: 'test' }, \"accepts options object\");\n        deepEqual(utils.getPaneOptions({ path: 'test' }, { data: 'data' }), { path: 'test', data: 'data' }, \"accepts options object and merges other options\");\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/panes.tests.js\n");
window.eval("\n(function () {\n    module(\"Unit.Utilities.Path\");\n\n    test('Path handles empty arguments', function () {\n        equal(TC.Path('').toString(), '');\n        equal(TC.Path(undefined).toString(), '');\n        equal(TC.Path(null).toString(), '');\n    });\n\n    test(\"withoutFilename\", function () {\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").withoutFilename().toString(), \"/folder/subfolder/\", \"Path with slashes\");\n    });\n\n    test(\"filename\", function () {\n        equal(TC.Path(\"filename.ext\").filename().toString(), \"filename.ext\", \"Filename\");\n        equal(TC.Path(\"/filename.ext\").filename().toString(), \"filename.ext\", \"Root path filename\");\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").filename().toString(), \"filename.ext\", \"Path with slashes\");\n    });\n\n    test(\"extension\", function () {\n        equal(TC.Path(\"filename.ext\").extension().toString(), \"ext\", \"Filename\");\n        equal(TC.Path(\"/filename.ext\").extension().toString(), \"ext\", \"Root path filename\");\n        equal(TC.Path(\"filename\").extension().toString(), \"\", \"Filename without extension\");\n        equal(TC.Path(\"/filename\").extension().toString(), \"\", \"Root path filename without extension\");\n        equal(TC.Path(\"filename.\").extension().toString(), \"\", \"Empty extension\");\n        equal(TC.Path(\"/folder/subfolder/filename.ext\").extension().toString(), \"ext\", \"Path with slashes\");\n    });\n\n    test(\"withoutExtension\", function () {\n        equal(TC.Path(\"filename.ext\").withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"filename\").withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"/test/filename.ext\").withoutExtension().toString(), \"/test/filename\");\n        equal(TC.Path(\"/test/filename\").withoutExtension().toString(), \"/test/filename\");\n        equal(TC.Path(\"/test/filename.ext\").filename().withoutExtension().toString(), \"filename\");\n        equal(TC.Path(\"/test/filename\").filename().withoutExtension().toString(), \"filename\");\n    });\n\n    test(\"Path objects can be concatenated with strings\", function () {\n        equal(TC.Path('/folder/filename.ext').withoutFilename() + 'new.ext', '/folder/new.ext');\n    });\n\n    test(\"isAbsolute\", function () {\n        ok(TC.Path(\"/test/\").isAbsolute());\n        ok(TC.Path(\"http://test/\").isAbsolute());\n        ok(!TC.Path(\"test/\").isAbsolute());\n        ok(!TC.Path(\"test.txt\").isAbsolute());\n        ok(!TC.Path(\"../test.txt\").isAbsolute());\n    });\n\n    test(\"makeAbsolute\", function () {\n        equal(TC.Path(\"/test\").makeAbsolute().toString(), \"/test\");\n        equal(TC.Path(\"test\").makeAbsolute().toString(), \"/test\");\n        equal(TC.Path(\"test.txt\").makeAbsolute().toString(), \"/test.txt\");\n        equal(TC.Path(\"test/test.txt\").makeAbsolute().toString(), \"/test/test.txt\");\n    });\n\n    test(\"makeRelative\", function () {\n        equal(TC.Path(\"test\").makeRelative().toString(), \"test\");\n        equal(TC.Path(\"/test\").makeRelative().toString(), \"test\");\n        equal(TC.Path(\"/test.txt\").makeRelative().toString(), \"test.txt\");\n        equal(TC.Path(\"/test/test.txt\").makeRelative().toString(), \"test/test.txt\");\n    });\n\n    test(\"normalise\", function () {\n        equal(TC.Path('test').toString(), 'test');\n        equal(TC.Path('../test').toString(), '../test');\n        equal(TC.Path('test1/../test2').toString(), 'test2');\n        equal(TC.Path('/test1/../test2').toString(), '/test2');\n        equal(TC.Path('/test1/../test2/../test3').toString(), '/test3');\n        equal(TC.Path('./test').toString(), 'test');\n        equal(TC.Path('test1/./test2').toString(), 'test1/test2');\n        equal(TC.Path('.././test1/../test2').toString(), '../test2');\n        equal(TC.Path('http://test//test.htm').toString(), 'http://test/test.htm');\n        equal(TC.Path('http://test///test//test.htm').toString(), 'http://test/test/test.htm');\n        equal(TC.Path('1///2//3/4/5').toString(), '1/2/3/4/5');\n    });\n\n    test(\"asPathIdentifier\", function () {\n        equal(TC.Path('test.txt').asMarkupIdentifier().toString(), 'test');\n        equal(TC.Path('test/test.txt').asMarkupIdentifier().toString(), 'test-test');\n    });\n\n    test(\"setExtension\", function() {\n        equal(TC.Path('/test/test').setExtension('js').toString(), '/test/test.js');\n        equal(TC.Path('/test/test.txt').setExtension('js').toString(), '/test/test.js');\n    });\n\n    test(\"combine\", function() {\n        equal(TC.Path('/test/').combine('/test.txt').toString(), '/test/test.txt');\n        equal(TC.Path('http://test/').combine('/test.txt').toString(), 'http://test/test.txt');\n        equal(TC.Path('/1/').combine('/2/').combine('/test.txt').toString(), '/1/2/test.txt');\n        equal(TC.Path('').combine('test.txt').toString(), 'test.txt');\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/Path.tests.js\n");
window.eval("\n(function () {\n    module('Unit.Utilities.querystring');\n    \n    var querystring = TC.Utils.Querystring;\n\n    test(\"stringify handles flat objects\", function() {\n        equal(querystring.stringify({ test: 't', test2: 2 }), 'test=t&test2=2');\n    });\n    \n    test(\"stringify handles nested objects\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: 't' } })), 'test[test2]=t');\n        equal(decodeURI(querystring.stringify({ test: { test2: { test3: 't' } } })), 'test[test2][test3]=t');\n    });\n\n    test(\"stringify handles arrays\", function () {\n        equal(decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } })), 'test[test2][][test3]=t');\n    });\n\n    test(\"stringify handles arrays with arrayKey set to false\", function () {\n        equal(\n            decodeURI(querystring.stringify({ test: { test2: [{ test3: 't' }] } }, { arrayKey: false })),\n            'test[test2][test3]=t');\n    });\n\n    test(\"stringify raises if source contains cyclic references\", function () {\n        raises(function () {\n            var test1 = {};\n            var test2 = { test1: test1 };\n            test1.test2 = test2;\n            querystring.stringify(test1);\n        });\n    });\n\n    test(\"parse handles flat objects\", function () {\n        deepEqual(querystring.parse('test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse strips leading question mark\", function () {\n        deepEqual(querystring.parse('?test=t&test2=2'), { test: 't', test2: 2 });\n    });\n\n    test(\"parse handles nested objects\", function () {\n        deepEqual(querystring.parse('test[test2]=t'), { test: { test2: 't' } });\n        deepEqual(querystring.parse('test[test2][test3]=t'), { test: { test2: { test3: 't' } } });\n    });\n\n    test(\"parse handles arrays\", function () {\n        deepEqual(querystring.parse('test[test2][][test3]=t'), { test: { test2: [{ test3: 't' }] } });\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Utilities/querystring.tests.js\n");
window.eval("\n(function () {\n    var history;\n    var api;\n\n    module('Unit.Types.History', {\n        setup: function () {\n            api = mockHistoryApi();\n            history = new TC.Types.History(api);\n        },\n        teardown: function () {\n            history.dispose();\n        }\n    });\n\n    test(\"browser.go is raised when popstate event is raised normally\", function () {\n        expect(1);\n\n        document.addEventListener('browser.go', assert);\n        raisePopstate();\n        document.removeEventListener('browser.go', assert);\n\n        function assert(e) {\n            equal(e.data.count, 1);\n        }\n    });\n\n    test(\"browser.go is not raised when update is called and popstate is raised\", function () {\n        expect(0);\n        \n        document.addEventListener('browser.go', assert);\n        history.update(1);\n        raisePopstate();\n        document.removeEventListener('browser.go', assert);\n\n        function assert(e) {\n            equal(e.data.count, 1);\n        }\n    });\n\n    test(\"window.history.go is called when go is called\", function () {\n        history.go(1);\n        ok(api.go.calledOnce);\n    });\n\n    test(\"window.history.pushState is called when navigate is called\", function() {\n        history.navigate();\n        ok(api.pushState.calledOnce);\n    });\n\n    test(\"window.history.pushState is called with url and title if urlProvider is passed\", function() {\n        history.navigate({ url: 'url1', title: 'title1' });\n        equal(api.pushState.firstCall.args[1], 'title1');\n        equal(api.pushState.firstCall.args[2], 'url1');\n    });\n\n    function mockHistoryApi() {\n        return {\n            pushState: sinon.spy(),\n            go: sinon.spy(),\n            replaceState: sinon.spy()\n        };\n    }\n\n    function raisePopstate() {\n        var event = document.createEvent(\"Event\");\n        event.initEvent('popstate', true, false);\n        event.state = 1;\n        window.dispatchEvent(event);\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/History.tests.js\n");
window.eval("\n(function() {\n    var resources;\n    var context;\n    \n    module(\"Unit.Types.Loader\", {\n        setup: function () {\n            context = Test.Unit.context();\n            resources = new TC.Types.Loader();\n        }\n    });\n\n    test(\"get should call handler for file extension from passed url\", function () {\n        var spy = sinon.spy();\n        TC.LoadHandlers.test = spy;\n        resources.get('test.test');\n        ok(spy.calledOnce);\n    });\n\n    test(\"get should call handler with url, resourcePath and context\", function () {\n        var spy = sinon.spy();\n        TC.LoadHandlers.test = spy;\n        resources.get('test.test', 'test/test', context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], 'test.test');\n        equal(spy.firstCall.args[1], 'test/test');\n        equal(spy.firstCall.args[2], context);\n    });\n\n    test(\"when passed the same url, get should return the same deferred from first call to handler\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        equal(resources.get('test.test'), deferred);\n    });\n\n    test(\"get should return null after deferred from first call to handler completes\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.resolve();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return null after deferred from first call to handler fails\", function () {\n        var deferred = $.Deferred();\n        TC.LoadHandlers.test = sinon.stub().returns(deferred);\n        equal(resources.get('test.test'), deferred);\n        deferred.reject();\n        equal(resources.get('test.test'), null);\n    });\n\n    test(\"get should return different deferred for each unique url\", function () {\n        TC.LoadHandlers.test = function () { return $.Deferred(); };\n        var result1 = resources.get('test1.test');\n        var result2 = resources.get('test2.test');\n        notEqual(result1, result2);\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Loader.tests.js\n");
window.eval("\n(function() {\n    var logger;\n\n    module(\"Unit.Types.Logger\", {\n        setup: function () {\n            TC.Loggers.test = sinon.spy();\n            logger = new TC.Types.Logger();\n            logger.setLogger('test');\n        }\n    });\n\n    test(\"logger is called with level and message\", function() {\n        logger.warn('test');\n        ok(TC.Loggers.test.calledOnce);\n        ok(TC.Loggers.test.calledWithExactly('warn', 'test'));\n    });\n\n    test(\"default log level logs everything\", function() {\n        logger.debug();\n        logger.info();\n        logger.warn();\n        logger.error();\n        equal(TC.Loggers.test.callCount, 4);\n    });\n\n    test(\"only levels equal or higher than the set value are logged\", function () {\n        logger.setLogLevel('warn');\n        logger.debug();\n        logger.info();\n        ok(TC.Loggers.test.notCalled);\n        logger.warn();\n        logger.error();\n        ok(TC.Loggers.test.calledTwice);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Types/Logger.tests.js\n");
window.eval("\n(function() {\n    var models;\n\n    module('Unit.Types.Models', {\n        setup: function() { models = new TC.Types.Models(); }\n    });\n\n    test(\"register stores model as property with constructor and options\", function () {\n        var constructor = function () { };\n        var options = {};\n        models.register('test', constructor, options);\n        equal(models.test.constructor, constructor);\n        equal(models.test.options, options);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Types/Models.tests.js\n");
window.eval("\n(function () {\n    var nav;\n    var node;\n\n    module('Unit.Types.Navigation', {\n        setup: function () {\n            node = nodeStub('test');\n            nav = new TC.Types.Navigation(node, { transition: 'fade' });\n            TC.history = { navigate: sinon.spy(), update: sinon.spy() };\n        },\n        teardown: function() {\n            nav.dispose();\n        }\n    });\n\n    test(\"forward transitions to specified pane\", function () {\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"forward accepts string transition as options\", function () {\n        nav = new TC.Types.Navigation(node, 'fade');\n        var navigateArgs = { path: 'test2' };\n        nav.navigate(navigateArgs);\n        equal(node.transitionTo.firstCall.args[0], navigateArgs);\n        equal(node.transitionTo.firstCall.args[1], 'fade');\n    });\n\n    test(\"back returns to initial pane with reverse transition\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n        equal(node.transitionTo.secondCall.args[2], true);\n    });\n\n    test(\"back returns to previous pane\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"back does nothing if no stack\", function () {\n        nav.go(-1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"forward does nothing if no stack\", function () {\n        nav.go(1);\n        ok(node.transitionTo.notCalled);\n    });\n\n    test(\"back two returns to initial pane\", function() {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        equal(node.transitionTo.lastCall.args[0].path, 'test');\n    });\n\n    test(\"forward moves stack forward if stack exists\", function () {\n        nav.navigate({ path: 'test2' });\n        nav.navigate({ path: 'test3' });\n        nav.go(-2);\n        nav.go(1);\n        equal(node.transitionTo.lastCall.args[0].path, 'test2');\n    });\n\n    test(\"document navigating event is raised when navigating\", function () {\n        expect(1);\n        document.addEventListener('navigating', assert);\n        nav.navigate({ path: 'test2' });\n        document.removeEventListener('navigating', assert);\n        \n        function assert(e) {\n            equal(e.data.options.path, 'test2');\n        }\n    });\n\n    test(\"TC.history.navigate is called on navigate when browser option is set\", function() {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        ok(TC.history.navigate.calledOnce);\n    });\n\n    test(\"TC.history.update is called on go when browser option is set\", function () {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        nav.go(-1);\n        ok(TC.history.update.calledOnce);\n    });\n\n    test(\"node transitions when browser.go event is received\", function() {\n        nav = new TC.Types.Navigation(node, { browser: true });\n        nav.navigate({ path: 'test2' });\n        TC.Utils.raiseDocumentEvent('browser.go', { count: -1 });\n        equal(node.transitionTo.secondCall.args[0].path, 'test');\n    });\n\n    test(\"initial state is set from urlProvider if paneOptionsFrom returns paneOptions object\", function () {\n        var provider = {\n            paneOptionsFrom: function() {\n                return {\n                    path: 'test',\n                    data: { test: 'test' }\n                };\n            }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0], provider.paneOptionsFrom());\n    });\n\n    test(\"initial state is not set from urlProvider if paneOptionsFrom returns null\", function() {\n        var provider = {\n            paneOptionsFrom: function () { return null; }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        deepEqual(nav.stack[0].path, 'test');\n    });\n\n    test(\"history url and title are set from urlProvider when navigating\", function () {\n        var provider = {\n            paneOptionsFrom: function () { return null; },\n            urlDataFrom: function() {\n                return {\n                    url: 'test',\n                    title: 'test'\n                };\n            }\n        };\n        nav = new TC.Types.Navigation(node, { browser: provider });\n        nav.navigate({ path: 'test2' });\n        deepEqual(TC.history.navigate.firstCall.args[0], provider.urlDataFrom());\n    });\n\n    Test.urlProvider = {\n        urlDataFrom: function() {\n            return {\n                url: 'test',\n                title: 'test'\n            };\n        },\n        paneOptionsFrom: function() {\n            return {\n                path: 'test',\n                data: { test: 'test' }\n            };\n        }\n    };\n\n    function nodeStub(path) {\n        return {\n            id: 1,\n            pane: { path: path },\n            transitionTo: sinon.spy()\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Navigation.tests.js\n");
window.eval("\n(function () {\n    module('Unit.Types.Node');\n\n    test(\"node creates Navigation if handlesNavigation is set on pane\", function() {\n        var node = new TC.Types.Node(null, pane('test', true));\n        ok(node.navigation);\n    });\n\n    test(\"findNavigation returns Navigation for root node if no pane handles navigation\", function() {\n        var leaf = createTree();\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for root node if specified\", function () {\n        var leaf = createTree('root');\n        equal(leaf.findNavigation().node, leaf.root);\n        equal(leaf.parent.findNavigation().node, leaf.root);\n        equal(leaf.root.findNavigation().node, leaf.root);\n    });\n\n    test(\"findNavigation returns Navigation for middle node if specified\", function () {\n        var leaf = createTree('middle');\n        equal(leaf.findNavigation().node, leaf.parent);\n        equal(leaf.parent.findNavigation().node, leaf.parent);\n        equal(leaf.root.findNavigation().node, leaf.parent);\n    });\n\n    test(\"findNavigation returns Navigation for leaf node if specified\", function () {\n        var leaf = createTree('leaf');\n        equal(leaf.findNavigation().node, leaf);\n        equal(leaf.parent.findNavigation().node, leaf);\n        equal(leaf.root.findNavigation().node, leaf);\n    });\n\n    test(\"findNavigation returns Navigation for root node if handling node disposed\", function () {\n        var leaf = createTree('leaf');\n        var middle = leaf.parent;\n        leaf.dispose();\n        equal(middle.findNavigation().node, middle.root);\n        equal(leaf.parent.findNavigation().node, middle.root);\n    });\n    \n    function pane(path, handlesNavigation) {\n        return new TC.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    function createTree(navigationNode) {\n        var root = new TC.Types.Node(null, pane('root', navigationNode === 'root'));\n        var middle = new TC.Types.Node(root, pane('middle', navigationNode === 'middle'));\n        var leaf = new TC.Types.Node(middle, pane('leaf', navigationNode === 'leaf'));\n        return leaf;\n    }\n})();\n//@ sourceURL=tribe://Tests/Unit/Types/Node.findNavigation.tests.js\n");
window.eval("\n(function () {\n    module('Unit.Types.Node');\n\n    function pane(path, handlesNavigation) {\n        return new TC.Types.Pane({ path: path, handlesNavigation: handlesNavigation });\n    }\n\n    test(\"setPane makes path absolute and sets pane path from pane if no parent\", function() {\n        var node = new TC.Types.Node(null, pane('test'));\n        equal(node.pane.path, '/test');\n    });\n\n    test(\"setPane sets pane path from parent and relative pane path\", function () {\n        var parent = new TC.Types.Node(null, pane('/path/parent'));\n        var node = new TC.Types.Node(parent, pane('child'));\n        equal(node.pane.path, '/path/child');\n    });\n\n    test(\"setPane sets pane path from pane if path is absolute\", function () {\n        var parent = new TC.Types.Node(null, pane('/path/parent'));\n        var node = new TC.Types.Node(parent, pane('/root'));\n        equal(node.pane.path, '/root');\n    });\n\n    test(\"setPane unsets node on existing pane\", function () {\n        var existingPane = pane('test');\n        var node = new TC.Types.Node(null, existingPane);\n        node.setPane(new TC.Types.Pane(pane('test2')));\n        equal(existingPane.node, null);\n    });\n\n    test(\"setPane sets node.navigation when pane.handlesNavigation\", function() {\n        var node = new TC.Types.Node();\n        node.setPane(pane('', 'test'));\n        ok(node.navigation.constructor, TC.Types.Navigation);\n    });\n\n    test(\"node root is set correctly\", function() {\n        var one = new TC.Types.Node(null, pane('one'));\n        var two = new TC.Types.Node(one, pane('two'));\n        var three = new TC.Types.Node(two, pane('three'));\n\n        equal(one.root, one);\n        equal(two.root, one);\n        equal(three.root, one);\n    });\n\n    test(\"dispose removes node from parent collection\", function() {\n        var parent = new TC.Types.Node(null, pane('parent'));\n        var child = new TC.Types.Node(parent, pane('child'));\n        equal(parent.children.length, 1);\n        child.dispose();\n        equal(parent.children.length, 0);\n    });\n\n    test(\"navigate inherits path from existing pane\", function () {\n        var node = new TC.Types.Node(null, pane('/path/node1'));\n        node.transitionTo = sinon.spy();\n        node.navigate('node2');\n        ok(node.transitionTo.calledOnce);\n        equal(node.transitionTo.firstCall.args[0].path, '/path/node2');\n    });\n\n    test(\"nodeForPath returns current node if skipPath is not specified\", function() {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        equal(node2.nodeForPath(), node2);\n    });\n\n    test(\"nodeForPath returns parent if skipPath is specified\", function() {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        node2.skipPath = true;\n        equal(node2.nodeForPath(), node1);\n    });\n\n    test(\"nodeForPath recurses, skipping nodes as specified\", function () {\n        var node1 = new TC.Types.Node(null, pane('/path1/node1'));\n        var node2 = new TC.Types.Node(node1, pane('/path2/node2'));\n        var node3 = new TC.Types.Node(node2, pane('/path2/node2'));\n        node2.skipPath = true;\n        node3.skipPath = true;\n        equal(node3.nodeForPath(), node1);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Types/Node.tests.js\n");
window.eval("\n(function () {\n    var operation;\n    \n    module(\"Unit.Types.Operation\", {\n        setup: function() { operation = new TC.Types.Operation(); }\n    });\n\n    test(\"operation resolves when single child completes\", function () {\n        operation.add(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(1);\n        equal(operation.promise.state(), 'resolved');\n    });\n\n    test(\"operation resolves when two children complete\", function() {\n        operation.add(1);\n        operation.add(2);\n        operation.complete(1);\n        equal(operation.promise.state(), 'pending');\n        operation.complete(2);\n        equal(operation.promise.state(), 'resolved');\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Operation.tests.js\n");
window.eval("\n(function() {\n    module('Unit.Types.Pane');\n\n    test(\"inheritPathFrom inherits path if pane path is relative\", function () {\n        var pane = new TC.Types.Pane({ path: 'pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/pane2');\n    });\n\n    test(\"inheritPathFrom doesn't inherit path if pane path is absolute\", function () {\n        var pane = new TC.Types.Pane({ path: '/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/pane2');\n    });\n\n    test(\"inheritPathFrom sets child folders from relative pane path\", function () {\n        var pane = new TC.Types.Pane({ path: 'Test2/pane2' });\n        pane.inheritPathFrom(wrap({ path: '/Test/pane1' }));\n        equal(pane.path, '/Test/Test2/pane2');\n    });\n    \n    function wrap(pane) {\n        return {\n            nodeForPath: function() {\n                return { pane: pane };\n            }\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Pane.tests.js\n");
window.eval("\n(function () {\n    var events;\n    var pipeline;\n    var eventDeferred;\n    var context = {};\n\n    module(\"Unit.Types.Pipeline\", {\n        setup: function() {\n            events = testEvents();\n            pipeline = new TC.Types.Pipeline(events, context);\n        }\n    });\n\n    test(\"event handlers specified are called\", function () {\n        pipeline.execute(['null1']);\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"event handlers are passed target and context\", function () {\n        var target = {};\n        pipeline.execute(['null1'], target);\n        ok(events.null1.calledWithExactly(target, context));\n    });\n\n    test(\"events returning null are executed synchronously\", function () {\n        pipeline.execute(['null1', 'null2']);\n        ok(events.null1.calledOnce);\n        ok(events.null2.calledOnce);\n    });\n\n    test(\"events are executed when previous event resolves\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        ok(events.null1.notCalled);\n        eventDeferred.resolve();\n        ok(events.null1.calledOnce);\n    });\n\n    test(\"rejected events terminate pipeline execution\", function() {\n        pipeline.execute(['deferred', 'null1']);\n        eventDeferred.reject();\n        ok(events.null1.notCalled);\n    });\n\n    test(\"execute returns deferred that resolves on completion\", function() {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.resolve();\n        equal(deferred.state(), 'resolved');\n    });\n    \n    test(\"execute returns deferred that rejects on failure\", function () {\n        var deferred = pipeline.execute(['deferred']);\n        equal(deferred.state(), 'pending');\n        eventDeferred.reject();\n        equal(deferred.state(), 'rejected');\n    });\n\n    function testEvents() {\n        eventDeferred = $.Deferred();\n        \n        return {\n            null1: sinon.spy(),\n            null2: sinon.spy(),\n            deferred: sinon.stub().returns(eventDeferred),\n        };\n    }\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Pipeline.tests.js\n");
window.eval("\n(function () {\n    var pane;\n    var pubsub;\n    var spy;\n    \n    module('Unit.Types.Saga', {\n        setup: function() {\n            pubsub = new Tribe.PubSub({ sync: true });\n            pane = { pubsub: pubsub };\n            spy = sinon.spy();\n        }\n    });\n\n    test(\"handler is executed with correct arguments when topic is published\", function () {\n        var saga = new TC.Types.Saga(pane, { 'testTopic': spy }).start();\n        pubsub.publish('testTopic', 'data');\n\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], saga);\n        equal(spy.firstCall.args[1], 'data');\n        equal(spy.firstCall.args[2].data, 'data');\n    });\n\n    test(\"onstart handler is executed when saga is started\", function() {\n        var saga = new TC.Types.Saga(pane, { onstart: spy }, 'test');\n        ok(spy.notCalled);\n        saga.start();\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], saga);\n        equal(spy.firstCall.args[1], 'test');\n    });\n\n    test(\"onend handler is executed when saga is started\", function () {\n        var saga = new TC.Types.Saga(pane, { onend: spy }).start();\n        ok(spy.notCalled);\n        saga.end();\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0], saga);\n    });\n\n    test(\"onstart and onend handlers are not executed when topics is published\", function () {\n        var saga = new TC.Types.Saga(pane, { onstart: spy, onend: spy }).start();\n        pubsub.publish('onstart');\n        pubsub.publish('onend');\n        ok(spy.calledOnce);\n    });\n\n    test(\"startChild starts child and adds to children\", function () {\n        var child = { onstart: sinon.spy() };\n        var saga = new TC.Types.Saga(pane);\n        saga.startChild(child);\n        ok(child.onstart.calledOnce);\n        equal(saga.children.length, 1);\n    });\n    \n    test(\"end calls end on any children\", function () {\n        var child = { onend: sinon.spy() };\n        var saga = new TC.Types.Saga(pane);\n        saga.startChild(child);\n        saga.end();\n        ok(child.onend.calledOnce);\n    });\n\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Types/Saga.tests.js\n");
window.eval("\n(function () {\n    var templates;\n    \n    module('Unit.Types.Templates', {\n        setup: function () { templates = new TC.Types.Templates(); },\n        teardown: function () { $('head script[type=\"text/template\"]').remove(); }\n    });\n\n    test(\"store wraps template in script tag with resource path as id\", function() {\n        templates.store('<br/>', 'test');\n        equal($('head script#template-test').text(), '<br/>');\n    });\n\n    test(\"store appends multiple wrapped templates\", function () {\n        templates.store('<script type=\"text/template\" id=\"test1\">test1</script><script type=\"text/template\" id=\"test2\">test2</script>');\n        equal($('head script#test1').text(), 'test1');\n        equal($('head script#test2').text(), 'test2');\n    });\n\n    test(\"store ignores unwrapped templates\", function () {\n        templates.store('<script type=\"text/template\" id=\"test1\">test1</script>blah<br/><script type=\"text/template\" id=\"test2\">test2</script>');\n        equal($('head script#test1').text(), 'test1');\n        equal($('head script#test2').text(), 'test2');\n    });\n\n    test(\"render replaces content of target with stored template\", function () {\n        $('#qunit-fixture').text('previous');\n        templates.store('content', 'test');\n        templates.render('#qunit-fixture', 'test');\n        equal($('#qunit-fixture').text(), 'content');\n    });\n    \n    test(\"loaded returns true if template has been loaded for specified path\", function () {\n        templates.store('<br/>', 'test');\n        ok(templates.loaded('test'));\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Types/Templates.tests.js\n");
window.eval("\n(function() {\n    var originalEval = $.globalEval;\n    var url = 'test.js';\n    var resourcePath = '/test';\n    var response = \"\";\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n    \n    module(\"Unit.LoadHandlers.scripts\", {\n        setup: function() {\n            context = Test.Unit.context();\n        },\n        teardown: function () { $.globalEval = originalEval; }\n    });\n\n    test(\"script handler returns promise object\", function() {\n        ok(TC.LoadHandlers.js(url, resourcePath, context).promise);\n    });\n\n    test(\"script handler executes globalEval with response\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(0, response.length), response);\n    });\n\n    test(\"script handler appends sourceURL tag\", function () {\n        $.globalEval = sinon.spy();\n        response = \"test\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n        ok($.globalEval.calledOnce);\n        equal($.globalEval.firstCall.args[0].substring(response.length + 1), \"//@ sourceURL=test.js\");\n    });\n\n    test(\"script handler splits scripts on sourceURL tag if option is set\", function() {\n        $.globalEval = sinon.spy();\n        response = \"test\\n//@ sourceURL=test.js\\ntest2\\n//@ sourceURL=test2.js\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n\n        ok($.globalEval.calledTwice);\n        equal($.globalEval.firstCall.args[0].substring(0, 4), \"test\");\n        equal($.globalEval.secondCall.args[0].substring(1, 6), \"test2\"); // leading /n - should fix\n    });\n\n    test(\"script handler sets TC.scriptEnvironment before executing scripts\", function () {\n        expect(1);\n        response = \"equal(TC.scriptEnvironment.resourcePath, '\" + resourcePath + \"');\";\n        TC.LoadHandlers.js(url, resourcePath, context);\n    });\n\n    test(\"script handler clears TC.scriptEnvironment after executing scripts\", function () {\n        TC.LoadHandlers.js(url, resourcePath, context);\n        equal(TC.scriptEnvironment, undefined);\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/LoadHandlers/scripts.tests.js\n");
window.eval("\n(function() {\n    var url = 'test.css';\n    var resourcePath = '/test';\n    var response = \"\";\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.stylesheets');\n    \n    test(\"stylesheet handler returns promise object\", function() {\n        ok(TC.LoadHandlers.css(url, resourcePath, Test.Unit.context()).promise);\n    });\n\n    test(\"stylesheet handler adds stylesheet to page header\", function () {\n        response = \"body{}\";\n        TC.LoadHandlers.css(url, resourcePath, Test.Unit.context());\n        equal($('head style').last().text(), response);\n    });\n\n    test(\"stylesheet is added with id of resource\", function () {\n        response = \"body{}\";\n        TC.LoadHandlers.css(url, resourcePath, Test.Unit.context());\n        equal($('head style#style--test').last().text(), response);\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/LoadHandlers/stylesheets.tests.js\n");
window.eval("\n(function() {\n    var url = 'test.htm';\n    var resourcePath = '/test';\n    var response = '<br/>';\n    var context;\n    \n    $.mockjax({\n        url: url,\n        response: function() { this.responseText = response; }\n    });\n\n    module('Unit.LoadHandlers.templates', {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"template handler returns promise object\", function() {\n        ok(TC.LoadHandlers.htm(url, resourcePath, context).promise);\n    });\n\n    test(\"template is stored with resource path identifier\", function() {\n        TC.LoadHandlers.htm(url, resourcePath, context);\n        ok(context.templates.store.calledOnce);\n        ok(context.templates.store.calledWithExactly('<br/>', '/test'));\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/LoadHandlers/templates.tests.js\n");
window.eval("\n(function () {\n    var context;\n    \n    module(\"Unit.LoadStrategies.adhoc\", {\n        setup: function () { context = Test.Unit.context(); }\n    });\n\n    test(\"loader.get is called for each resource\", function () {\n        TC.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.calledThrice);\n        ok(context.loader.get.firstCall.calledWithExactly('new.js', 'new', context));\n        ok(context.loader.get.secondCall.calledWithExactly('new.htm', 'new', context));\n        ok(context.loader.get.thirdCall.calledWithExactly('new.css', 'new', context));\n    });\n\n    test(\"loader.get is called with base path combined with pane path\", function () {\n        context = Test.Unit.context();\n        context.options.basePath = 'panes';\n        TC.LoadStrategies.adhoc({ path: 'test2' }, context);\n        ok(context.loader.get.firstCall.calledWithExactly('panes/test2.js', 'test2', context));\n    });\n\n    test(\"subsequent calls with the same path returns the same deferred object\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function() { return deferred; };\n        var result1 = TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        var result2 = TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        equal(result1, result2);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been resolved\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.resolve();\n        equal(TC.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"subsequent calls with the same path returns null after the deferred has been rejected\", function () {\n        var deferred = $.Deferred();\n        context.loader.get = function () { return deferred; };\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        deferred.reject();\n        equal(TC.LoadStrategies.adhoc({ path: 'test' }, context), null);\n    });\n\n    test(\"loader.get is not called when model has been loaded\", function () {\n        TC.LoadStrategies.adhoc({ path: 'test' }, context);\n        ok(context.loader.get.notCalled);\n    });\n\n    test(\"loader.get is not called when template has been loaded\", function () {\n        context.templates.loaded = function() { return true; };\n        TC.LoadStrategies.adhoc({ path: 'new' }, context);\n        ok(context.loader.get.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/LoadStrategies/adhoc.tests.js\n");
window.eval("\nmodule('Unit.LoadStrategies.preloaded');\n\ntest(\"returns rejected promise if no resources have been loaded for the specified path\", function() {\n    var context = Test.Unit.context();\n    var promise = TC.LoadStrategies.preloaded({ path: 'test2' }, context);\n    equal(promise.state(), 'rejected');\n});\n//@ sourceURL=tribe://Tests/Unit/LoadStrategies/preloaded.tests.js\n");
window.eval("\n(function () {\n    var context;\n    var node;\n    \n    module(\"Unit.Events.createModel\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n        }\n    });\n\n    test(\"model is created from stored constructor\", function () {\n        TC.Events.createModel(pane, context);\n        ok(context.models.test.constructor.calledOnce);\n    });\n\n    test(\"default model is created if no constructor defined\", function () {\n        context.models.test.constructor = null;\n        TC.Events.createModel(pane, context);\n        equal(pane.model.pane, pane);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Events/createModel.tests.js\n");
window.eval("\n(function () {\n    var pane, context;\n    \n    module(\"Unit.Events.renderComplete\", {\n        setup: function() {\n            pane = new TC.Types.Pane({ element: '#qunit-fixture', transition: 'test' });\n            pane.model = { renderComplete: sinon.spy() };\n            context = Test.Unit.context();\n            TC.Transitions.test = { in: sinon.spy() };\n        }\n    });\n\n    test(\"renderComplete calls transition.in with pane element\", function () {\n        TC.Events.renderComplete(pane, context);\n        ok(TC.Transitions.test.in.calledOnce);\n        equal(TC.Transitions.test.in.firstCall.args[0], pane.element);\n    });\n\n    test(\"renderComplete calls renderComplete on pane model\", function () {\n        TC.Events.renderComplete(pane, context);\n        ok(pane.model.renderComplete.calledOnce);\n    });\n\n    test(\"renderComplete resolves is.rendered on pane model\", function () {\n        equal(pane.is.rendered.state(), 'pending');\n        TC.Events.renderComplete(pane, context);\n        equal(pane.is.rendered.state(), 'resolved');\n    });\n\n    test(\"renderComplete raises renderComplete event on document, passing pane as data\", function () {\n        var spy = sinon.spy();\n        window.document.addEventListener(\"renderComplete\", spy);\n        TC.Events.renderComplete(pane, context);\n        ok(spy.calledOnce);\n        equal(spy.firstCall.args[0].data, pane);\n        window.document.removeEventListener(\"renderComplete\", spy);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Events/renderComplete.tests.js\n");
window.eval("\n(function () {\n    var node;\n    var context;\n\n    module(\"Unit.Events.renderPane\", {\n        setup: function () {\n            context = Test.Unit.context();\n            pane = Test.Unit.node().pane;\n            context.setTemplate('<div/>');\n        }\n    });\n\n    test(\"templates.render is called with identifier and element\", function () {\n        TC.Events.renderPane(pane, context);\n        ok(context.templates.render.calledOnce);\n        ok(context.templates.render.calledWithExactly(pane.element, 'test'));\n    });\n\n    test(\"bindings are applied to child elements of pane element\", function () {\n        TC.Events.renderPane(pane, context);\n        ok(ko.applyBindings.calledOnce);\n        ok(ko.applyBindings.calledWithExactly(pane.model, $('#qunit-fixture').children()[0]));\n    });\n\n    test(\"paneRendered function is called on the model\", function () {\n        TC.Events.renderPane(pane, context);\n        ok(pane.model.paneRendered.calledOnce);\n    });\n})();\n//@ sourceURL=tribe://Tests/Unit/Events/renderPane.tests.js\n");
window.eval("\n(function () {\n    var pane, node;\n    \n    module('Unit.transition', {\n        setup: function () {\n            Test.Integration.createTestElement();\n            TC.Transitions.test = { in: sinon.spy(), out: sinon.spy(), reverse: 'test2' };\n            TC.Transitions.test2 = { in: sinon.spy(), out: sinon.spy(), reverse: 'test' };\n            pane = new TC.Types.Pane({ transition: 'test', element: '.test' });\n            node = new TC.Types.Node(null, pane);\n        }\n    });\n\n    test(\"transition executes specified in transition against given element\", function () {\n        TC.transition('.test', 'test').in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"transition executes specified out transition against given element\", function () {\n        TC.transition('.test', 'test').out();\n        equal(TC.Transitions.test.out.firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from node\", function () {\n        TC.transition(node).in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"transition gets target element and transition from pane\", function () {\n        TC.transition(pane).in();\n        equal(TC.Transitions.test.in.firstCall.args[0], '.test');\n    });\n\n    test(\"specifying transition as argument overrides pane transition\", function() {\n        TC.Transitions.test2 = { in: sinon.spy(), out: sinon.spy() };\n        TC.transition(pane, 'test2').in();\n        ok(TC.Transitions.test.in.notCalled);\n        ok(TC.Transitions.test2.in.calledOnce);\n    });\n\n    test(\"transitioning out removes element by default\", function () {\n        TC.transition('.test').out();\n        equal($('.test').length, 0);\n    });\n\n    test(\"transitioning out hides element if specified\", function () {\n        TC.transition('.test').out(false);\n        equal($('.test').length, 1);\n    });\n\n    test(\"reverse transition is executed when specified\", function() {\n        TC.transition('.test', 'test', true).in();\n        equal(TC.Transitions.test2.in.firstCall.args[0], '.test');\n\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Unit/Transitions/transition.tests.js\n");
window.eval("\n(function () {\n    module(\"Integration.api\");\n\n    test(\"arguments can be passed to registerModel in any order\", function () {\n        var path = 'path';\n        var options = {};\n        var constructor = function () { };\n\n        TC.registerModel(path, options, constructor);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n\n        TC.registerModel(options, constructor, path);\n        equal(Test.Integration.context.models.path.options, options);\n        equal(Test.Integration.context.models.path.constructor, constructor);\n    });\n\n    test(\"registerModel takes path from TC.scriptEnvironment\", function () {\n        var constructor = function () { };\n        TC.scriptEnvironment = { resourcePath: 'test' };\n        TC.registerModel(constructor);\n        equal(Test.Integration.context.models.test.constructor, constructor);\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/api.tests.js\n");
window.eval("\n(function() {\n    module('Integration.bindingHandler', {\n        setup: function() {\n            TC.Events.spy = sinon.spy();\n            TC.options.events = ['spy'];\n        }\n    });\n\n    test(\"pane path is set from string binding value\", function() {\n        executeHandler({ value: 'test' });\n        equal(pane().path, '/test');\n    });\n\n    test(\"pane properties are set from object binding value\", function() {\n        executeHandler({ value: { path: 'test', data: 'test2' } });\n        equal(pane().path, '/test');\n        equal(pane().data, 'test2');\n    });\n\n    test(\"pane data is set from other binding value\", function() {\n        executeHandler({ otherValues: { data: 'data' } });\n        equal(pane().data, 'data');\n    });\n\n    test(\"pane element is set from element argument\", function() {\n        executeHandler({ element: '#qunit-fixture' });\n        equal(pane().element, $('#qunit-fixture')[0]);\n    });\n\n    test(\"parent node is extracted from bindingContext\", function () {\n        var parentNode = Test.Unit.node();\n        executeHandler({ bindingContext: { $root: { __node: parentNode } } });\n        equal(pane().node.parent, parentNode);\n    });\n\n    function executeHandler(values) {\n        values = values || {};\n        return ko.bindingHandlers.pane.init(\n            values.element,\n            accessor(values.value || ''),\n            accessor(values.otherValues || {}),\n            values.viewModel,\n            values.bindingContext || {});\n    }\n    \n    function accessor(value) {\n        return function() { return value; };\n    }\n    \n    function pane() {\n        return TC.Events.spy.firstCall.args[0];\n    }\n})();\n//@ sourceURL=tribe://Tests/Integration/bindingHandler.tests.js\n");
window.eval("\n//(function () {\n//    var history;\n\n//    module('Integration.History', {\n//        setup: function () {\n//            history = new TC.Types.History(window.history);\n//            Test.Integration.createTestElement();\n//        },\n//        teardown: function() {\n//            history.dispose();\n//        }\n//    });\n\n//    test(\"History sets window state when navigating\", function () {\n//        TC.createNode('.test', { path: 'History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        var options = JSON.parse(window.history.state.options);\n//        equal(options.path, '/History/content2');\n//    });\n\n//    // these tests sometimes seem to do strange things to the Chrome debugger. If breakpoints aren't being hit, this is the culprit.\n//    asyncTest(\"History transitions navigation node to previous state when back is called\", function () {\n//        expect(2);\n//        TC.createNode('.test', { path: '/History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function() {\n//            equal($('.content2').length, 0);\n//            equal($('.content1').length, 1);\n//            start();\n//        }, 50);\n//    });\n\n//    asyncTest(\"History transitions navigation node to next state when forward is called\", function () {\n//        expect(2);\n//        TC.createNode('.test', { path: '/History/layout' });\n//        TC.nodeFor('.content1').navigate('content2');\n//        window.history.back();\n//        setTimeout(function () {\n//            window.history.forward();\n//            setTimeout(function () {\n//                equal($('.content2').length, 1);\n//                equal($('.content1').length, 0);\n//                start();\n//            }, 50);\n//        }, 50);\n//    });\n\n//    test(\"document navigating event is raised once\", function () {\n//        expect(2);\n//        $(document).on('navigating', function(e, data) {\n//            equal(data.options.path, '/Navigate/content2');\n//            equal(data.options.data, 'test');\n//        });\n//        TC.createNode('.test', { path: 'Navigate/layout' });\n//        TC.nodeFor('.content1').navigate({ path: 'content2', data: 'test' });\n//        $(document).off('navigating');\n//    });\n//})();\n\n//@ sourceURL=tribe://Tests/Integration/History.tests.js\n");
window.eval("\nmodule('Integration.Navigate', {\n    setup: Test.Integration.createTestElement\n});\n\ntest(\"navigating child pane transitions node marked with handlesNavigation\", function () {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    TC.nodeFor('.child1').navigate('content2');\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating root pane transitions node marked with handlesNavigation\", function () {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    TC.nodeFor('.layout').navigate('content2');\n    equal($('.layout').length, 1);\n    equal($('.child2').length, 1);\n    equal($('.content1').length, 0);\n});\n\ntest(\"navigating back returns to previous pane\", function() {\n    TC.createNode('.test', { path: 'Navigate/layout' });\n    var node = TC.nodeFor('.layout');\n    node.navigate('content2');\n    equal($('.content1').length, 0);\n    node.navigateBack();\n    equal($('.content1').length, 1);\n});\n//@ sourceURL=tribe://Tests/Integration/Navigate.tests.js\n");
window.eval("\n(function () {\n    module('Integration.nodes');\n\n    test(\"createNode binds pane to target element\", function() {\n        TC.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n    });\n\n    test(\"appendNode appends wrapped pane to target element\", function() {\n        TC.appendNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal($('#qunit-fixture div .parent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode called from paneRendered model function renders\", function() {\n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n    });\n\n    test(\"createNode inherits context from parent element\", function () {\n        TC.Events.spy = sinon.spy();\n        TC.options.events = ['loadResources', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'spy', 'active', 'dispose'];\n        \n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' });\n        ok(TC.Events.spy.calledTwice);\n        equal(TC.Events.spy.firstCall.args[1], TC.Events.spy.secondCall.args[1]);\n    });\n\n    test(\"createNode returns populated Node object\", function() {\n        var node = TC.createNode('#qunit-fixture', { path: 'Utilities/parent' });\n        equal(node.pane.path, '/Utilities/parent');\n        equal(node.children.length, 1);\n    });\n\n    asyncTest(\"context.renderOperation resolves when render operation is complete\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('#qunit-fixture', { path: 'Utilities/parent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function() {\n                equal($('#qunit-fixture .parent .child .message').text(), 'test message');\n                start();\n            });\n    });\n\n    asyncTest(\"context.renderOperation includes dynamically added nodes\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('#qunit-fixture', { path: 'Utilities/dynamicParent' }, null, context);\n        $.when(context.renderOperation.promise)\n            .done(function () {\n                equal($('#qunit-fixture .dynamicParent .child .message').text(), 'test message');\n                start();\n            });\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Integration/nodes.tests.js\n");
window.eval("\nmodule('Integration.Paths', {\n    setup: Test.Integration.createTestElement\n});\n\ntest(\"panes created with skipPath true inherit pane path from their parent\", function() {\n    TC.createNode('.test', { path: 'Paths/Subfolder/parent' });\n    equal($('.parent').length, 1);\n    equal($('.parent').children().length, 1);\n    equal($('.parent .child').length, 1);\n});\n//@ sourceURL=tribe://Tests/Integration/Paths.tests.js\n");
window.eval("\nmodule('Integration.PubSub', {\n    setup: function () {\n        Test.Integration.pubsubAsTribe();\n        Test.Integration.createTestElement();\n    } \n});\n\ntest(\"subscription in pane is executed\", function() {\n    TC.createNode('.test', { path: 'PubSub/subscriber' });\n    Test.Integration.context.pubsub.publish('test', 'message');\n    equal($('.subscriber').text(), 'message');\n});\n\ntest(\"subscription is removed when pane is removed from DOM\", function () {\n    TC.createNode('.test', { path: 'PubSub/subscriber' });\n    equal(Test.Integration.context.pubsub.subscribers.get('test').length, 1);\n    $('.test').remove();\n    equal(Test.Integration.context.pubsub.subscribers.get('test').length, 0);\n});\n//@ sourceURL=tribe://Tests/Integration/PubSub.tests.js\n");
window.eval("\n(function () {\n    module('Integration.Transition', {\n        setup: Test.Integration.createTestElement\n    });\n\n    test(\"transitioning node replaces pane with specified pane\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        TC.transition(TC.nodeFor('.pane1')).to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"transitioning element replaces pane with specified pane\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1' });\n        equal($('.pane1').length, 1);\n        TC.transition('.test').to('Transition/pane2');\n        equal($('.pane1').length, 0);\n        equal($('.pane2').length, 1);\n    });\n\n    test(\"specifying reverseTransitionIn pane option applies reverse transition\", function () {        \n        TC.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n        ok($('.pane1').parent().hasClass('slideRight'));\n    });\n\n    test(\"specifying reverse argument applies reverse transition\", function () {\n        TC.createNode('.test', { path: 'Transition/pane1', transition: 'slideLeft', reverseTransitionIn: true });\n        TC.transition(TC.nodeFor('.pane1'), null, true).to('Transition/pane2');\n        ok($('.pane1').parent().hasClass('slideRight'));\n        ok($('.pane2').parent().hasClass('slideRight'));\n    });\n\n    asyncTest(\"async transition to replaces pane with specified pane\", function () {\n        TC.options.synchronous = false;\n        var context = TC.context();\n        TC.createNode('.test', { path: 'Transition/pane1' }, null, context);\n        $.when(context.renderOperation.promise).done(function() {\n            equal($('.pane1').length, 1);\n            $.when(TC.transition('.test').to('Transition/pane2')).done(function() {\n                equal($('.pane1').length, 0);\n                equal($('.pane2').length, 1);\n                start();\n            });\n        });\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Integration/Transition.tests.js\n");
window.eval("\n(function () {\n    var root;\n\n    module('Integration.Tree', {\n        setup: function() {\n             Test.Integration.executeDefaultEvents('Tree/1');\n             root = Test.state.pane.node.root;\n        }\n    });\n\n    test(\"tree renders\", function () {\n        equal($('.111').length, 1);\n    });\n\n    test(\"node is created and attached to pane\", function () {\n        ok(Test.state.pane.node);\n        equal(Test.state.pane.path, '/Tree/1');\n    });\n\n    test(\"node is part of full node tree\", function () {\n        equal(root.children.length, 1);\n        equal(root.children[0].children.length, 2);\n        equal(root.children[0].children[1].pane.path, '/Tree/112');\n    });\n\n    test(\"node is removed from tree when pane element is remove from DOM\", function () {\n        equal(root.children[0].children.length, 2);\n        $('.111').parent().remove();\n        equal(root.children[0].children.length, 1);\n    });\n\n    test(\"pane changes when node is transitioned\", function () {\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n\n    test(\"child nodes are removed when transitioned\", function () {\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0].children.length, 0);\n    });\n\n    test(\"node is not replaced when transitioned\", function() {\n        var node = root.children[0];\n        TC.transition(TC.nodeFor('.11')).to('12');\n        equal(root.children[0], node);\n    });\n\n    test(\"node is replaced when element is transitioned\", function() {\n        var node = root.children[0];\n        TC.transition($('.11').parent()).to('/Tree/12');\n        equal(root.children.length, 1);\n        notEqual(root.children[0], node);\n        equal(root.children[0].pane.path, '/Tree/12');\n    });\n})();\n\n//@ sourceURL=tribe://Tests/Integration/Tree.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.active', {\n        setup: function() { TC.Events.spy = sinon.spy(); }\n    });\n\n    var events = Test.Integration.testEventsUntil('active');\n\n    test(\"event ends when pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(TC.Events.spy.notCalled);\n        $('.basic').parent().remove();\n        ok(TC.Events.spy.called);\n        equal(TC.Events.spy.firstCall.args[0].path, '/Events/basic');\n    });\n\n    test(\"child events end when parent pane element is removed from DOM\", function () {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        ok(TC.Events.spy.notCalled);\n        $('.basicContainer').parent().remove();\n        ok(TC.Events.spy.calledTwice);\n        equal(TC.Events.spy.firstCall.args[0].path, '/Events/basicParent');\n        equal(TC.Events.spy.secondCall.args[0].path, '/Events/basic');\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/active.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.createModel', {\n        setup: function () { Test.Integration.executeEvents(Test.Integration.testEventsUntil('createModel'), 'Events/basic'); }\n    });\n\n    test(\"model is created and attached to pane object\", function () {\n        ok(Test.state.model);\n        ok(Test.state.pane.model);\n        equal(Test.state.model, Test.state.pane.model);\n    });\n\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/createModel.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.dispose');\n\n    var events = Test.Integration.testEventsUntil('dispose');\n\n    test(\"dispose is called once on model when pane element is removed from DOM using jQuery\", function () {\n        Test.Integration.executeEvents(events, 'Events/dispose');\n        ok(!Test.state.disposeCalled);\n        $('.dispose').parent().remove();\n        equal(Test.state.disposeCallCount, 1);\n    });\n\n    // it seems DOMNodeRemoved sometimes fires asynchronously, this should probably be async - this will probably fail on other browsers\n    test(\"dispose is called once on model when pane element is removed from DOM using native functions\", function () {\n        Test.Integration.executeEvents(events, 'Events/dispose');\n        ok(!Test.state.disposeCalled);\n        var element = document.querySelector('.dispose').parentNode;\n        element.parentNode.removeChild(element);\n        equal(Test.state.disposeCallCount, 1);\n    });\n\n    test(\"dispose calls end on pubsub lifetime for each pane\", function () {\n        Test.Integration.pubsubAsMock();\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        $('.basicContainer').parent().remove();\n        ok(Test.Integration.context.pubsub.end.calledTwice);\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/dispose.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.initialiseModel');\n\n    test(\"initialise function is called on model\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/basic');\n        equal(Test.state.model.message, 'test message');\n    });\n\n    test(\"returning deferred from initialise makes pipeline wait\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        ok(TC.Events.spy.notCalled);\n        Test.state.deferred.resolve();\n        ok(TC.Events.spy.calledOnce);\n    });\n\n    test(\"rejecting deferred returned from initialise halts pipeline\", function () {\n        Test.Integration.executeEvents(Test.Integration.testEventsUntil('initialiseModel'), 'Events/initialise');\n        Test.state.deferred.reject();\n        ok(TC.Events.spy.notCalled);\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/initialiseModel.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.loadResources', {\n        setup: function () { Test.Integration.executeEvents(['loadResources'], 'Events/basic'); }\n    });\n\n    test(\"loadResources loads model\", function () {\n        ok(Test.Integration.context.models['/Events/basic']);\n    });\n\n    test(\"loadResources loads template\", function () {\n        equal($('#template--Events-basic').length, 1);\n    });\n\n    test(\"loadResources loads style\", function () {\n        equal($('#style--Events-basic').length, 1);\n    });\n\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/loadResources.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.renderComplete');\n\n    var events = Test.Integration.testEventsUntil('renderComplete');\n\n    test(\"renderComplete is called on model when single pane has rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.renderCompleteCalled);\n    });\n\n    test(\"renderComplete is called on model when all panes in tree have rendered\", function () {\n        Test.Integration.executeEvents(events, 'Events/initialiseParent');\n        ok(!Test.state.parentRenderCompleteCalled);\n        Test.state.deferred.resolve();\n        ok(Test.state.parentRenderCompleteCalled);\n    });\n    \n    asyncTest(\"renderComplete is called on single model when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n\n    asyncTest(\"renderComplete is called on all models when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.renderComplete = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/asyncParent');\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/renderComplete.tests.js\n");
window.eval("\n(function() {\n    module('Integration.Events.renderPane');\n\n    var events = Test.Integration.testEventsUntil('renderPane');\n\n    test(\"pane template is rendered and bound to model\", function () {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        equal($('.message').text(), 'test message');\n    });\n\n    test(\"paneRendered is called on model\", function() {\n        Test.Integration.executeEvents(events, 'Events/basic');\n        ok(Test.state.model.paneRenderedCalled);\n    });\n\n    test(\"child panes are rendered\", function() {\n        Test.Integration.executeEvents(events, 'Events/basicParent');\n        equal($('.basic').length, 1);\n    });\n\n    test(\"model is passed data\", function() {\n        Test.Integration.executeEvents(events, 'Events/data', 'test message');\n        equal($('.message').text(), 'test message');\n    });\n\n    asyncTest(\"paneRendered is called on model when in async mode\", function () {\n        expect(1);\n        TC.options.synchronous = false;\n        Test.state.paneRendered = function () {\n            equal($('.message').text(), 'test message');\n            start();\n        };\n        Test.Integration.executeEvents(events, 'Events/async');\n    });\n})();\n//@ sourceURL=tribe://Tests/Integration/Events/renderPane.tests.js\n");
