window.eval("window.Tribe = window.Tribe || {};\nwindow.Tribe.PubSub = function (options) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    this.owner = this;\n    this.sync = option('sync');\n     \n    var subscribers = new Tribe.PubSub.SubscriberList();\n    this.subscribers = subscribers;\n\n    function publish(envelope) {\n        var messageSubscribers = subscribers.get(envelope.topic);\n        var sync = envelope.sync === true || self.sync === true;\n\n        for (var i = 0; i < messageSubscribers.length; i++) {\n            if (sync)\n                executeSubscriber(messageSubscribers[i].handler);\n            else {\n                (function (subscriber) {\n                    setTimeout(function () {\n                        executeSubscriber(subscriber.handler);\n                    });\n                })(messageSubscribers[i]);\n            }\n        }\n\n        function executeSubscriber(func) {\n            var exceptionHandler = option('exceptionHandler');\n            \n            if(option('handleExceptions'))\n                try {\n                    func(envelope.data, envelope);\n                } catch (e) {\n                    if (exceptionHandler) exceptionHandler(e, envelope);\n                }\n            else\n                func(envelope.data, envelope);\n        }\n    }\n\n    this.publish = function (topicOrEnvelope, data) {\n        var envelope = topicOrEnvelope && topicOrEnvelope.topic\n            ? topicOrEnvelope\n            : { topic: topicOrEnvelope, data: data, sync: false };\n        return publish(envelope);\n    };\n\n    this.publishSync = function (topic, data) {\n        return publish({ topic: topic, data: data, sync: true });\n    };\n\n    this.subscribe = function (topic, func) {\n        if (typeof (topic) === \"string\")\n            return subscribers.add(topic, func);\n        else if (utils.isArray(topic))\n            return utils.map(topic, function(topicName) {\n                return subscribers.add(topicName, func);\n            });\n        else\n            return utils.map(topic, function (individualFunc, topicName) {\n                return subscribers.add(topicName, individualFunc);\n            });\n    };\n\n    this.unsubscribe = function (tokens) {\n        if (Tribe.PubSub.utils.isArray(tokens)) {\n            var results = [];\n            for(var i = 0; i < tokens.length; i++)\n                results.push(subscribers.remove(tokens[i]));\n            return results;\n        }\n\n        return subscribers.remove(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self);\n    };\n    \n    function option(name) {\n        return (options && options.hasOwnProperty(name)) ? options[name] : Tribe.PubSub.options[name];\n    }\n};Tribe.PubSub.Lifetime = function (parent, owner) {\n    var self = this;\n    var tokens = [];\n\n    this.owner = owner;\n\n    this.publish = function(topicOrEnvelope, data) {\n        return parent.publish(topicOrEnvelope, data);\n    };\n\n    this.publishSync = function(topic, data) {\n        return parent.publishSync(topic, data);\n    };\n\n    this.subscribe = function(topic, func) {\n        var token = parent.subscribe(topic, func);\n        return recordToken(token);\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        var token = parent.subscribeOnce(topic, func);\n        return recordToken(token);\n    };\n    \n    this.unsubscribe = function(token) {\n        // we should really remove the token(s) from our token list, but it has trivial impact if we don't\n        return parent.unsubscribe(token);\n    };\n\n    this.end = function() {\n        return parent.unsubscribe(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n    \n    function recordToken(token) {\n        if (Tribe.PubSub.utils.isArray(token))\n            tokens = tokens.concat(token);\n        else\n            tokens.push(token);\n        return token;\n    }\n};window.Tribe.PubSub.options = {\n    sync: false,\n    handleExceptions: true,\n    exceptionHandler: function(e, envelope) {\n        console.log(\"Exception occurred in subscriber to '\" + envelope.topic + \"': \" + e.message);\n    }\n};Tribe.PubSub.prototype.subscribeOnce = function (topic, handler) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n    var lifetime = this.createLifetime();\n\n    if (typeof (topic) === \"string\")\n        return lifetime.subscribe(topic, wrapHandler(handler));\n    else if (utils.isArray(topic))\n        return lifetime.subscribe(wrapTopicArray());\n    else\n        return lifetime.subscribe(wrapTopicObject());\n\n    function wrapTopicArray() {\n        var result = {};\n        utils.each(topic, function(topicName) {\n            result[topicName] = wrapHandler(handler);\n        });\n        return result;\n    }\n    \n    function wrapTopicObject() {\n        return utils.map(topic, function (func, topicName) {\n            return lifetime.subscribe(topicName, wrapHandler(func));\n        });\n    }\n\n    function wrapHandler(func) {\n        return function() {\n            lifetime.end();\n            func.apply(self, arguments);\n        };\n    }\n};Tribe.PubSub.SubscriberList = function() {\n    var subscribers = {};\n    var lastUid = -1;\n\n    this.get = function (publishedTopic) {\n        var matching = [];\n        for (var registeredTopic in subscribers)\n            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))\n                matching = matching.concat(subscribers[registeredTopic]);\n        return matching;\n    };\n\n    this.add = function (topic, handler) {\n        var token = (++lastUid).toString();\n        if (!subscribers.hasOwnProperty(topic))\n            subscribers[topic] = [];\n        subscribers[topic].push({ topic: topic, handler: handler, token: token });\n        return token;\n    };\n\n    this.remove = function(token) {\n        for (var m in subscribers)\n            if (subscribers.hasOwnProperty(m))\n                for (var i = 0, j = subscribers[m].length; i < j; i++)\n                    if (subscribers[m][i].token === token) {\n                        subscribers[m].splice(i, 1);\n                        return token;\n                    }\n\n        return false;\n    };\n\n    function topicMatches(published, subscriber) {\n        if (subscriber === '*')\n            return true;\n        \n        var expression = \"^\" + subscriber\n            .replace(/\\./g, \"\\\\.\")\n            .replace(/\\*/g, \"[^\\.]*\") + \"$\";\n        return published.match(expression);\n    }\n};Tribe.PubSub.utils = {};\n(function(utils) {\n    utils.isArray = function (source) {\n        return source.constructor === Array;\n    };\n\n    // The following functions are taken from the underscore library, duplicated to avoid dependency. Licensing at http://underscorejs.org.\n    var nativeForEach = Array.prototype.forEach;\n    var nativeMap = Array.prototype.map;\n    var breaker = {};\n\n    utils.each = function (obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker) return;\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) return;\n                }\n            }\n        }\n    };\n\n    utils.map = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        utils.each(obj, function (value, index, list) {\n            results[results.length] = iterator.call(context, value, index, list);\n        });\n        return results;\n    };\n})(Tribe.PubSub.utils);\n\n//@ sourceURL=Libraries/Tribe.PubSub.js");
window.eval("(function(global) {\n    if (!jQuery)\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (!ko)\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n\n    global.Tribe = global.Tribe || {};\n    global.Tribe.Composite = {};\n    global.TC = global.Tribe.Composite;\n    global.TC.Events = {};\n    global.TC.Factories = {};\n    global.TC.LoadHandlers = {};\n    global.TC.LoadStrategies = {};\n    global.TC.Loggers = {};\n    global.TC.Transitions = {};\n    global.TC.Types = {};\n    global.TC.Utils = {};\n    global.T = global.TC.Utils;\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n        //$('head').append('<style class=\"__tribe\">.__rendering { position: fixed; right: 100%; }</style>');\n    });\n})(window || this);\n\n//@ sourceURL=Source/setup.js");
window.eval("TC.defaultOptions = function() {\n    return {\n        synchronous: false,\n        splitScripts: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']\n    };\n};\nTC.options = TC.defaultOptions();\n//@ sourceURL=Source/options.js");
window.eval("(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//@ sourceURL=Source/Utilities/bindingHandlers.js");
window.eval("(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n})(TC.Utils);\n//@ sourceURL=Source/Utilities/collections.js");
window.eval("TC.Utils.elementDestroyed = function (element) {\n    if (element.constructor === jQuery)\n        element = element[0];\n    \n    var promise = $.Deferred();\n\n    // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n    $(element).on('destroyed', resolve);\n\n    // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n    $(document).on(\"DOMNodeRemoved\", matchElement);\n\n    function matchElement(event) {\n        if (event.target === element)\n            resolve();\n    }\n\n    function resolve() {\n        promise.resolve();\n        $(element).off('destroyed', resolve);\n        $(document).off('DOMNodeRemoved', matchElement);\n    }\n\n    return promise;\n};\n//@ sourceURL=Source/Utilities/elementDestroyed.js");
window.eval("(function() {\n    TC.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    TC.Utils.contextFor = function (element) {\n        return element && TC.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    TC.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');\n    };\n\n    TC.Utils.nodeFor = function (element) {\n        return element && TC.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n\n    TC.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//@ sourceURL=Source/Utilities/embeddedContext.js");
window.eval("TC.Utils.raiseDocumentEvent = function(name, data) {\n    var event = document.createEvent(\"Event\");\n    event.initEvent(name, true, false);\n    event.data = data;\n    document.dispatchEvent(event);\n};\n\n//@ sourceURL=Source/Utilities/events.js");
window.eval("TC.Utils.try = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(func, args);\n        } catch (ex) {\n            TC.logger.error(message, ex);\n        }\n    else\n        func.apply(func, args);\n};\n//@ sourceURL=Source/Utilities/exceptions.js");
window.eval("(function () {\n    TC.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = TC.Utils.idGenerator();\n    TC.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//@ sourceURL=Source/Utilities/idGenerator.js");
window.eval("(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//@ sourceURL=Source/Utilities/jquery.complete.js");
window.eval("(function ($) {\n    var oldClean = jQuery.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})(jQuery);\n//@ sourceURL=Source/Utilities/jquery.destroyed.js");
window.eval("TC.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//@ sourceURL=Source/Utilities/knockout.js");
window.eval("TC.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        function: byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nTC.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nTC.Utils.inheritOptions = function(from, to, options) {\n    for (var i = 0; i < options.length; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nTC.Utils.evaluateProperty = function(target, property) {\n    var properties = property.match(/[^\\.]+/g);\n    var result = target;\n    \n    if (properties) {\n        for (var i = 0; i < properties.length; i++)\n            if (properties[i])\n                result = result[properties[i]];\n    }\n    return result;\n};\n//@ sourceURL=Source/Utilities/objects.js");
window.eval("(function () {\n    var utils = TC.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n})();\n\n//@ sourceURL=Source/Utilities/panes.js");
window.eval("(function() {\n    TC.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return Path(extensionIndex === -1 ? '' : path.substring(extensionIndex + 1));\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path[0] === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return Path(this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, ''));\n            },\n            setExtension: function(extension) {\n                return this.withoutExtension() + '.' + extension;\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//@ sourceURL=Source/Utilities/Path.js");
window.eval("TC.Types.History = function (history) {\n    var ids = TC.Utils.idGenerator();\n    var node;\n    var currentState;\n\n    $(document).on('navigating', documentNavigating);\n    window.onpopstate = popState;\n    \n    function documentNavigating(e, data) {\n        if (node !== data.node) {\n            node = data.node;\n            pushState({ path: node.pane.path, data: node.pane.data }, true);\n        }\n        pushState(data.options);\n    }\n    \n    function pushState(options, replace) {\n        var state = {\n            id: ids.next(),\n            options: JSON.stringify(options)\n        };\n        currentState = state;\n        replace ? history.replaceState(state, '') : history.pushState(state, '');\n    }\n    \n    function popState(e) {\n        currentState = e.state;\n        //var reverse = state.id < currentState.id;\n        if (currentState) {\n            node.transitionTo(JSON.parse(currentState.options), null, true);\n        }\n    }\n\n    this.dispose = function() {\n        $(document).off('navigating', documentNavigating);\n        $(document).off('popstate', popState);\n    };\n};\n//@ sourceURL=Source/Types/History.js");
window.eval("// Ensures URLs are only loaded once. \n// Concurrent requests return the same promise.\n// Delegates actual loading and handling of resources to LoadHandlers\nTC.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = TC.Path(url).extension().toString();\n        var handler = TC.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        TC.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//@ sourceURL=Source/Types/Loader.js");
window.eval("TC.Types.Logger = function () {\n    var logLevel = 0;\n    var logger = 'console';\n\n    var levels = {\n        0: 'debug',\n        1: 'info',\n        2: 'warn',\n        3: 'error',\n        4: 'none'\n    };\n\n    this.debug = function (message) {\n        log(0, message);\n    };\n\n    this.info = function (message) {\n        log(1, message);\n    };\n\n    this.warn = function (message) {\n        log(2, message);\n    };\n\n    this.error = function (message, error) {\n        var logString;\n        if (error && error.stack)\n            logString = message + ' ' + error.stack;\n        else if (error && error.message)\n            logString = message + ' ' + error.message;\n        else\n            logString = message + ' ' + (error ? error : '');\n\n        log(3, logString);\n    };\n\n    function log(level, message) {\n        if(logLevel <= level)\n            TC.Loggers[logger](levels[level], message);\n    };\n\n    this.setLogLevel = function (level) {\n        $.each(levels, function(value, text) {\n            if (level === text)\n                logLevel = value;\n        });\n    };\n\n    this.setLogger = function(newLogger) {\n        logger = newLogger;\n    };\n};\n\nTC.logger = new TC.Types.Logger();\n//@ sourceURL=Source/Types/Logger.js");
window.eval("TC.Types.Models = function () { };\n\nTC.Types.Models.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    TC.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//@ sourceURL=Source/Types/Models.js");
window.eval("TC.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nTC.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = TC.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!TC.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = TC.Path(this.pane.path).withoutFilename().combine(paneOptions.path).toString();\n\n    if (this.defaultNavigationNode && this.defaultNavigationNode.handlesNavigation)\n        this.defaultNavigationNode.navigate(paneOptions);\n    \n    else if (this.handlesNavigation || !this.parent) {\n        $(document).trigger('navigating', { node: this, options: paneOptions });\n        this.transitionTo(paneOptions, this.handlesNavigation);\n        \n    } else\n        this.parent.navigate(paneOptions);\n};\n\nTC.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    TC.transition(this, transition || this.handlesNavigation, reverse).to(paneOptions);\n};\n\nTC.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.handlesNavigation = pane.handlesNavigation;\n        \n        // this sets this pane as the \"default\", accessible from everywhere. \n        // It's not appropriate for multiple navigation panes, but we haven't tested for that anyway.\n        this.root.defaultNavigationNode = this;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nTC.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nTC.Types.Node.prototype.dispose = function() {\n    if (this.parent)\n        TC.Utils.removeItem(this.parent.children, this);\n    if (this.pane && this.pane.dispose)\n        this.pane.dispose();\n};\n//@ sourceURL=Source/Types/Node.js");
window.eval("// Encapsulates an operation involving several child operations, keyed by an id\n// Child operations can be added cumulatively\n// Promise resolves when the all child operations complete\nTC.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        TC.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//@ sourceURL=Source/Types/Operation.js");
window.eval("TC.Types.Pane = function (options) {\n    TC.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };    \n};\n\nTC.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nTC.Types.Pane.prototype.remove = function() {\n    $(this.element).remove();\n};\n\nTC.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        var node = this.node;\n        delete this.node;\n        node.dispose();\n    }\n\n    if (this.element)\n        TC.Utils.cleanElement(this.element);\n};\n\nTC.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;    \n    var path = TC.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = TC.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nTC.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nTC.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nTC.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nTC.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n//@ sourceURL=Source/Types/Pane.js");
window.eval("// Manages the step by step execution of a number of named events\n// Each step will only execute after the promise returned by the previous step resolves\n// A rejected promise will halt execution of the pipeline\nTC.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var event = events[eventName];\n\n            if (!event) {\n                TC.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            $.when(event(target, context))\n                .done(executeNextEvent)\n                .fail(handleFailure);\n\n            function handleFailure() {\n                promise.reject();\n                var targetDescription = target ? target.toString() : \"empty target\";\n                TC.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription);\n            }\n        }\n\n        return promise;\n    };\n};\n//@ sourceURL=Source/Types/Pipeline.js");
window.eval("TC.Types.Saga = function (pane, handlers, initialData) {\n    var self = this;\n    \n    this.pubsub = pane.pubsub.createLifetime();\n    this.pane = pane;\n    this.data = initialData || {};\n    this.children = [];\n\n    handlers = $.extend({}, handlers);\n    var startHandler = handlers.onstart;\n    delete handlers.onstart;\n    var endHandler = handlers.onend;\n    delete handlers.onend;\n\n    this.start = function() {\n        $.each(handlers, attachHandler);\n        if(startHandler) startHandler(self, initialData);\n        return self;\n    };\n    \n    function attachHandler(topic, handler) {\n        self.pubsub.subscribe(topic, messageHandlerFor(handler));\n    }\n    \n    function messageHandlerFor(handler) {\n        return function(messageData, envelope) {\n            handler(self, messageData, envelope);\n        };\n    }\n\n    this.startChild = function(childHandlers, childData) {\n        self.children.push(new TC.Types.Saga(pane, childHandlers, childData).start());\n    };\n\n    this.end = function () {\n        if (endHandler) endHandler(self);        \n        self.pubsub.end();\n        $.each(self.children, function(index, child) {\n            child.end();\n        });\n    };\n};\n//@ sourceURL=Source/Types/Saga.js");
window.eval("TC.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = TC.Path(path).asMarkupIdentifier().toString();\n        var $template = $(template);\n        if ($template.is(\"script\"))\n            $('head').append($template.filter('script'));\n        else\n            $('<script type=\"text/template\" class=\"__tribe\" id=\"template-' + id + '\"></script>').text(template).appendTo('head');\n    };\n\n    this.loaded = function(path) {\n        return $('head script#template-' + TC.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = TC.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//@ sourceURL=Source/Types/Templates.js");
window.eval("TC.Events.active = function (pane, context) {\n    return TC.Utils.elementDestroyed(pane.element);\n};\n//@ sourceURL=Source/Events/active.js");
window.eval("TC.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path];\n    var model = definition && definition.constructor ?\n        new definition.constructor(pane) :\n        { pane: pane, data: pane.data };\n\n    TC.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n};\n//@ sourceURL=Source/Events/createModel.js");
window.eval("TC.Events.createPubSub = function (pane, context) {\n    if (context.pubsub)\n        pane.pubsub = context.pubsub.createLifetime ?\n            context.pubsub.createLifetime() :\n            context.pubsub;\n};\n\n//@ sourceURL=Source/Events/createPubSub.js");
window.eval("TC.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//@ sourceURL=Source/Events/dispose.js");
window.eval("TC.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//@ sourceURL=Source/Events/initialiseModel.js");
window.eval("TC.Events.loadResources = function (pane, context) {\n    var strategy = TC.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//@ sourceURL=Source/Events/loadResources.js");
window.eval("TC.Events.renderComplete = function (pane, context) {\n    $.when(TC.transition(pane, null, pane.reverseTransitionIn).in()).done(executeRenderComplete);\n    setTimeout(function() {\n        pane.endRender();\n    });\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        TC.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new TC.Types.Operation();\n    }\n};\n//@ sourceURL=Source/Events/renderComplete.js");
window.eval("TC.Events.renderPane = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    TC.Utils.try(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n\n    function applyBindings() {\n        var elements = $(pane.element).children();\n        for (var i = 0; i < elements.length; i++)\n            ko.applyBindings(pane.model, elements[i]);\n    }\n};\n//@ sourceURL=Source/Events/renderPane.js");
window.eval("TC.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeLoadedScripts\n    });\n\n    function executeLoadedScripts(scripts) {\n        if (shouldSplit(scripts)) {\n            var split = splitScripts(scripts);\n\n            if (split === null)\n                executeScript(appendSourceUrl(scripts));\n            else\n                for (var i = 0; i < split.length; i++)\n                    executeScript(split[i]);\n\n        } else\n            executeScript(appendSourceUrl(scripts));\n\n        TC.logger.debug('Loaded script from ' + url);\n    }\n    \n    function executeScript(script) {\n        TC.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        TC.Utils.try($.globalEval, [script], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete TC.scriptEnvironment;\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//@ sourceURL=' + url.replace(/ /g, \"_\");\n    }\n    \n    function splitScripts(script) {\n        return script.match(/(.*(\\r|\\n))*?(.*\\/{2}\\@ sourceURL.*)/g);\n    }\n\n    function shouldSplit(script) {\n        if (context.options.splitScripts !== true) return false;\n        var tagMatches = script.match(\"(//@ sourceURL=)\");\n        return tagMatches && tagMatches.length > 1;\n    }\n};\n//@ sourceURL=Source/LoadHandlers/scripts.js");
window.eval("TC.LoadHandlers.css = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        $('<style/>')\n            .attr('id', resourcePath ? 'style-' + TC.Path(resourcePath).asMarkupIdentifier() : null)\n            .attr('class', '__tribe')\n            .text(stylesheet)\n            .appendTo('head');\n    }\n};\n//@ sourceURL=Source/LoadHandlers/stylesheets.js");
window.eval("TC.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nTC.LoadHandlers.html = TC.LoadHandlers.htm;\n\n//@ sourceURL=Source/LoadHandlers/templates.js");
window.eval("TC.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = TC.Path(context.options.basePath).combine(TC.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            TC.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//@ sourceURL=Source/LoadStrategies/adhoc.js");
window.eval("TC.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        TC.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//@ sourceURL=Source/LoadStrategies/preloaded.js");
window.eval("TC.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n    \n    transition = transition || (pane && pane.transition);\n    var implementation = TC.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = TC.Transitions[implementation.reverse];\n\n    return {\n        in: function () {\n            $(element).show();\n            return implementation && implementation.in(element);\n        },\n        \n        out: function (remove) {\n            if (TC.transition.mode === 'fixed')\n                setFixedPosition();\n            \n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n            \n            function removeElement() {\n                remove === false ? $(element).hide() : $(element).remove();\n            }\n        },\n        \n        to: function (paneOptions, remove) {\n            var context = TC.context();\n            if (node)\n                TC.insertPaneAfter(node, element, TC.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                TC.insertNodeAfter(element, TC.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove);\n            return context.renderOperation.promise;\n        }\n    };\n    \n    function setFixedPosition() {\n        var $element = $(element);\n        $element.css({\n            position: 'fixed',\n            left: $element.offset().left,\n            top: $element.offset().top\n        });\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to TC.transition\";\n        \n        if (target.constructor === TC.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === TC.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }    \n};\n//@ sourceURL=Source/Transitions/transition.js");
window.eval("(function () {\n    createCssTransition('fade');\n    createCssTransition('pop');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n    createCssTransition('flipLeft', 'flipRight');\n    createCssTransition('flipRight', 'flipLeft');\n    createCssTransition('swapLeft', 'swapRight');\n    createCssTransition('swapRight', 'swapLeft');\n    createCssTransition('cubeLeft', 'cubeRight');\n    createCssTransition('cubeRight', 'cubeLeft');\n\n    function createCssTransition(name, reverse) {\n        TC.Transitions[name] = {\n            in: function(element) {\n                var $element = $(element);\n                $element.bind('webkitAnimationEnd', animationEnd)\n                        .addClass(name + ' in');\n\n                var promise = $.Deferred();\n                return promise;\n\n                function animationEnd() {\n                    $element.unbind('webkitAnimationEnd', animationEnd)\n                            .removeClass(name + ' in');\n                    promise.resolve();\n                }\n            },\n            \n            out: function(element) {\n                var $element = $(element);\n                $element.bind('webkitAnimationEnd', animationEnd)\n                        .addClass(name + ' out');\n\n                var promise = $.Deferred();\n                return promise;\n\n                function animationEnd() {\n                    $element.unbind('webkitAnimationEnd', animationEnd)\n                            .removeClass(name + ' out')\n                            .remove();\n                    promise.resolve();\n                }\n            },\n            reverse: reverse || name\n        };\n    }\n})();\n\n//@ sourceURL=Source/Transitions/Css/css.js");
window.eval("$('<style/>')\n    .attr('class', '__tribe')\n    .text('.in,.out{-webkit-animation-duration:250ms;-webkit-animation-fill-mode:both;-webkit-animation-timing-function:ease-in-out}.in:after{content:\"\";position:absolute;display:block;top:0;left:0;bottom:0;right:0}.cubeLeft.in,.cubeLeft.out,.cubeRight.in,.cubeRight.out{-webkit-animation-duration:.6s;-webkit-transform:perspective(800)}.cubeLeft.in{-webkit-transform-origin:0% 50%;-webkit-animation-name:cubeLeftIn}.cubeLeft.out{-webkit-transform-origin:100% 50%;-webkit-animation-name:cubeLeftOut}@-webkit-keyframes cubeLeftIn{0%{-webkit-transform:rotateY(90deg) translateZ(320px);opacity:.5}100%{-webkit-transform:rotateY(0) translateZ(0) translateX(0);opacity:1}}@-webkit-keyframes cubeLeftOut{0%{-webkit-transform:rotateY(0) translateZ(0) translateX(0);opacity:1}100%{-webkit-transform:rotateY(-90deg) translateZ(320px);opacity:.5}}.cubeRight.in{-webkit-transform-origin:100% 50%;-webkit-animation-name:cubeRightIn}.cubeRight.out{-webkit-transform-origin:0% 50%;-webkit-animation-name:cubeRightOut}@-webkit-keyframes cubeRightIn{0%{-webkit-transform:rotateY(-90deg) translateZ(320px);opacity:.5}100%{-webkit-transform:rotateY(0) translateZ(0) translateX(0);opacity:1}}@-webkit-keyframes cubeRightOut{0%{-webkit-transform:rotateY(0) translateZ(0) translateX(0);opacity:1}100%{-webkit-transform:rotateY(90deg) translateZ(320px);opacity:.5}}.fade.in{-webkit-animation-name:fadeIn}.fade.out{z-index:10;-webkit-animation-name:fadeOut}@-webkit-keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.flipLeft{-webkit-backface-visibility:hidden}.flipLeft.in{-webkit-animation-name:flipLeftIn}.flipLeft.out{-webkit-animation-name:flipLeftOut}@-webkit-keyframes flipLeftIn{0%{-webkit-transform:rotateY(180deg) scale(.8)}100%{-webkit-transform:rotateY(0) scale(1)}}@-webkit-keyframes flipLeftOut{0%{-webkit-transform:rotateY(0) scale(1)}100%{-webkit-transform:rotateY(-180deg) scale(.8)}}.flipRight{-webkit-backface-visibility:hidden}.flipRight.in{-webkit-animation-name:flipRightIn}.flipRight.out{-webkit-animation-name:flipRightOut}@-webkit-keyframes flipRightIn{0%{-webkit-transform:rotateY(-180deg) scale(.8)}100%{-webkit-transform:rotateY(0) scale(1)}}@-webkit-keyframes flipRightOut{0%{-webkit-transform:rotateY(0) scale(1)}100%{-webkit-transform:rotateY(180deg) scale(.8)}}.pop.in{-webkit-animation-name:popIn}.pop.out{-webkit-animation-name:popOut}@-webkit-keyframes popIn{0%{-webkit-transform:scale(.2);opacity:0}100%{-webkit-transform:scale(1);opacity:1}}@-webkit-keyframes popOut{0%{-webkit-transform:scale(1);opacity:1}100%{-webkit-transform:scale(.2);opacity:0}}.slideLeft.in{-webkit-animation-name:slideLeftIn}.slideLeft.out{-webkit-animation-name:slideLeftOut}@-webkit-keyframes slideLeftIn{0%{-webkit-transform:translateX(100%)}100%{-webkit-transform:translateX(0)}}@-webkit-keyframes slideLeftOut{0%{-webkit-transform:translateX(0)}100%{-webkit-transform:translateX(-100%)}}.slideRight.in{-webkit-animation-name:slideRightIn}.slideRight.out{-webkit-animation-name:slideRightOut}@-webkit-keyframes slideRightIn{0%{-webkit-transform:translateX(-100%)}100%{-webkit-transform:translateX(0)}}@-webkit-keyframes slideRightOut{0%{-webkit-transform:translateX(0)}100%{-webkit-transform:translateX(100%)}}.slideUp.in{-webkit-animation-name:slideUpIn}.slideUp.out{-webkit-animation-name:slideUpOut}@-webkit-keyframes slideUpIn{0%{-webkit-transform:translateY(100%)}100%{-webkit-transform:translateY(0)}}@-webkit-keyframes slideUpOut{0%{-webkit-transform:translateY(0)}100%{-webkit-transform:translateY(-100%)}}.slideDown.in{-webkit-animation-name:slideDownIn}.slideDown.out{-webkit-animation-name:slideDownOut}@-webkit-keyframes slideDownIn{0%{-webkit-transform:translateY(-100%)}100%{-webkit-transform:translateY(0)}}@-webkit-keyframes slideDownOut{0%{-webkit-transform:translateY(0)}100%{-webkit-transform:translateY(100%)}}.swapLeft{-webkit-animation-duration:.7s;-webkit-transform:perspective(800);-webkit-animation-timing-function:ease-out}.swapLeft.in{-webkit-animation-name:swapLeftIn}.swapLeft.out{-webkit-animation-name:swapLeftOut}@-webkit-keyframes swapLeftIn{0%{-webkit-transform:translate3d(0,0,-800px) rotateY(-70deg);opacity:0}35%{-webkit-transform:translate3d(180px,0,-400px) rotateY(-20deg);opacity:1}100%{opacity:1;-webkit-transform:translate3d(0,0,0) rotateY(0)}}@-webkit-keyframes swapLeftOut{0%{-webkit-transform:translate3d(0,0,0) rotateY(0);opacity:1}35%{-webkit-transform:translate3d(-180px,0,-400px) rotateY(20deg);opacity:.5}100%{-webkit-transform:translate3d(0,0,-800px) rotateY(70deg);opacity:0}}.swapRight{-webkit-animation-duration:.7s;-webkit-transform:perspective(800);-webkit-animation-timing-function:ease-out}.swapRight.in{-webkit-animation-name:swapRightIn}.swapRight.out{-webkit-animation-name:swapRightOut}@-webkit-keyframes swapRightIn{0%{-webkit-transform:translate3d(0,0,-800px) rotateY(70deg);opacity:0}35%{-webkit-transform:translate3d(-180px,0,-400px) rotateY(20deg);opacity:1}100%{-webkit-transform:translate3d(0,0,0) rotateY(0);opacity:1}}@-webkit-keyframes swapRightOut{0%{-webkit-transform:translate3d(0,0,0) rotateY(0);opacity:1}35%{-webkit-transform:translate3d(180px,0,-400px) rotateY(-20deg);opacity:.5}100%{-webkit-transform:translate3d(0,0,-800px) rotateY(-70deg);opacity:0}}')\n    .appendTo('head');\n\n//@ sourceURL=Source/Transitions/Css/style.css.js");
window.eval("(function () {\n    TC.registerModel = function () {\n        var environment = TC.scriptEnvironment || {};\n        \n        var context = environment.context || TC.context();\n        var args = TC.Utils.arguments(arguments);\n        \n        var constructor = args.function;\n        var options = args.object;\n        var path = args.string || environment.resourcePath;\n        \n        context.models.register(path, constructor, options);\n    };\n\n    TC.initialise = function(preload, model) {\n        if (preload) {\n            var promises = [];\n            var context = TC.context();\n\n            if ($.isArray(preload))\n                for (var i = 0; i < preload.length; i++)\n                    addPromise(preload[i]);\n            else\n                addPromise(preload);\n            \n            function addPromise(path) {\n                promises.push(context.loader.get(TC.Path(context.options.basePath).combine(path).toString(), null, context));\n            }\n\n            return $.when.apply(null, promises).done(function () {\n                ko.applyBindings(model);\n            });\n        } else\n            ko.applyBindings(model);\n    };\n})();\n//@ sourceURL=Source/Api/api.js");
window.eval("(function() {\n    ko.bindingHandlers.pane = { init: updateBinding };\n\n    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        TC.createNode(element, constructPaneOptions(), TC.Utils.extractNode(bindingContext), TC.Utils.extractContext(bindingContext));\n\n        return { controlsDescendantBindings: true };\n\n        function constructPaneOptions() {\n            return TC.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n    }\n})();\n\n//@ sourceURL=Source/Api/bindingHandler.js");
window.eval("(function () {\n    var staticState;\n\n    TC.context = function (source) {\n        staticState = staticState || {\n            models: new TC.Types.Models(),\n            loader: new TC.Types.Loader(),\n            options: TC.options,\n            templates: new TC.Types.Templates(),\n            loadedPanes: {},\n            pubsub: Tribe.PubSub && new Tribe.PubSub({ sync: TC.options.synchronous, handleExceptions: TC.options.handleExceptions })\n        };\n        var perContextState = {\n            renderOperation: new TC.Types.Operation()\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//@ sourceURL=Source/Api/context.js");
window.eval("(function () {\n    var utils = TC.Utils;\n\n    TC.bindPane = function(node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || TC.context();\n        var pane = new TC.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new TC.Types.Pipeline(TC.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    TC.appendPane = function(node, target, paneOptions, context) {\n        var element = $('<div/>').appendTo(target);\n        return TC.bindPane(node, element, paneOptions, context);\n    };\n\n    TC.insertPaneAfter = function(node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return TC.bindPane(node, element, paneOptions, context);\n    };\n\n    TC.createNode = function (element, paneOptions, parentNode, context) {\n        parentNode = parentNode || utils.nodeFor(element);\n        context = context || utils.contextFor(element) || TC.context();\n\n        var node = new TC.Types.Node(parentNode);\n        TC.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    TC.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return TC.createNode(element, paneOptions, parentNode, context);\n    };\n\n    TC.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return TC.createNode(element, paneOptions, parentNode || utils.nodeFor(target), context);\n    };\n})();\n\n//@ sourceURL=Source/Api/nodes.js");
window.eval("TC.Loggers.console = function(level, message) {\n    if (window.console && window.console.log)\n        window.console.log(level.toUpperCase() + ': ' + message);\n};\n//@ sourceURL=Source/Loggers/console.js");
