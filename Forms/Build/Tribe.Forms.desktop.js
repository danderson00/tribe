// Generated by CoffeeScript 1.2.1-pre

/*!
 * Lightweight DatePicker - jQuery Plugin
 * Provides themeable and customizable date picker
 *
 * Â© 2011 Maxim Zhukov (zhkv.mxm@gmail.com)
 * 
 * Version: 1.1
 * Requires: jQuery v1.6+
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
*/


(function() {
  var $, LightweightDatepicker, compareDates, isDateValid, lw_dp_active_day_class, lw_dp_class, lw_dp_data_key, lw_dp_dows_class, lw_dp_dows_last_column_class, lw_dp_firstweek_class, lw_dp_hidden_class, lw_dp_lastweek_class, lw_dp_month_class, lw_dp_neighbour_month_day_class, lw_dp_next_class, lw_dp_out_of_interval_class, lw_dp_previous_class, lw_dp_today_class, lw_dp_toolbar_class, lw_dp_week_class, lw_dp_week_last_column_class, lw_dp_weekend_class, settings,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  $ = jQuery;

  settings = {
    'startDate': null,
    'endDate': null,
    'dowNames': ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    'monthNames': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    'firstDayOfTheWeekIndex': 0,
    'autoFillToday': false,
    'alwaysVisible': false,
    'autoHideAfterClick': false,
    'parseDate': null,
    'formatDate': null,
    'onChange': null
  };

  lw_dp_class = 'lw-dp';

  lw_dp_active_day_class = 'lw-dp-active-day';

  lw_dp_dows_class = 'lw-dp-dows';

  lw_dp_dows_last_column_class = 'lw-dp-dows-last-column';

  lw_dp_firstweek_class = 'lw-dp-firstweek';

  lw_dp_hidden_class = 'lw-dp-hidden';

  lw_dp_lastweek_class = 'lw-dp-lastweek';

  lw_dp_month_class = 'lw-dp-month';

  lw_dp_neighbour_month_day_class = 'lw-dp-neighbour-month-day';

  lw_dp_next_class = 'lw-dp-next';

  lw_dp_out_of_interval_class = 'lw-dp-out-of-interval';

  lw_dp_previous_class = 'lw-dp-previous';

  lw_dp_today_class = 'lw-dp-today';

  lw_dp_toolbar_class = 'lw-dp-toolbar';

  lw_dp_week_class = 'lw-dp-week';

  lw_dp_week_last_column_class = 'lw-dp-week-last-column';

  lw_dp_weekend_class = 'lw-dp-weekend';

  lw_dp_data_key = 'lw-datepicker';

  compareDates = function(date1, date2) {
    if (date1.getFullYear() < date2.getFullYear()) return -1;
    if (date1.getFullYear() > date2.getFullYear()) return 1;
    if (date1.getMonth() < date2.getMonth()) return -1;
    if (date1.getMonth() > date2.getMonth()) return 1;
    if (date1.getDate() < date2.getDate()) return -1;
    if (date1.getDate() > date2.getDate()) return 1;
    return 0;
  };

  isDateValid = function(date) {
    if (Object.prototype.toString.call(date) !== '[object Date]') return false;
    return !isNaN(date.getTime());
  };

  LightweightDatepicker = (function() {

    LightweightDatepicker.name = 'LightweightDatepicker';

    LightweightDatepicker.prototype.canShowPreviousMonth = true;

    LightweightDatepicker.prototype.canShowNextMonth = true;

    LightweightDatepicker.prototype.shouldHide = true;

    function LightweightDatepicker(el, settings) {
      this.destroy = __bind(this.destroy, this);

      this._handleKeyDown = __bind(this._handleKeyDown, this);

      this.showNextMonth = __bind(this.showNextMonth, this);

      this.showPreviousMonth = __bind(this.showPreviousMonth, this);

      this.show = __bind(this.show, this);

      this.hide = __bind(this.hide, this);

      this._isDateInsidePeriod = __bind(this._isDateInsidePeriod, this);

      this.setCurrentDate = __bind(this.setCurrentDate, this);

      this.setActiveDate = __bind(this.setActiveDate, this);

      this._updateMonth = __bind(this._updateMonth, this);

      this._getDateFromElement = __bind(this._getDateFromElement, this);

      this._onChange = __bind(this._onChange, this);

      this._onClick = __bind(this._onClick, this);
      this.input = el;
      this.input.bind('focus', this.show);
      this.input.bind('blur', this.hide);
      this.input.bind('keydown', this._handleKeyDown);
      this.input.bind('change', this._onChange);
      this.input.bind('click', this._onClick);
      this.isIE = $.browser.msie && parseInt($.browser.version, 10) <= 8;
      this.input.data(lw_dp_data_key, this);
      this.settings = {
        startDate: settings['startDate'],
        endDate: settings['endDate'],
        dowNames: settings['dowNames'],
        monthNames: settings['monthNames'],
        firstDayOfTheWeekIndex: settings['firstDayOfTheWeekIndex'],
        autoFillToday: settings['autoFillToday'],
        alwaysVisible: settings['alwaysVisible'],
        autoHideAfterClick: settings['autoHideAfterClick'],
        parseDate: settings['parseDate'],
        formatDate: settings['formatDate'],
        onChange: settings['onChange']
      };
      this.todayDate = new Date;
      this.currentDate = this.settings.startDate || new Date;
      this._createDatepicker();
      if (this.settings.autoFillToday && this._isDateInsidePeriod(new Date)) {
        this.activeDate = new Date;
      }
      this.setActiveDate(this._parseDate(this.input.val()));
      if (this.settings.alwaysVisible) {
        this.wrapper.insertAfter(this.input);
      } else {
        this.wrapper.appendTo(document.body);
      }
      this.margin = parseInt(this.wrapper.css('margin-top'), 10);
      this.wrapper.css('margin', 0);
      this._bindEvents();
      if (this.settings.alwaysVisible) this.updatePosition();
      this.updateInput();
      this._updateMonth();
      this.hide();
    }

    LightweightDatepicker.prototype._onClick = function() {
      if (!$("." + lw_dp_class).has(this.wrapper).length) return this.show();
    };

    LightweightDatepicker.prototype._onChange = function() {
      if (this.updatingInput) return;
      return this.setActiveDate(this._parseDate(this.input.val()));
    };

    LightweightDatepicker.prototype._createDatepicker = function() {
      this.wrapper = $("<div class=" + lw_dp_class + "/>");
      this.toolbar = $("<div class=" + lw_dp_toolbar_class + "/>").appendTo(this.wrapper);
      this.previous = $("<div class=" + lw_dp_previous_class + "/>").appendTo(this.toolbar);
      this.next = $("<div class=" + lw_dp_next_class + "/>").appendTo(this.toolbar);
      this.month = $("<div class=" + lw_dp_month_class + "/>").appendTo(this.toolbar);
      this._renderDows().appendTo(this.wrapper);
      return this.days = $('<div/>').appendTo(this.wrapper);
    };

    LightweightDatepicker.prototype._bindEvents = function() {
      var event,
        _this = this;
      this.wrapper.bind('mousedown touchstart', function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (_this.isIE) return _this.shouldHide = false;
      });
      event = this.isIE ? 'mousedown' : 'click touchstart';
      this.toolbar.delegate("." + lw_dp_next_class, event, this.showNextMonth);
      this.toolbar.delegate("." + lw_dp_previous_class, event, this.showPreviousMonth);
      return this.days.delegate("li:not(." + lw_dp_active_day_class + "):not(." + lw_dp_out_of_interval_class + ")", event, function(e) {
        var currentLi;
        currentLi = $(e.currentTarget);
        _this.setActiveDate(_this._getDateFromElement(currentLi));
        if (_this.settings.autoHideAfterClick) _this.hide();
        if (typeof _this.settings.onChange === 'function') {
          _this.settings.onChange(_this.activeDate, _this.input);
        }
        return false;
      });
    };

    LightweightDatepicker.prototype._getDateFromElement = function(el) {
      var currentDay, currentMonth, currentYear, diff;
      currentDay = el.text();
      currentYear = this.currentDate.getFullYear();
      diff = 0;
      if (el.hasClass(lw_dp_neighbour_month_day_class)) {
        diff = currentDay > 10 ? -1 : 1;
      }
      currentMonth = this.currentDate.getMonth() + diff;
      return new Date(currentYear, currentMonth, currentDay);
    };

    LightweightDatepicker.prototype.updateInput = function() {
      this.input.val(this._formatDate(this.activeDate));
      this.updatingInput = true;
      this.input.trigger('change');
      return this.updatingInput = false;
    };

    LightweightDatepicker.prototype._updateMonth = function() {
      var cd, date, day, daysInFirstWeek, daysInMonth, daysInPreviousMonth, firstDayDow, firstDayOfNextMonth, html, lastDayOfPreviousMonth, lastDowIndex, renderDay, week, weeks, _i, _j,
        _this = this;
      this.month.html(this.settings.monthNames[this.currentDate.getMonth()] + ', ' + this.currentDate.getFullYear());
      cd = this.currentDate;
      lastDayOfPreviousMonth = new Date(cd.getFullYear(), cd.getMonth(), 0);
      if ((this.settings.startDate != null) && lastDayOfPreviousMonth.getTime() < this.settings.startDate.getTime()) {
        this.canShowPreviousMonth = false;
        $(this.previous).hide();
      } else {
        this.canShowPreviousMonth = true;
        $(this.previous).show();
      }
      firstDayOfNextMonth = new Date(cd.getFullYear(), cd.getMonth() + 1, 1);
      if ((this.settings.endDate != null) && firstDayOfNextMonth.getTime() > this.settings.endDate.getTime()) {
        this.canShowNextMonth = false;
        $(this.next).hide();
      } else {
        this.canShowNextMonth = true;
        $(this.next).show();
      }
      firstDayDow = (new Date(cd.getFullYear(), cd.getMonth(), 1)).getDay();
      lastDowIndex = (this.settings.firstDayOfTheWeekIndex + 6) % 7;
      daysInFirstWeek = (7 - firstDayDow + this.settings.firstDayOfTheWeekIndex) % 7;
      if (daysInFirstWeek === 0) daysInFirstWeek = 7;
      daysInPreviousMonth = lastDayOfPreviousMonth.getDate();
      date = new Date(cd.getFullYear(), cd.getMonth(), daysInFirstWeek - 6);
      daysInMonth = (new Date(cd.getFullYear(), cd.getMonth() + 1, 0)).getDate();
      weeks = Math.ceil((daysInMonth + 7 - daysInFirstWeek) / 7.0);
      renderDay = function(day) {
        var classAttribute, classes, liContent;
        classes = [];
        classAttribute = '';
        liContent = day.getDate();
        if (day.getMonth() !== cd.getMonth()) {
          classes.push(lw_dp_neighbour_month_day_class);
        }
        if (day.getDay() === 0 || day.getDay() === 6) {
          classes.push(lw_dp_weekend_class);
        }
        if (day.getDay() === lastDowIndex) {
          classes.push(lw_dp_week_last_column_class);
        }
        if (compareDates(day, _this.todayDate) === 0) {
          classes.push(lw_dp_today_class);
          liContent = "<span>" + liContent + "</span>";
        }
        if ((_this.activeDate != null) && compareDates(day, _this.activeDate) === 0) {
          classes.push(lw_dp_active_day_class);
        }
        if (!_this._isDateInsidePeriod(date)) {
          classes.push(lw_dp_out_of_interval_class);
          liContent = '';
        }
        if (classes.length) {
          classAttribute = " class='" + (classes.join(" ")) + "'";
        }
        day.setDate(day.getDate() + 1);
        return "<li" + classAttribute + ">" + liContent + "</li>";
      };
      html = '';
      for (week = _i = 1; 1 <= weeks ? _i <= weeks : _i >= weeks; week = 1 <= weeks ? ++_i : --_i) {
        if (week === 1) {
          html += "<ul class='" + lw_dp_week_class + " " + lw_dp_firstweek_class + "'>";
        } else if (week === weeks) {
          html += "<ul class='" + lw_dp_week_class + " " + lw_dp_lastweek_class + "'>";
        } else {
          html += "<ul class=" + lw_dp_week_class + ">";
        }
        for (day = _j = 1; _j <= 7; day = ++_j) {
          html += renderDay(date);
        }
        html += '</ul>';
      }
      return this.days.html(html);
    };

    LightweightDatepicker.prototype.setActiveDate = function(date) {
      var activeLi, oldDate;
      if (!isDateValid(date)) return false;
      if (!this._isDateInsidePeriod(date)) return false;
      oldDate = this.activeDate;
      this.activeDate = date;
      this.setCurrentDate(date);
      this.updateInput();
      if ((oldDate != null) && (date.getFullYear() === oldDate.getFullYear() && date.getMonth() === oldDate.getMonth())) {
        this.days.find("li." + lw_dp_active_day_class).removeClass(lw_dp_active_day_class);
        activeLi = this.days.find("li:not(." + lw_dp_neighbour_month_day_class + ")").filter(function() {
          return parseInt($(this).text(), 10) === date.getDate();
        });
        return activeLi.addClass(lw_dp_active_day_class);
      }
    };

    LightweightDatepicker.prototype.setCurrentDate = function(date) {
      this.currentDate = date;
      return this._updateMonth();
    };

    LightweightDatepicker.prototype._isDateInsidePeriod = function(date) {
      if ((this.settings.startDate != null) && (compareDates(date, this.settings.startDate) === -1)) {
        return false;
      }
      if ((this.settings.endDate != null) && (compareDates(date, this.settings.endDate) === 1)) {
        return false;
      }
      return true;
    };

    LightweightDatepicker.prototype._parseDate = function(string) {
      if (typeof this.settings.parseDate === 'function') {
        return this.settings.parseDate(string);
      } else {
        return new Date(Date.parse(string));
      }
    };

    LightweightDatepicker.prototype._formatDate = function(date) {
      if (!isDateValid(date)) return;
      if (typeof this.settings.formatDate === 'function') {
        return this.settings.formatDate(date);
      } else {
        if (date != null) {
          return (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
        } else {
          return '';
        }
      }
    };

    LightweightDatepicker.prototype._renderDows = function() {
      var day, first, found, html, name, temp, _i, _len, _ref;
      first = this.settings.dowNames[this.settings.firstDayOfTheWeekIndex];
      found = false;
      html = "<ul class=" + lw_dp_dows_class + ">";
      temp = '';
      _ref = this.settings.dowNames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if (name === first) found = true;
        day = "<li>" + name + "</li>";
        if (found) {
          html += day;
        } else {
          temp += day;
        }
      }
      html += temp;
      html += '</ul>';
      return $(html);
    };

    LightweightDatepicker.prototype.updatePosition = function() {
      var inputOffset, left, top, wrapperOuterHeight, wrapperOuterWidth;
      if (this.settings.alwaysVisible) {
        inputOffset = this.input.position();
      } else {
        inputOffset = this.input.offset();
      }
      wrapperOuterWidth = this.wrapper.outerWidth();
      wrapperOuterHeight = this.wrapper.outerHeight();
      left = inputOffset.left;
      if ($('body').width() > left + wrapperOuterWidth) {
        this.wrapper.css({
          'left': left
        });
      } else {
        if (inputOffset.left > wrapperOuterWidth + this.margin) {
          this.wrapper.css({
            'left': $('body').width() - wrapperOuterWidth + this.margin
          });
        } else {
          this.wrapper.css({
            'left': left
          });
        }
      }
      this.wrapper.removeClass('lw-dp-opposite-vertical');
      top = inputOffset.top + this.input.outerHeight() + this.margin;
      if ($(document).height() > top + wrapperOuterHeight) {
        return this.wrapper.css({
          'top': top
        });
      } else {
        if (inputOffset.top > wrapperOuterHeight + this.margin) {
          this.wrapper.css({
            'top': inputOffset.top - wrapperOuterHeight - this.margin
          });
          return this.wrapper.addClass('lw-dp-opposite-vertical');
        } else {
          return this.wrapper.css({
            'top': top
          });
        }
      }
    };

    LightweightDatepicker.prototype.hide = function() {
      var _ref;
      if (!this.settings.alwaysVisible && this.shouldHide) this.wrapper.detach();
      if (!this.shouldHide) if ((_ref = this.input) != null) _ref.focus();
      return this.shouldHide = true;
    };

    LightweightDatepicker.prototype.show = function() {
      if (!this.settings.alwaysVisible) this.wrapper.appendTo(document.body);
      this.updatePosition();
      return this._updateMonth();
    };

    LightweightDatepicker.prototype.showPreviousMonth = function() {
      return this.setCurrentDate(new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() - 1, this.currentDate.getDate()));
    };

    LightweightDatepicker.prototype.showNextMonth = function() {
      return this.setCurrentDate(new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, this.currentDate.getDate()));
    };

    LightweightDatepicker.prototype._handleKeyDown = function(e) {
      var handled, keyCode, newDate, selectionEnd, selectionStart;
      keyCode = e.keyCode;
      handled = true;
      selectionStart = this.input[0].selectionStart;
      selectionEnd = this.input[0].selectionEnd;
      switch (keyCode) {
        case 27:
          this.input.blur();
          return false;
        case 33:
          newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() - 1, this.activeDate.getDate());
          while (newDate.getMonth() === this.activeDate.getMonth()) {
            newDate.setDate(newDate.getDate() - 1);
          }
          this.setActiveDate(newDate);
          break;
        case 34:
          newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + 1, this.activeDate.getDate());
          while (newDate.getMonth() === this.activeDate.getMonth() + 2) {
            newDate.setDate(newDate.getDate() - 1);
          }
          this.setActiveDate(newDate);
          break;
        case 38:
          this.setActiveDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth(), this.activeDate.getDate() - 1));
          break;
        case 40:
          this.setActiveDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth(), this.activeDate.getDate() + 1));
          break;
        default:
          handled = false;
      }
      this.input[0].selectionStart = selectionStart;
      this.input[0].selectionEnd = selectionEnd;
      return !handled;
    };

    LightweightDatepicker.prototype.destroy = function() {
      this.toolbar.undelegate();
      this.days.undelegate();
      this.input.unbind('focus', this.show);
      this.input.unbind('blur', this.hide);
      this.input.unbind('keydown', this._handleKeyDown);
      this.input.unbind('change', this._onChange);
      this.input.unbind('click', this._onClick);
      this.input.data(lw_dp_data_key, null);
      return this.input = null;
    };

    return LightweightDatepicker;

  })();

  $.fn['lwDatepicker'] = function(options) {
    options = $.extend({}, settings, options);
    return this.each(function() {
      var $el;
      $el = $(this);
      if (($el.is('input, textarea')) && !$el.data(lw_dp_data_key)) {
        return new LightweightDatepicker($el, options);
      }
    });
  };

  $.fn['lwDatepicker']['setDefaultOptions'] = function(options) {
    if (options == null) options = {};
    return settings = $.extend(settings, options);
  };

}).call(this);
/*
*   Knockout Validation
*   Created By Eric M. Barnard (https://github.com/ericmbarnard)
*
*   Source: https://github.com/ericmbarnard/Knockout-Validation
*   MIT License: http://www.opensource.org/licenses/MIT
*/
(function () {

    if (typeof (ko) === undefined) { throw 'Knockout is required, please ensure it is loaded before loading this validation plug-in'; }

    var configuration = {
        registerExtenders: true,
        messagesOnModified: true,
        messageTemplate: null,
        insertMessages: true,
        parseInputAttributes: false,
        decorateElement: false,         //false to keep backward compatibility
        errorClass: null,               //single class for error message and element
        errorElementClass: 'validationElement',  //class to decorate error element
        errorMessageClass: 'validationMessage',  //class to decorate error message
        grouping: {
            deep: false,        //by default grouping is shallow
            observable: true    //and using observables
        }
    };

    var html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];

    var async = function (expr) {
        if (window.setImmediate) { window.setImmediate(expr); }
        else { window.setTimeout(expr, 0); }
    };

    //#region Utilities

    var utils = (function () {
        var seedId = new Date().getTime();

        var domData = {}; //hash of data objects that we reference from dom elements
        var domDataKey = '__ko_validation__';

        return {
            isArray: function (o) {
                return o.isArray || Object.prototype.toString.call(o) === '[object Array]';
            },
            isObject: function (o) {
                return o !== null && typeof o === 'object';
            },
            values: function (o) {
                var r = [];
                for (var i in o) {
                    if (o.hasOwnProperty(i)) {
                        r.push(o[i]);
                    }
                }
                return r;
            },
            getValue: function (o) {
                return (typeof o === 'function' ? o() : o);
            },
            hasAttribute: function (node, attr) {
                return node.getAttribute(attr) !== null;
            },
            isValidatable: function (o) {
                return o.rules && o.isValid && o.isModified;
            },
            insertAfter: function (node, newNode) {
                node.parentNode.insertBefore(newNode, node.nextSibling);
            },
            newId: function () {
                return seedId += 1;
            },
            getConfigOptions: function (element) {
                var options = utils.contextFor(element);

                return options || configuration;
            },
            setDomData: function (node, data) {
                var key = node[domDataKey];

                if (!key) {
                    node[domDataKey] = key = utils.newId();
                }

                domData[key] = data;
            },
            getDomData: function (node) {
                var key = node[domDataKey];

                if (!key) {
                    return undefined;
                }

                return domData[key];
            },
            contextFor: function (node) {
                switch (node.nodeType) {
                    case 1:
                    case 8:
                        var context = utils.getDomData(node);
                        if (context) return context;
                        if (node.parentNode) return utils.contextFor(node.parentNode);
                        break;
                }
                return undefined;
            },
            isEmptyVal: function (val) {
                if (val === undefined) {
                    return true;
                }
                if (val === null) {
                    return true;
                }
                if (val === "") {
                    return true;
                }
            }
        };
    } ());

    //#endregion

    //#region Public API
    ko.validation = (function () {

        var isInitialized = 0;

        return {
            utils: utils,

            //Call this on startup
            //any config can be overridden with the passed in options
            init: function (options, force) {
                //done run this multiple times if we don't really want to
                if (isInitialized > 0 && !force) {
                    return;
                }

                //becuase we will be accessing options properties it has to be an object at least
                options = options || {};
                //if specific error classes are not provided then apply generic errorClass
                //it has to be done on option so that options.errorClass can override default 
                //errorElementClass and errorMessage class but not those provided in options            
                options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;
                options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;

                ko.utils.extend(configuration, options);

                if (configuration.registerExtenders) {
                    ko.validation.registerExtenders();
                }

                isInitialized = 1;
            },
            //backwards compatability
            configure: function (options) { ko.validation.init(options); },

            group: function group(obj, options) { // array of observables or viewModel
                var options = ko.utils.extend(configuration.grouping, options),
                validatables = ko.observableArray([]),
                result = null,

                //anonymous, immediate function to traverse objects hierarchically
                //if !options.deep then it will stop on top level
                traverse = function traverse(obj, level) {
                    var objValues = [],
                        val = ko.utils.unwrapObservable(obj);

                    //default level value depends on deep option. 
                    level = (level !== undefined ? level : options.deep ? 1 : -1);

                    // if object is observable then add it to the list
                    if (ko.isObservable(obj)) {

                        //make sure it is validatable object
                        if (!obj.isValid) obj.extend({ validatable: true });
                        validatables.push(obj);
                    }

                    //get list of values either from array or object but ignore non-objects
                    if (val) {
                        if (utils.isArray(val)) {
                            objValues = val;
                        } else if (utils.isObject(val)) {
                            objValues = utils.values(val);
                        }
                    }

                    //process recurisvely if it is deep grouping
                    if (level !== 0) {
                        ko.utils.arrayForEach(objValues, function (observable) {

                            //but not falsy things and not HTML Elements
                            if (observable && !observable.nodeType) traverse(observable, level + 1);
                        });
                    }
                };

                //if using observables then traverse structure once and add observables
                if (options.observable) {

                    traverse(obj);

                    result = ko.computed(function () {
                        var errors = [];
                        ko.utils.arrayForEach(validatables(), function (observable) {
                            if (!observable.isValid()) {
                                errors.push(observable.error);
                            }
                        });
                        return errors;
                    });

                } else { //if not using observables then every call to error() should traverse the structure
                    result = function () {
                        var errors = [];
                        validatables([]); //clear validatables
                        traverse(obj); // and traverse tree again
                        ko.utils.arrayForEach(validatables(), function (observable) {
                            if (!observable.isValid()) {
                                errors.push(observable.error);
                            }
                        });
                        return errors;
                    };


                }

                result.showAllMessages = function (show) { // thanks @heliosPortal
                    if (show == undefined) //default to true
                        show = true;

                    // ensure we have latest changes
                    result();

                    ko.utils.arrayForEach(validatables(), function (observable) {
                        observable.isModified(show);
                        observable.notifySubscribers();
                    });
                };

                obj.errors = result;
                obj.isValid = function () {
                    return obj.errors().length === 0;
                }

                return result;
            },

            formatMessage: function (message, params) {
                return message.replace(/\{0\}/gi, params);
            },

            // addRule: 
            // This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator
            // ie: ko.validation.addRule(myObservable, {
            //          rule: 'required',
            //          params: true
            //      });
            //
            addRule: function (observable, rule) {
                observable.extend({ validatable: true });

                //push a Rule Context to the observables local array of Rule Contexts
                observable.rules.push(rule);
                return observable;
            },

            // addAnonymousRule:
            // Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property
            // and developers typically are wanting to add them on the fly or not register a rule with the 'ko.validation.rules' object
            //
            // Example:
            // var test = ko.observable('something').extend{(
            //      validation: {
            //          validator: function(val, someOtherVal){
            //              return true;
            //          },
            //          message: "Something must be really wrong!',
            //          params: true
            //      }
            //  )};
            addAnonymousRule: function (observable, ruleObj) {
                var ruleName = utils.newId();

                //Create an anonymous rule to reference
                ko.validation.rules[ruleName] = {
                    validator: ruleObj.validator,
                    message: ruleObj.message || 'Error'
                };

                //add the anonymous rule to the observable
                ko.validation.addRule(observable, {
                    rule: ruleName,
                    params: ruleObj.params
                });
            },

            addExtender: function (ruleName) {
                ko.extenders[ruleName] = function (observable, params) {
                    //params can come in a few flavors
                    // 1. Just the params to be passed to the validator
                    // 2. An object containing the Message to be used and the Params to pass to the validator
                    //
                    // Example:
                    // var test = ko.observable(3).extend({
                    //      max: {
                    //          message: 'This special field has a Max of {0}',
                    //          params: 2
                    //      }
                    //  )};
                    //
                    if (params.message) { //if it has a message object, then its an object literal to use
                        return ko.validation.addRule(observable, {
                            rule: ruleName,
                            message: params.message,
                            params: params.params || true
                        });
                    } else {
                        return ko.validation.addRule(observable, {
                            rule: ruleName,
                            params: params
                        });
                    }
                };
            },

            // loops through all ko.validation.rules and adds them as extenders to 
            // ko.extenders
            registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts
                if (configuration.registerExtenders) {
                    for (var ruleName in ko.validation.rules) {
                        if (ko.validation.rules.hasOwnProperty(ruleName)) {
                            if (!ko.extenders[ruleName]) {
                                ko.validation.addExtender(ruleName);
                            }
                        }
                    }
                }
            },

            //creates a span next to the @element with the specified error class
            insertValidationMessage: function (element) {
                var span = document.createElement('SPAN');
                span.className = configuration.errorMessageClass;
                utils.insertAfter(element, span);
                return span;
            },

            // if html-5 validation attributes have been specified, this parses
            // the attributes on @element
            parseInputValidationAttributes: function (element, valueAccessor) {
                ko.utils.arrayForEach(html5Attributes, function (attr) {
                    if (utils.hasAttribute(element, attr)) {
                        ko.validation.addRule(valueAccessor(), {
                            rule: attr,
                            params: element.getAttribute(attr) || true
                        });
                    }
                });
            }
        };
    } ());
    //#endregion

    //#region Core Validation Rules

    //Validation Rules:
    // You can view and override messages or rules via:
    // ko.validation.rules[ruleName] 
    // 
    // To implement a custom Rule, simply use this template:
    // ko.validation.rules['<custom rule name>'] = {
    //      validator: function (val, param) {
    //          <custom logic>
    //          return <true or false>;
    //      },
    //      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'
    // };
    //
    // Example:
    // ko.validation.rules['mustEqual'] = {
    //      validator: function( val, mustEqualVal ){
    //          return val === mustEqualVal;
    //      }, 
    //      message: 'This field must equal {0}'
    // };
    //
    ko.validation.rules = {};
    ko.validation.rules['required'] = {
        validator: function (val, required) {
            var stringTrimRegEx = /^\s+|\s+$/g,
                testVal;

            if (val === undefined || val === null) {
                return !required;
            }

            testVal = val;
            if (typeof (val) == "string") {
                testVal = val.replace(stringTrimRegEx, '');
            }

            return required && (testVal + '').length > 0;
        },
        message: 'This field is required.'
    };

    ko.validation.rules['min'] = {
        validator: function (val, min) {
            return utils.isEmptyVal(val) || val >= min;
        },
        message: 'Please enter a value greater than or equal to {0}.'
    };

    ko.validation.rules['max'] = {
        validator: function (val, max) {
            return utils.isEmptyVal(val) || val <= max;
        },
        message: 'Please enter a value less than or equal to {0}.'
    };

    ko.validation.rules['minLength'] = {
        validator: function (val, minLength) {
            return utils.isEmptyVal(val) || val.length >= minLength;
        },
        message: 'Please enter at least {0} characters.'
    };

    ko.validation.rules['maxLength'] = {
        validator: function (val, maxLength) {
            return utils.isEmptyVal(val) || val.length <= maxLength;
        },
        message: 'Please enter no more than {0} characters.'
    };

    ko.validation.rules['pattern'] = {
        validator: function (val, regex) {
            return utils.isEmptyVal(val) || val.match(regex) != null;
        },
        message: 'Please check this value.'
    };

    ko.validation.rules['step'] = {
        validator: function (val, step) {
            return utils.isEmptyVal(val) || val % step === 0;
        },
        message: 'The value must increment by {0}'
    };

    ko.validation.rules['email'] = {
        validator: function (val, validate) {
            //I think an empty email address is also a valid entry
            //if one want's to enforce entry it should be done with 'required: true'
            return utils.isEmptyVal(val) || (
                validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)
            );
        },
        message: '{0} is not a proper email address'
    };

    ko.validation.rules['date'] = {
        validator: function (value, validate) {
            return utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));
        },
        message: 'Please enter a proper date'
    };

    ko.validation.rules['dateISO'] = {
        validator: function (value, validate) {
            return utils.isEmptyVal(value) || (validate && /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value));
        },
        message: 'Please enter a proper date'
    };

    ko.validation.rules['number'] = {
        validator: function (value, validate) {
            return utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value));
        },
        message: 'Please enter a number'
    };

    ko.validation.rules['digit'] = {
        validator: function (value, validate) {
            return utils.isEmptyVal(value) || (validate && /^\d+$/.test(value));
        },
        message: 'Please enter a digit'
    };

    ko.validation.rules['phoneUS'] = {
        validator: function (phoneNumber, validate) {
            if (typeof (phoneNumber) !== 'string') { return false; }
            if (utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required
            phoneNumber = phoneNumber.replace(/\s+/g, "");
            return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
        },
        message: 'Please specify a valid phone number'
    };

    ko.validation.rules['equal'] = {
        validator: function (val, params) {
            var otherValue = params;
            return val === utils.getValue(otherValue);
        },
        message: 'Values must equal'
    };

    ko.validation.rules['notEqual'] = {
        validator: function (val, params) {
            var otherValue = params;
            return val !== utils.getValue(otherValue);
        },
        message: 'Please choose another value.'
    };

    //unique in collection
    // options are:
    //    collection: array or function returning (observable) array 
    //              in which the value has to be unique
    //    valueAccessor: function that returns value from an object stored in collection
    //              if it is null the value is compared directly
    //    external: set to true when object you are validating is automatically updating collection
    ko.validation.rules['unique'] = {
        validator: function (val, options) {
            var c = utils.getValue(options.collection),
                external = utils.getValue(options.externalValue),
                counter = 0;

            if (!val || !c) return true;

            ko.utils.arrayFilter(ko.utils.unwrapObservable(c), function (item) {
                if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) counter++;
            });
            // if value is external even 1 same value in collection means the value is not unique
            return counter < (external !== undefined && val !== external ? 1 : 2);
        },
        message: 'Please make sure the value is unique.'
    };


    //now register all of these!
    (function () {
        ko.validation.registerExtenders();
    } ());

    //#endregion

    //#region Knockout Binding Handlers
    //setup the 'init' bindingHandler override where we inject validation messages
    (function () {
        var init = ko.bindingHandlers.value.init;

        ko.bindingHandlers.value.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {

            init(element, valueAccessor, allBindingsAccessor);

            var config = utils.getConfigOptions(element);

            // parse html5 input validation attributes, optional feature
            if (config.parseInputAttributes) {
                async(function () { ko.validation.parseInputValidationAttributes(element, valueAccessor) });
            }

            //if requested insert message element and apply bindings
            if (config.insertMessages && utils.isValidatable(valueAccessor())) {
                var validationMessageElement = ko.validation.insertValidationMessage(element);
                if (config.messageTemplate) {
                    ko.renderTemplate(config.messageTemplate, { field: valueAccessor() }, null, validationMessageElement, 'replaceNode');
                } else {
                    ko.applyBindingsToNode(validationMessageElement, { validationMessage: valueAccessor() });
                }
            }
            //if requested add binding to decorate element	
            if (config.decorateElement && utils.isValidatable(valueAccessor())) {
                ko.applyBindingsToNode(element, { validationElement: valueAccessor() });
            }
        };
    } ());


    ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding
        update: function (element, valueAccessor) {
            var obsv = valueAccessor(),
                config = utils.getConfigOptions(element),
                val = ko.utils.unwrapObservable(obsv),
                msg = null,
                isModified = false,
                isValid = false;

            obsv.extend({ validatable: true });

            isModified = obsv.isModified();
            isValid = obsv.isValid();

            // create a handler to correctly return an error message
            var errorMsgAccessor = function () {
                if (!config.messagesOnModified || isModified) {
                    return isValid ? null : obsv.error;
                } else {
                    return null;
                }
            };

            //toggle visibility on validation messages when validation hasn't been evaluated, or when the object isValid
            var visiblityAccessor = function () {
                return isModified ? !isValid : false;
            };

            ko.bindingHandlers.text.update(element, errorMsgAccessor);
            ko.bindingHandlers.visible.update(element, visiblityAccessor);
        }
    };

    ko.bindingHandlers['validationElement'] = {
        update: function (element, valueAccessor) {
            var obsv = valueAccessor(),
                config = utils.getConfigOptions(element),
                val = ko.utils.unwrapObservable(obsv),
                msg = null,
                isModified = false,
                isValid = false;

            obsv.extend({ validatable: true });

            isModified = obsv.isModified();
            isValid = obsv.isValid();

            // create an evaluator function that will return something like:
            // css: { validationElement: true }
            var cssSettingsAccessor = function () {
                var css = {};

                var shouldShow = (isModified ? !isValid : false);

                if (!config.decorateElement) { shouldShow = false; }

                // css: { validationElement: false }
                css[config.errorElementClass] = shouldShow;

                return css;
            };

            //add or remove class on the element;
            ko.bindingHandlers.css.update(element, cssSettingsAccessor);
        }
    };

    // ValidationOptions:
    // This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements
    //
    // Example:
    // <div data-bind="validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}">
    //      <input type="text" data-bind="value: someValue"/>
    //      <input type="text" data-bind="value: someValue2"/>
    // </div>
    ko.bindingHandlers['validationOptions'] = (function () {
        return {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var options = ko.utils.unwrapObservable(valueAccessor());
                if (options) {
                    var newConfig = ko.utils.extend({}, configuration);
                    ko.utils.extend(newConfig, options);

                    //store the validation options on the node so we can retrieve it later
                    utils.setDomData(element, newConfig);
                }
            }
        };
    } ());
    //#endregion

    //#region Knockout Extenders

    // Validation Extender:
    // This is for creating custom validation logic on the fly
    // Example:
    // var test = ko.observable('something').extend{(
    //      validation: {
    //          validator: function(val, someOtherVal){
    //              return true;
    //          },
    //          message: "Something must be really wrong!',
    //          params: true
    //      }
    //  )};
    ko.extenders['validation'] = function (observable, rules) { // allow single rule or array
        ko.utils.arrayForEach(utils.isArray(rules) ? rules : [rules], function (rule) {
            // the 'rule' being passed in here has no name to identify a core Rule,
            // so we add it as an anonymous rule
            // If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples
            ko.validation.addAnonymousRule(observable, rule);
        });
        return observable;
    };

    //This is the extender that makes a Knockout Observable also 'Validatable'
    //examples include:
    // 1. var test = ko.observable('something').extend({validatable: true});
    // this will ensure that the Observable object is setup properly to respond to rules
    // 
    // 2. test.extend({validatable: false});
    // this will remove the validation properties from the Observable object should you need to do that.
    ko.extenders['validatable'] = function (observable, enable) {
        if (enable && !utils.isValidatable(observable)) {

            observable.error = null; // holds the error message, we only need one since we stop processing validators when one is invalid

            // observable.rules:
            // ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it
            //
            // Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }            
            observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation

            //in case async validation is occuring
            observable.isValidating = ko.observable(false);

            //the true holder of whether the observable is valid or not
            observable.__valid__ = ko.observable(true);

            observable.isModified = ko.observable(false);

            // we use a computed here to ensure that anytime a dependency changes, the 
            // validation logic evaluates
            var h_obsValidationTrigger = ko.computed(function () {
                var obs = observable(),
                    ruleContexts = observable.rules();

                ko.validation.validateObservable(observable);

                return true;
            });

            // a semi-protected observable  
            observable.isValid = ko.computed(function () {
                return observable.__valid__();
            });

            //subscribe to changes in the observable
            var h_change = observable.subscribe(function () {
                observable.isModified(true);
            });

            observable._disposeValidation = function () {
                //first dispose of the subscriptions
                observable.isValid.dispose();
                observable.rules.removeAll();
                observable.isModified._subscriptions['change'] = [];
                observable.isValidating._subscriptions['change'] = [];
                observable.__valid__._subscriptions['change'] = [];
                h_change.dispose();
                h_obsValidationTrigger.dispose();

                delete observable['rules'];
                delete observable['error'];
                delete observable['isValid'];
                delete observable['isValidating'];
                delete observable['__valid__'];
                delete observable['isModified'];
            };
        } else if (enable === false && utils.isValidatable(observable)) {

            if (observable._disposeValidation) {
                observable._disposeValidation();
            }
        }
        return observable;
    };

    function validateSync(observable, rule, ctx) {
        //Execute the validator and see if its valid
        if (!rule.validator(observable(), ctx.params || true)) { // default param is true, eg. required = true

            //not valid, so format the error message and stick it in the 'error' variable
            observable.error = ko.validation.formatMessage(ctx.message || rule.message, ctx.params);
            observable.__valid__(false);
            return false;
        } else {
            return true;
        }
    };

    function validateAsync(observable, rule, ctx) {
        observable.isValidating(true);

        var callBack = function (valObj) {
            var isValid = false,
                msg = '';

            if (!observable.__valid__()) {
                return; //if its already NOT valid, don't add to that
            }

            //we were handed back a complex object
            if (valObj['message']) {
                isValid = valObj.isValid;
                msg = valObj.message;
            } else {
                isValid = valObj;
            }

            if (isValid) {//its VALID, so don't mess up anything that may have happened synchronously earlier on
                return;
            }

            //not valid, so format the error message and stick it in the 'error' variable
            observable.error = ko.validation.formatMessage(msg || ctx.message || rule.message, ctx.params);
            observable.isValidating(false);
            observable.__valid__(isValid);
        }

        //fire the validator and hand it the callback
        rule.validator(observable(), ctx.params || true, callBack);
    };

    ko.validation.validateObservable = function (observable) {
        var i = 0,
            rule, // the rule validator to execute
            ctx, // the current Rule Context for the loop
            ruleContexts = observable.rules(), //cache for iterator
            len = ruleContexts.length; //cache for iterator  

        for (; i < len; i++) {

            //get the Rule Context info to give to the core Rule
            ctx = ruleContexts[i];

            //get the core Rule to use for validation
            rule = ko.validation.rules[ctx.rule];

            if (rule['async'] || ctx['async']) {
                //run async validation
                validateAsync(observable, rule, ctx);

            } else {
                //run normal sync validation
                if (!validateSync(observable, rule, ctx)) {
                    return false; //break out of the loop
                }
            }
        }
        //finally if we got this far, make the observable valid again!
        observable.error = null;
        observable.__valid__(true);
        return true;
    };

    //#endregion

    //#region Validated Observable

    ko.validatedObservable = function (initialValue) {
        if (!ko.validation.utils.isObject(initialValue)) { return ko.observable(initialValue).extend({ validatable: true }); }

        var obsv = ko.observable(initialValue);
        obsv.errors = ko.validation.group(initialValue);
        obsv.isValid = ko.computed(function () {
            return obsv.errors().length === 0;
        });

        return obsv;
    };

    //#endregion

    //#region Localization

    //quick function to override rule messages
    ko.validation.localize = function (msgTranslations) {

        var msg, rule;

        //loop the properties in the object and assign the msg to the rule
        for (rule in msgTranslations) {
            if (ko.validation.rules.hasOwnProperty(rule)) {
                ko.validation.rules[rule].message = msgTranslations[rule];
            }
        }
    };
    //#endregion

    //#region ApplyBindings Added Functionality
    ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {
        var len = arguments.length,
            node, config;

        if (len > 2) { // all parameters were passed
            node = rootNode;
            config = options;
        } else if (len < 2) {
            node = document.body;
        } else { //have to figure out if they passed in a root node or options
            if (arguments[1].nodeType) { //its a node
                node = rootNode;
            } else {
                config = arguments[1];
            }
        }

        ko.validation.init();

        if (config) { ko.validation.utils.setDomData(node, config); }

        ko.applyBindings(viewModel, rootNode);
    };

    //override the original applyBindings so that we can ensure all new rules and what not are correctly registered
    var origApplyBindings = ko.applyBindings;
    ko.applyBindings = function (viewModel, rootNode) {

        ko.validation.init();

        origApplyBindings(viewModel, rootNode);
    };

    //#endregion

})();(function () {
    // adds setWithoutValidation to observables
    var oldExtender = ko.extenders['validatable'];
    ko.extenders['validatable'] = function (observable, enable) {
        oldExtender(observable, enable);
        observable.setWithoutValidation = setWithoutValidation;
    };

    function setWithoutValidation(value) {
        var rules = observable.rules();
        observable.rules([]);
        observable(value);
        observable.isModified(false);
        observable.rules(rules);
    }
})();TF = window.TF || {};
TF.renderTemplate = function(name, target) {
    $(target).empty().append($('head script#template--Forms-' + name).html());
};ko.validation.rules['date'] = {
    validator: function (value, validate) {
        return !value || (validate && Dates.tryParseDate(value));
    },
    message: 'Please enter a proper date'
};(function () {
    addBindingHandler('display');
    addBindingHandler('textField');
    addBindingHandler('dateField');
    addBindingHandler('passwordField');
    addBindingHandler('selectField');
    addBindingHandler('radioField');
    addBindingHandler('booleanField');

    ko.bindingHandlers.field = {
        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var properties = valueAccessor();
            renderFieldTemplate(properties.type + 'Field', element, function () { return properties.value; }, valueAccessor, viewModel, bindingContext);
        }
    };

    function addBindingHandler(name) {
        ko.bindingHandlers[name] = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                renderFieldTemplate(name, element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
                return { controlsDescendantBindings: true };
            }
        };
    }

    function renderFieldTemplate(templateName, element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var data = allBindingsAccessor();
        data.value = valueAccessor();
        if (!ko.isObservable(data.value) && _.isFunction(data.value))
            data.value = data.value();

        var innerBindingContext = bindingContext.extend(data);
        ko.applyBindingsToDescendants(innerBindingContext, element);

        TF.renderTemplate(templateName, element);
        
        for (var i = 0; i < element.children.length; i++)
            ko.applyBindings(data, element.children[i]);
            
        var inputs = $(element).find('input');
        setIdAttribute();
        setFocus();
        clickFirstButtonOnEnterKey();

        // this is a bit of a hack
        function setFocus() {
            if (data.isDefault) // && !Configuration.mobile())
                setTimeout(function () {
                    inputs.focus();
                }, 100);
        }

        function clickFirstButtonOnEnterKey() {
            if (viewModel.__node)
                inputs.keyup(function (event) {
                    if (event.which === 13) {
                        $(event.target).change().blur();
                        var clickTarget = $(element).closest('.form').find('button:eq(0)');
                        if(clickTarget.length === 0 && viewModel.__node)
                            clickTarget = $(viewModel.__node.pane.element).find('button:eq(0)');
                        clickTarget.click();
                    }
                });
        }

        // it would be nicer if we could use the attr { id: id } binding in knockout, but the jQuery UI datepicker sets the id of elements, the attr binding then resets it.
        function setIdAttribute() {
            inputs.eq(0).attr('id', data.id);
        }
    };
})();ko.bindingHandlers.focus = {
    update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var context = viewModel.__context || bindingContext.$root.__context;
        if (context)
            $.when(context.renderOperation.promise).done(function () {
                setTimeout(function() {
                    $(element).focus();
                }, 100);
            });
    }
};(function () {
    ko.bindingHandlers.select = {
        update: function (element, valueAccessor, allBindingsAccessor) {
            var value = valueAccessor();
            var bindings = allBindingsAccessor();
            var source = ko.utils.unwrapObservable(bindings.source);
            var displayList = bindings.property ?
                _.map(source, function(item) {
                    return item[bindings.property];
                }) : 
                source.slice(0);

            displayList.splice(0, 0, [bindings.initialText || 'Select...']);

            setTimeout(function() {
                TF.renderTemplate('/Templates/select.list', element);
                ko.applyBindings({ source: displayList, change: change }, element.children[0]);
            });
            
            function change(binding, event) {
                var index = $(event.target).find('option:selected').index();
                if(ko.isObservable(value))
                    value(index ? source[index - 1] : null);
            }
        }
    };

    ko.bindingHandlers.label = {
        update: function (element, valueAccessor) {
            $(element).attr('label', ko.utils.unwrapObservable(valueAccessor()));
        }
    };
})();(function() {
    ko.bindingHandlers.validatedClick = {
        'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
            var newValueAccessor = function() {
                return validatedClick;
            };
            return ko.bindingHandlers.click.init(element, newValueAccessor, allBindingsAccessor, viewModel);

            function validatedClick(arg) {
                // ignore the embedded properties or they cause the validator to loop infinitely
                var target = $.extend(this, { __context: null, __node: null });
                var errors = ko.validation.group(target, { deep: true });
                if (errors().length > 0)
                    errors.showAllMessages();
                else
                    valueAccessor()(arg);
            }
        }
    };
})();//ko.bindingHandlers['validationMessage'] = {
//    init: function (element, valueAccessor) {
//        var id = uuid.v4();
//        var observable = valueAccessor();
//        var $parent = $(element).parent();
//        var $targetElement;

//        if ($parent.hasClass('display'))
//            $targetElement = $parent.parent().parent();
//        else {
//            var $prev = $(element).prev();
//            $targetElement = $prev.attr('type') === 'hidden' ? $prev.prev() : $prev;
//        }
//        var error = ko.observable();
//        var pane = TC.insertNodeAfter($targetElement, {
//            path: '/Common/tooltip',
//            data: { html: error, position: 'auto', target: $targetElement, timeout: 3000, topic: id }
//        });
//        $targetElement.next().addClass('validationMessage');
//        observable.subscribe(function () {
//            if (observable.isModified && observable.isModified()) {
//                TC.context().pubsub.publish(observable.isValid() ? 'tooltip.hide' : 'tooltip.show', { topic: id, immediate: true });
//                error(observable.error);
//            }
//        });
//        return { controlsDescendantBindings: true };
//    }
//};
$('head')
    .append('<script type="text/template" id="template--booleanField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display">\n        <input type="checkbox" data-bind="checked: value" />\n    </div>\n    <div style="clear: both"></div>\n</div>\n</script>');
$('head')
    .append('<script type="text/template" id="template--dateField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display">\n        <input type="text" class="datePicker" data-bind="value: value, restrictKeys: \'[^0-9\/]+\'" />\n    </div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--display"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display">\n        <span data-bind="text: value"></span>\n    </div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--passwordField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display">\n        <input type="password" data-bind="value: value"></input>\n    </div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--radioField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display" data-bind="foreach: items">\n        <label>\n            <input type="radio" data-bind="value: $data, checked: $parent.value, attr: { group: $parent.displayText.replace(/ /g, \'_\') }" />\n            <span data-bind="text: $data"></span>\n        </label>\n        &nbsp;\n    </div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--select"><select data-bind="foreach: source">\n    <optgroup data-bind="label: group, foreach: list">\n        <option data-bind="text: $data"></option>\n    </optgroup>\n</select></script>');
$('head')
    .append('<script type="text/template" id="template--select"><select data-bind="foreach: source, event: { change: change }">\n    <option data-bind="text: $data"></option>\n</select></script>');
$('head')
    .append('<script type="text/template" id="template--selectField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display" data-bind="pane: \'/Common/dropDown\', data: $data"></div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--textField"><div class="field">\n    <div class="label">\n        <span data-bind="text: displayText"></span>\n    </div>\n    <div class="display">\n        <input type="text" data-bind="value: value" />\n    </div>\n    <div style="clear: both"></div>\n</div></script>');
$('head')
    .append('<script type="text/template" id="template--validationMessage"><div data-bind="pane: \'/Common/tooltip\', data: { html: $data.field.error, autoShow: true, position: \'right\' }"></div></script>');
$('<style/>')
    .attr('class', '__tribe')
    .text('.lw-dp{position:absolute;z-index:100;overflow:hidden;cursor:default;width:141px;border-width:1px;border-style:solid;padding:4px;margin:5.5px;background:#45484d;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzQ1NDg0ZCIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAwMDAiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);background:-moz-linear-gradient(top,rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0%,rgba(69,72,77,1)),color-stop(100%,rgba(0,0,0,1)));background:-webkit-linear-gradient(top,rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);background:-o-linear-gradient(top,rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);background:-ms-linear-gradient(top,rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);background:linear-gradient(top,rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#45484d\',endColorstr=\'#000000\',GradientType=0);border-radius:6px;-moz-border-radius:6px;-webkit-border-radius:6px;box-shadow:3px 3px 3px rgba(0,0,0,.3);-moz-box-shadow:3px 3px 3px rgba(0,0,0,.3);-webkit-box-shadow:3px 3px 3px rgba(0,0,0,.3);-moz-user-select:none;-webkit-user-select:none;-o-user-select:none;user-select:none}.lw-dp-hidden{display:none;box-shadow:none}.lw-dp-toolbar{text-align:center;overflow:hidden;font-size:12px;line-height:18px;color:#ddd;padding:0 0 2.2px}.lw-dp-month{display:inline-block;width:103px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.lw-dp-previous,.lw-dp-next{position:absolute;overflow:hidden;top:8px;width:0;height:0;color:#ddd;cursor:pointer;border-top:5.938px solid transparent;border-bottom:5.938px solid transparent}.lw-dp-previous{left:8px;border-right:11.875px solid #ddd}.lw-dp-next{right:8px;border-left:11.875px solid #ddd}.lw-dp-previous:hover{border-right-color:#797979}.lw-dp-next:hover{border-left-color:#797979}.lw-dp-previous:active{border-right-color:#acacac}.lw-dp-next:active{border-left-color:#acacac}.lw-dp-dows{padding:0;margin:0;overflow:hidden}.lw-dp-dows li,.lw-dp-week li{display:block;float:left;padding:0;margin:0;text-align:center;color:#fff}.lw-dp-dows li{font-size:9px;line-height:7.7px;width:20px;height:10px;padding:0;margin:0}.lw-dp-week{padding:0;margin:0;overflow:hidden}.lw-dp-week li{padding:0;margin:0;border-width:0;font-size:11px;color:#000;width:19px;height:19px;line-height:19px;background:#e0e0e0;border-left-width:1px;border-top-width:1px;border-style:solid;border-color:#f9f9f9;cursor:pointer}.lw-dp-dows-last-column,.lw-dp-week-last-column{border-right-width:1px}.lw-dp-lastweek li{padding:0;margin:0;border-bottom-width:1px}.lw-dp-firstweek li:first-child{-moz-border-radius:4px 0 0 0;-webkit-border-radius:4px 0 0 0;-o-border-radius:4px 0 0 0;-ms-border-radius:4px 0 0 0;-khtml-border-radius:4px 0 0 0;border-radius:4px 0 0 0}.lw-dp-firstweek li:last-child{-moz-border-radius:0 4px 0 0;-webkit-border-radius:0 4px 0 0;-o-border-radius:0 4px 0 0;-ms-border-radius:0 4px 0 0;-khtml-border-radius:0 4px 0 0;border-radius:0 4px 0 0}.lw-dp-lastweek li:first-child{-moz-border-radius:0 0 0 4px;-webkit-border-radius:0 0 0 4px;-o-border-radius:0 0 0 4px;-ms-border-radius:0 0 0 4px;-khtml-border-radius:0 0 0 4px;border-radius:0 0 0 4px}.lw-dp-lastweek li:last-child{-moz-border-radius:0 0 4px 0;-webkit-border-radius:0 0 4px 0;-o-border-radius:0 0 4px 0;-ms-border-radius:0 0 4px 0;-khtml-border-radius:0 0 4px 0;border-radius:0 0 4px 0}.lw-dp-week li:hover{background:#f4f4f4}li.lw-dp-weekend{background:#d0d0d0}li.lw-dp-today{-moz-border-radius:2px;-webkit-border-radius:2px;-o-border-radius:2px;-ms-border-radius:2px;-khtml-border-radius:2px;border-radius:2px}li.lw-dp-today span{display:block;width:17px;height:17px;line-height:17px;border:1px solid #acacac;-moz-border-radius:2px;-webkit-border-radius:2px;-o-border-radius:2px;-ms-border-radius:2px;-khtml-border-radius:2px;border-radius:2px}li.lw-dp-today:hover span{color:#797979}li.lw-dp-active-day,li.lw-dp-active-day:hover{position:relative;color:#f9f9f9;background:#797979}li.lw-dp-active-day:nth-child(n),li.lw-dp-active-day:hover:nth-child(n){background:none}li.lw-dp-active-day::before,li.lw-dp-active-day:hover::before{position:absolute;left:0;top:0;bottom:0;right:0;content:\'\';-moz-border-radius:2px;-webkit-border-radius:2px;-o-border-radius:2px;-ms-border-radius:2px;-khtml-border-radius:2px;border-radius:2px;background:#797979;z-index:-1}li.lw-dp-active-day:hover span{background:#e0e0e0}li.lw-dp-neighbour-month-day{color:#b9b9b9}li.lw-dp-out-of-interval,li.lw-dp-out-of-interval:hover{background:#ececec;cursor:default}')
    .appendTo('head');
$('<style/>')
    .attr('class', '__tribe')
    .text('.field{clear:left;padding-top:5px}.label{float:left;width:150px}.display{float:left;position:relative}.fieldColumn{float:left}.fieldColumn:nth-child(n+2){padding-left:20px}.validationMessage{display:inline;color:#fa8072}.validationMessage .tooltipContent{padding:1px 5px;border:1px solid #4f0707;white-space:nowrap;background:#ad1111}.desktop .validationMessage .tooltipContent{background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2FkMTExMSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiM0ZjA3MDciIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);background:-moz-linear-gradient(top,rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0%,rgba(173,17,17,1)),color-stop(100%,rgba(79,7,7,1)));background:-webkit-linear-gradient(top,rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);background:-o-linear-gradient(top,rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);background:-ms-linear-gradient(top,rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);background:linear-gradient(top,rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\'#ad1111\',endColorstr=\'#4f0707\',GradientType=0)}.validationElement{border:2px solid red!important}')
    .appendTo('head');
