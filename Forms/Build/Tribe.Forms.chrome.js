window.eval("// Generated by CoffeeScript 1.2.1-pre\n\n/*!\n * Lightweight DatePicker - jQuery Plugin\n * Provides themeable and customizable date picker\n *\n * Â© 2011 Maxim Zhukov (zhkv.mxm@gmail.com)\n * \n * Version: 1.1\n * Requires: jQuery v1.6+\n *\n * Dual licensed under the MIT and GPL licenses:\n *   http://www.opensource.org/licenses/mit-license.php\n *   http://www.gnu.org/licenses/gpl.html\n*/\n\n\n(function() {\n  var $, LightweightDatepicker, compareDates, isDateValid, lw_dp_active_day_class, lw_dp_class, lw_dp_data_key, lw_dp_dows_class, lw_dp_dows_last_column_class, lw_dp_firstweek_class, lw_dp_hidden_class, lw_dp_lastweek_class, lw_dp_month_class, lw_dp_neighbour_month_day_class, lw_dp_next_class, lw_dp_out_of_interval_class, lw_dp_previous_class, lw_dp_today_class, lw_dp_toolbar_class, lw_dp_week_class, lw_dp_week_last_column_class, lw_dp_weekend_class, settings,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  $ = jQuery;\n\n  settings = {\n    'startDate': null,\n    'endDate': null,\n    'dowNames': ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n    'monthNames': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n    'firstDayOfTheWeekIndex': 0,\n    'autoFillToday': false,\n    'alwaysVisible': false,\n    'autoHideAfterClick': false,\n    'parseDate': null,\n    'formatDate': null,\n    'onChange': null\n  };\n\n  lw_dp_class = 'lw-dp';\n\n  lw_dp_active_day_class = 'lw-dp-active-day';\n\n  lw_dp_dows_class = 'lw-dp-dows';\n\n  lw_dp_dows_last_column_class = 'lw-dp-dows-last-column';\n\n  lw_dp_firstweek_class = 'lw-dp-firstweek';\n\n  lw_dp_hidden_class = 'lw-dp-hidden';\n\n  lw_dp_lastweek_class = 'lw-dp-lastweek';\n\n  lw_dp_month_class = 'lw-dp-month';\n\n  lw_dp_neighbour_month_day_class = 'lw-dp-neighbour-month-day';\n\n  lw_dp_next_class = 'lw-dp-next';\n\n  lw_dp_out_of_interval_class = 'lw-dp-out-of-interval';\n\n  lw_dp_previous_class = 'lw-dp-previous';\n\n  lw_dp_today_class = 'lw-dp-today';\n\n  lw_dp_toolbar_class = 'lw-dp-toolbar';\n\n  lw_dp_week_class = 'lw-dp-week';\n\n  lw_dp_week_last_column_class = 'lw-dp-week-last-column';\n\n  lw_dp_weekend_class = 'lw-dp-weekend';\n\n  lw_dp_data_key = 'lw-datepicker';\n\n  compareDates = function(date1, date2) {\n    if (date1.getFullYear() < date2.getFullYear()) return -1;\n    if (date1.getFullYear() > date2.getFullYear()) return 1;\n    if (date1.getMonth() < date2.getMonth()) return -1;\n    if (date1.getMonth() > date2.getMonth()) return 1;\n    if (date1.getDate() < date2.getDate()) return -1;\n    if (date1.getDate() > date2.getDate()) return 1;\n    return 0;\n  };\n\n  isDateValid = function(date) {\n    if (Object.prototype.toString.call(date) !== '[object Date]') return false;\n    return !isNaN(date.getTime());\n  };\n\n  LightweightDatepicker = (function() {\n\n    LightweightDatepicker.name = 'LightweightDatepicker';\n\n    LightweightDatepicker.prototype.canShowPreviousMonth = true;\n\n    LightweightDatepicker.prototype.canShowNextMonth = true;\n\n    LightweightDatepicker.prototype.shouldHide = true;\n\n    function LightweightDatepicker(el, settings) {\n      this.destroy = __bind(this.destroy, this);\n\n      this._handleKeyDown = __bind(this._handleKeyDown, this);\n\n      this.showNextMonth = __bind(this.showNextMonth, this);\n\n      this.showPreviousMonth = __bind(this.showPreviousMonth, this);\n\n      this.show = __bind(this.show, this);\n\n      this.hide = __bind(this.hide, this);\n\n      this._isDateInsidePeriod = __bind(this._isDateInsidePeriod, this);\n\n      this.setCurrentDate = __bind(this.setCurrentDate, this);\n\n      this.setActiveDate = __bind(this.setActiveDate, this);\n\n      this._updateMonth = __bind(this._updateMonth, this);\n\n      this._getDateFromElement = __bind(this._getDateFromElement, this);\n\n      this._onChange = __bind(this._onChange, this);\n\n      this._onClick = __bind(this._onClick, this);\n      this.input = el;\n      this.input.bind('focus', this.show);\n      this.input.bind('blur', this.hide);\n      this.input.bind('keydown', this._handleKeyDown);\n      this.input.bind('change', this._onChange);\n      this.input.bind('click', this._onClick);\n      this.isIE = $.browser.msie && parseInt($.browser.version, 10) <= 8;\n      this.input.data(lw_dp_data_key, this);\n      this.settings = {\n        startDate: settings['startDate'],\n        endDate: settings['endDate'],\n        dowNames: settings['dowNames'],\n        monthNames: settings['monthNames'],\n        firstDayOfTheWeekIndex: settings['firstDayOfTheWeekIndex'],\n        autoFillToday: settings['autoFillToday'],\n        alwaysVisible: settings['alwaysVisible'],\n        autoHideAfterClick: settings['autoHideAfterClick'],\n        parseDate: settings['parseDate'],\n        formatDate: settings['formatDate'],\n        onChange: settings['onChange']\n      };\n      this.todayDate = new Date;\n      this.currentDate = this.settings.startDate || new Date;\n      this._createDatepicker();\n      if (this.settings.autoFillToday && this._isDateInsidePeriod(new Date)) {\n        this.activeDate = new Date;\n      }\n      this.setActiveDate(this._parseDate(this.input.val()));\n      if (this.settings.alwaysVisible) {\n        this.wrapper.insertAfter(this.input);\n      } else {\n        this.wrapper.appendTo(document.body);\n      }\n      this.margin = parseInt(this.wrapper.css('margin-top'), 10);\n      this.wrapper.css('margin', 0);\n      this._bindEvents();\n      if (this.settings.alwaysVisible) this.updatePosition();\n      this.updateInput();\n      this._updateMonth();\n      this.hide();\n    }\n\n    LightweightDatepicker.prototype._onClick = function() {\n      if (!$(\".\" + lw_dp_class).has(this.wrapper).length) return this.show();\n    };\n\n    LightweightDatepicker.prototype._onChange = function() {\n      if (this.updatingInput) return;\n      return this.setActiveDate(this._parseDate(this.input.val()));\n    };\n\n    LightweightDatepicker.prototype._createDatepicker = function() {\n      this.wrapper = $(\"<div class=\" + lw_dp_class + \"/>\");\n      this.toolbar = $(\"<div class=\" + lw_dp_toolbar_class + \"/>\").appendTo(this.wrapper);\n      this.previous = $(\"<div class=\" + lw_dp_previous_class + \"/>\").appendTo(this.toolbar);\n      this.next = $(\"<div class=\" + lw_dp_next_class + \"/>\").appendTo(this.toolbar);\n      this.month = $(\"<div class=\" + lw_dp_month_class + \"/>\").appendTo(this.toolbar);\n      this._renderDows().appendTo(this.wrapper);\n      return this.days = $('<div/>').appendTo(this.wrapper);\n    };\n\n    LightweightDatepicker.prototype._bindEvents = function() {\n      var event,\n        _this = this;\n      this.wrapper.bind('mousedown touchstart', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (_this.isIE) return _this.shouldHide = false;\n      });\n      event = this.isIE ? 'mousedown' : 'click touchstart';\n      this.toolbar.delegate(\".\" + lw_dp_next_class, event, this.showNextMonth);\n      this.toolbar.delegate(\".\" + lw_dp_previous_class, event, this.showPreviousMonth);\n      return this.days.delegate(\"li:not(.\" + lw_dp_active_day_class + \"):not(.\" + lw_dp_out_of_interval_class + \")\", event, function(e) {\n        var currentLi;\n        currentLi = $(e.currentTarget);\n        _this.setActiveDate(_this._getDateFromElement(currentLi));\n        if (_this.settings.autoHideAfterClick) _this.hide();\n        if (typeof _this.settings.onChange === 'function') {\n          _this.settings.onChange(_this.activeDate, _this.input);\n        }\n        return false;\n      });\n    };\n\n    LightweightDatepicker.prototype._getDateFromElement = function(el) {\n      var currentDay, currentMonth, currentYear, diff;\n      currentDay = el.text();\n      currentYear = this.currentDate.getFullYear();\n      diff = 0;\n      if (el.hasClass(lw_dp_neighbour_month_day_class)) {\n        diff = currentDay > 10 ? -1 : 1;\n      }\n      currentMonth = this.currentDate.getMonth() + diff;\n      return new Date(currentYear, currentMonth, currentDay);\n    };\n\n    LightweightDatepicker.prototype.updateInput = function() {\n      this.input.val(this._formatDate(this.activeDate));\n      this.updatingInput = true;\n      this.input.trigger('change');\n      return this.updatingInput = false;\n    };\n\n    LightweightDatepicker.prototype._updateMonth = function() {\n      var cd, date, day, daysInFirstWeek, daysInMonth, daysInPreviousMonth, firstDayDow, firstDayOfNextMonth, html, lastDayOfPreviousMonth, lastDowIndex, renderDay, week, weeks, _i, _j,\n        _this = this;\n      this.month.html(this.settings.monthNames[this.currentDate.getMonth()] + ', ' + this.currentDate.getFullYear());\n      cd = this.currentDate;\n      lastDayOfPreviousMonth = new Date(cd.getFullYear(), cd.getMonth(), 0);\n      if ((this.settings.startDate != null) && lastDayOfPreviousMonth.getTime() < this.settings.startDate.getTime()) {\n        this.canShowPreviousMonth = false;\n        $(this.previous).hide();\n      } else {\n        this.canShowPreviousMonth = true;\n        $(this.previous).show();\n      }\n      firstDayOfNextMonth = new Date(cd.getFullYear(), cd.getMonth() + 1, 1);\n      if ((this.settings.endDate != null) && firstDayOfNextMonth.getTime() > this.settings.endDate.getTime()) {\n        this.canShowNextMonth = false;\n        $(this.next).hide();\n      } else {\n        this.canShowNextMonth = true;\n        $(this.next).show();\n      }\n      firstDayDow = (new Date(cd.getFullYear(), cd.getMonth(), 1)).getDay();\n      lastDowIndex = (this.settings.firstDayOfTheWeekIndex + 6) % 7;\n      daysInFirstWeek = (7 - firstDayDow + this.settings.firstDayOfTheWeekIndex) % 7;\n      if (daysInFirstWeek === 0) daysInFirstWeek = 7;\n      daysInPreviousMonth = lastDayOfPreviousMonth.getDate();\n      date = new Date(cd.getFullYear(), cd.getMonth(), daysInFirstWeek - 6);\n      daysInMonth = (new Date(cd.getFullYear(), cd.getMonth() + 1, 0)).getDate();\n      weeks = Math.ceil((daysInMonth + 7 - daysInFirstWeek) / 7.0);\n      renderDay = function(day) {\n        var classAttribute, classes, liContent;\n        classes = [];\n        classAttribute = '';\n        liContent = day.getDate();\n        if (day.getMonth() !== cd.getMonth()) {\n          classes.push(lw_dp_neighbour_month_day_class);\n        }\n        if (day.getDay() === 0 || day.getDay() === 6) {\n          classes.push(lw_dp_weekend_class);\n        }\n        if (day.getDay() === lastDowIndex) {\n          classes.push(lw_dp_week_last_column_class);\n        }\n        if (compareDates(day, _this.todayDate) === 0) {\n          classes.push(lw_dp_today_class);\n          liContent = \"<span>\" + liContent + \"</span>\";\n        }\n        if ((_this.activeDate != null) && compareDates(day, _this.activeDate) === 0) {\n          classes.push(lw_dp_active_day_class);\n        }\n        if (!_this._isDateInsidePeriod(date)) {\n          classes.push(lw_dp_out_of_interval_class);\n          liContent = '';\n        }\n        if (classes.length) {\n          classAttribute = \" class='\" + (classes.join(\" \")) + \"'\";\n        }\n        day.setDate(day.getDate() + 1);\n        return \"<li\" + classAttribute + \">\" + liContent + \"</li>\";\n      };\n      html = '';\n      for (week = _i = 1; 1 <= weeks ? _i <= weeks : _i >= weeks; week = 1 <= weeks ? ++_i : --_i) {\n        if (week === 1) {\n          html += \"<ul class='\" + lw_dp_week_class + \" \" + lw_dp_firstweek_class + \"'>\";\n        } else if (week === weeks) {\n          html += \"<ul class='\" + lw_dp_week_class + \" \" + lw_dp_lastweek_class + \"'>\";\n        } else {\n          html += \"<ul class=\" + lw_dp_week_class + \">\";\n        }\n        for (day = _j = 1; _j <= 7; day = ++_j) {\n          html += renderDay(date);\n        }\n        html += '</ul>';\n      }\n      return this.days.html(html);\n    };\n\n    LightweightDatepicker.prototype.setActiveDate = function(date) {\n      var activeLi, oldDate;\n      if (!isDateValid(date)) return false;\n      if (!this._isDateInsidePeriod(date)) return false;\n      oldDate = this.activeDate;\n      this.activeDate = date;\n      this.setCurrentDate(date);\n      this.updateInput();\n      if ((oldDate != null) && (date.getFullYear() === oldDate.getFullYear() && date.getMonth() === oldDate.getMonth())) {\n        this.days.find(\"li.\" + lw_dp_active_day_class).removeClass(lw_dp_active_day_class);\n        activeLi = this.days.find(\"li:not(.\" + lw_dp_neighbour_month_day_class + \")\").filter(function() {\n          return parseInt($(this).text(), 10) === date.getDate();\n        });\n        return activeLi.addClass(lw_dp_active_day_class);\n      }\n    };\n\n    LightweightDatepicker.prototype.setCurrentDate = function(date) {\n      this.currentDate = date;\n      return this._updateMonth();\n    };\n\n    LightweightDatepicker.prototype._isDateInsidePeriod = function(date) {\n      if ((this.settings.startDate != null) && (compareDates(date, this.settings.startDate) === -1)) {\n        return false;\n      }\n      if ((this.settings.endDate != null) && (compareDates(date, this.settings.endDate) === 1)) {\n        return false;\n      }\n      return true;\n    };\n\n    LightweightDatepicker.prototype._parseDate = function(string) {\n      if (typeof this.settings.parseDate === 'function') {\n        return this.settings.parseDate(string);\n      } else {\n        return new Date(Date.parse(string));\n      }\n    };\n\n    LightweightDatepicker.prototype._formatDate = function(date) {\n      if (!isDateValid(date)) return;\n      if (typeof this.settings.formatDate === 'function') {\n        return this.settings.formatDate(date);\n      } else {\n        if (date != null) {\n          return (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n        } else {\n          return '';\n        }\n      }\n    };\n\n    LightweightDatepicker.prototype._renderDows = function() {\n      var day, first, found, html, name, temp, _i, _len, _ref;\n      first = this.settings.dowNames[this.settings.firstDayOfTheWeekIndex];\n      found = false;\n      html = \"<ul class=\" + lw_dp_dows_class + \">\";\n      temp = '';\n      _ref = this.settings.dowNames;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        if (name === first) found = true;\n        day = \"<li>\" + name + \"</li>\";\n        if (found) {\n          html += day;\n        } else {\n          temp += day;\n        }\n      }\n      html += temp;\n      html += '</ul>';\n      return $(html);\n    };\n\n    LightweightDatepicker.prototype.updatePosition = function() {\n      var inputOffset, left, top, wrapperOuterHeight, wrapperOuterWidth;\n      if (this.settings.alwaysVisible) {\n        inputOffset = this.input.position();\n      } else {\n        inputOffset = this.input.offset();\n      }\n      wrapperOuterWidth = this.wrapper.outerWidth();\n      wrapperOuterHeight = this.wrapper.outerHeight();\n      left = inputOffset.left;\n      if ($('body').width() > left + wrapperOuterWidth) {\n        this.wrapper.css({\n          'left': left\n        });\n      } else {\n        if (inputOffset.left > wrapperOuterWidth + this.margin) {\n          this.wrapper.css({\n            'left': $('body').width() - wrapperOuterWidth + this.margin\n          });\n        } else {\n          this.wrapper.css({\n            'left': left\n          });\n        }\n      }\n      this.wrapper.removeClass('lw-dp-opposite-vertical');\n      top = inputOffset.top + this.input.outerHeight() + this.margin;\n      if ($(document).height() > top + wrapperOuterHeight) {\n        return this.wrapper.css({\n          'top': top\n        });\n      } else {\n        if (inputOffset.top > wrapperOuterHeight + this.margin) {\n          this.wrapper.css({\n            'top': inputOffset.top - wrapperOuterHeight - this.margin\n          });\n          return this.wrapper.addClass('lw-dp-opposite-vertical');\n        } else {\n          return this.wrapper.css({\n            'top': top\n          });\n        }\n      }\n    };\n\n    LightweightDatepicker.prototype.hide = function() {\n      var _ref;\n      if (!this.settings.alwaysVisible && this.shouldHide) this.wrapper.detach();\n      if (!this.shouldHide) if ((_ref = this.input) != null) _ref.focus();\n      return this.shouldHide = true;\n    };\n\n    LightweightDatepicker.prototype.show = function() {\n      if (!this.settings.alwaysVisible) this.wrapper.appendTo(document.body);\n      this.updatePosition();\n      return this._updateMonth();\n    };\n\n    LightweightDatepicker.prototype.showPreviousMonth = function() {\n      return this.setCurrentDate(new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() - 1, this.currentDate.getDate()));\n    };\n\n    LightweightDatepicker.prototype.showNextMonth = function() {\n      return this.setCurrentDate(new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, this.currentDate.getDate()));\n    };\n\n    LightweightDatepicker.prototype._handleKeyDown = function(e) {\n      var handled, keyCode, newDate, selectionEnd, selectionStart;\n      keyCode = e.keyCode;\n      handled = true;\n      selectionStart = this.input[0].selectionStart;\n      selectionEnd = this.input[0].selectionEnd;\n      switch (keyCode) {\n        case 27:\n          this.input.blur();\n          return false;\n        case 33:\n          newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() - 1, this.activeDate.getDate());\n          while (newDate.getMonth() === this.activeDate.getMonth()) {\n            newDate.setDate(newDate.getDate() - 1);\n          }\n          this.setActiveDate(newDate);\n          break;\n        case 34:\n          newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + 1, this.activeDate.getDate());\n          while (newDate.getMonth() === this.activeDate.getMonth() + 2) {\n            newDate.setDate(newDate.getDate() - 1);\n          }\n          this.setActiveDate(newDate);\n          break;\n        case 38:\n          this.setActiveDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth(), this.activeDate.getDate() - 1));\n          break;\n        case 40:\n          this.setActiveDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth(), this.activeDate.getDate() + 1));\n          break;\n        default:\n          handled = false;\n      }\n      this.input[0].selectionStart = selectionStart;\n      this.input[0].selectionEnd = selectionEnd;\n      return !handled;\n    };\n\n    LightweightDatepicker.prototype.destroy = function() {\n      this.toolbar.undelegate();\n      this.days.undelegate();\n      this.input.unbind('focus', this.show);\n      this.input.unbind('blur', this.hide);\n      this.input.unbind('keydown', this._handleKeyDown);\n      this.input.unbind('change', this._onChange);\n      this.input.unbind('click', this._onClick);\n      this.input.data(lw_dp_data_key, null);\n      return this.input = null;\n    };\n\n    return LightweightDatepicker;\n\n  })();\n\n  $.fn['lwDatepicker'] = function(options) {\n    options = $.extend({}, settings, options);\n    return this.each(function() {\n      var $el;\n      $el = $(this);\n      if (($el.is('input, textarea')) && !$el.data(lw_dp_data_key)) {\n        return new LightweightDatepicker($el, options);\n      }\n    });\n  };\n\n  $.fn['lwDatepicker']['setDefaultOptions'] = function(options) {\n    if (options == null) options = {};\n    return settings = $.extend(settings, options);\n  };\n\n}).call(this);\n\n//@ sourceURL=tribe://Dependencies/jquery.lw-datepicker.js");
window.eval("/*\n*   Knockout Validation\n*   Created By Eric M. Barnard (https://github.com/ericmbarnard)\n*\n*   Source: https://github.com/ericmbarnard/Knockout-Validation\n*   MIT License: http://www.opensource.org/licenses/MIT\n*/\n(function () {\n\n    if (typeof (ko) === undefined) { throw 'Knockout is required, please ensure it is loaded before loading this validation plug-in'; }\n\n    var configuration = {\n        registerExtenders: true,\n        messagesOnModified: true,\n        messageTemplate: null,\n        insertMessages: true,\n        parseInputAttributes: false,\n        decorateElement: false,         //false to keep backward compatibility\n        errorClass: null,               //single class for error message and element\n        errorElementClass: 'validationElement',  //class to decorate error element\n        errorMessageClass: 'validationMessage',  //class to decorate error message\n        grouping: {\n            deep: false,        //by default grouping is shallow\n            observable: true    //and using observables\n        }\n    };\n\n    var html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];\n\n    var async = function (expr) {\n        if (window.setImmediate) { window.setImmediate(expr); }\n        else { window.setTimeout(expr, 0); }\n    };\n\n    //#region Utilities\n\n    var utils = (function () {\n        var seedId = new Date().getTime();\n\n        var domData = {}; //hash of data objects that we reference from dom elements\n        var domDataKey = '__ko_validation__';\n\n        return {\n            isArray: function (o) {\n                return o.isArray || Object.prototype.toString.call(o) === '[object Array]';\n            },\n            isObject: function (o) {\n                return o !== null && typeof o === 'object';\n            },\n            values: function (o) {\n                var r = [];\n                for (var i in o) {\n                    if (o.hasOwnProperty(i)) {\n                        r.push(o[i]);\n                    }\n                }\n                return r;\n            },\n            getValue: function (o) {\n                return (typeof o === 'function' ? o() : o);\n            },\n            hasAttribute: function (node, attr) {\n                return node.getAttribute(attr) !== null;\n            },\n            isValidatable: function (o) {\n                return o.rules && o.isValid && o.isModified;\n            },\n            insertAfter: function (node, newNode) {\n                node.parentNode.insertBefore(newNode, node.nextSibling);\n            },\n            newId: function () {\n                return seedId += 1;\n            },\n            getConfigOptions: function (element) {\n                var options = utils.contextFor(element);\n\n                return options || configuration;\n            },\n            setDomData: function (node, data) {\n                var key = node[domDataKey];\n\n                if (!key) {\n                    node[domDataKey] = key = utils.newId();\n                }\n\n                domData[key] = data;\n            },\n            getDomData: function (node) {\n                var key = node[domDataKey];\n\n                if (!key) {\n                    return undefined;\n                }\n\n                return domData[key];\n            },\n            contextFor: function (node) {\n                switch (node.nodeType) {\n                    case 1:\n                    case 8:\n                        var context = utils.getDomData(node);\n                        if (context) return context;\n                        if (node.parentNode) return utils.contextFor(node.parentNode);\n                        break;\n                }\n                return undefined;\n            },\n            isEmptyVal: function (val) {\n                if (val === undefined) {\n                    return true;\n                }\n                if (val === null) {\n                    return true;\n                }\n                if (val === \"\") {\n                    return true;\n                }\n            }\n        };\n    } ());\n\n    //#endregion\n\n    //#region Public API\n    ko.validation = (function () {\n\n        var isInitialized = 0;\n\n        return {\n            utils: utils,\n\n            //Call this on startup\n            //any config can be overridden with the passed in options\n            init: function (options, force) {\n                //done run this multiple times if we don't really want to\n                if (isInitialized > 0 && !force) {\n                    return;\n                }\n\n                //becuase we will be accessing options properties it has to be an object at least\n                options = options || {};\n                //if specific error classes are not provided then apply generic errorClass\n                //it has to be done on option so that options.errorClass can override default \n                //errorElementClass and errorMessage class but not those provided in options            \n                options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;\n                options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;\n\n                ko.utils.extend(configuration, options);\n\n                if (configuration.registerExtenders) {\n                    ko.validation.registerExtenders();\n                }\n\n                isInitialized = 1;\n            },\n            //backwards compatability\n            configure: function (options) { ko.validation.init(options); },\n\n            group: function group(obj, options) { // array of observables or viewModel\n                var options = ko.utils.extend(configuration.grouping, options),\n                validatables = ko.observableArray([]),\n                result = null,\n\n                //anonymous, immediate function to traverse objects hierarchically\n                //if !options.deep then it will stop on top level\n                traverse = function traverse(obj, level) {\n                    var objValues = [],\n                        val = ko.utils.unwrapObservable(obj);\n\n                    //default level value depends on deep option. \n                    level = (level !== undefined ? level : options.deep ? 1 : -1);\n\n                    // if object is observable then add it to the list\n                    if (ko.isObservable(obj)) {\n\n                        //make sure it is validatable object\n                        if (!obj.isValid) obj.extend({ validatable: true });\n                        validatables.push(obj);\n                    }\n\n                    //get list of values either from array or object but ignore non-objects\n                    if (val) {\n                        if (utils.isArray(val)) {\n                            objValues = val;\n                        } else if (utils.isObject(val)) {\n                            objValues = utils.values(val);\n                        }\n                    }\n\n                    //process recurisvely if it is deep grouping\n                    if (level !== 0) {\n                        ko.utils.arrayForEach(objValues, function (observable) {\n\n                            //but not falsy things and not HTML Elements\n                            if (observable && !observable.nodeType) traverse(observable, level + 1);\n                        });\n                    }\n                };\n\n                //if using observables then traverse structure once and add observables\n                if (options.observable) {\n\n                    traverse(obj);\n\n                    result = ko.computed(function () {\n                        var errors = [];\n                        ko.utils.arrayForEach(validatables(), function (observable) {\n                            if (!observable.isValid()) {\n                                errors.push(observable.error);\n                            }\n                        });\n                        return errors;\n                    });\n\n                } else { //if not using observables then every call to error() should traverse the structure\n                    result = function () {\n                        var errors = [];\n                        validatables([]); //clear validatables\n                        traverse(obj); // and traverse tree again\n                        ko.utils.arrayForEach(validatables(), function (observable) {\n                            if (!observable.isValid()) {\n                                errors.push(observable.error);\n                            }\n                        });\n                        return errors;\n                    };\n\n\n                }\n\n                result.showAllMessages = function (show) { // thanks @heliosPortal\n                    if (show == undefined) //default to true\n                        show = true;\n\n                    // ensure we have latest changes\n                    result();\n\n                    ko.utils.arrayForEach(validatables(), function (observable) {\n                        observable.isModified(show);\n                        observable.notifySubscribers();\n                    });\n                };\n\n                obj.errors = result;\n                obj.isValid = function () {\n                    return obj.errors().length === 0;\n                }\n\n                return result;\n            },\n\n            formatMessage: function (message, params) {\n                return message.replace(/\\{0\\}/gi, params);\n            },\n\n            // addRule: \n            // This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator\n            // ie: ko.validation.addRule(myObservable, {\n            //          rule: 'required',\n            //          params: true\n            //      });\n            //\n            addRule: function (observable, rule) {\n                observable.extend({ validatable: true });\n\n                //push a Rule Context to the observables local array of Rule Contexts\n                observable.rules.push(rule);\n                return observable;\n            },\n\n            // addAnonymousRule:\n            // Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property\n            // and developers typically are wanting to add them on the fly or not register a rule with the 'ko.validation.rules' object\n            //\n            // Example:\n            // var test = ko.observable('something').extend{(\n            //      validation: {\n            //          validator: function(val, someOtherVal){\n            //              return true;\n            //          },\n            //          message: \"Something must be really wrong!',\n            //          params: true\n            //      }\n            //  )};\n            addAnonymousRule: function (observable, ruleObj) {\n                var ruleName = utils.newId();\n\n                //Create an anonymous rule to reference\n                ko.validation.rules[ruleName] = {\n                    validator: ruleObj.validator,\n                    message: ruleObj.message || 'Error'\n                };\n\n                //add the anonymous rule to the observable\n                ko.validation.addRule(observable, {\n                    rule: ruleName,\n                    params: ruleObj.params\n                });\n            },\n\n            addExtender: function (ruleName) {\n                ko.extenders[ruleName] = function (observable, params) {\n                    //params can come in a few flavors\n                    // 1. Just the params to be passed to the validator\n                    // 2. An object containing the Message to be used and the Params to pass to the validator\n                    //\n                    // Example:\n                    // var test = ko.observable(3).extend({\n                    //      max: {\n                    //          message: 'This special field has a Max of {0}',\n                    //          params: 2\n                    //      }\n                    //  )};\n                    //\n                    if (params.message) { //if it has a message object, then its an object literal to use\n                        return ko.validation.addRule(observable, {\n                            rule: ruleName,\n                            message: params.message,\n                            params: params.params || true\n                        });\n                    } else {\n                        return ko.validation.addRule(observable, {\n                            rule: ruleName,\n                            params: params\n                        });\n                    }\n                };\n            },\n\n            // loops through all ko.validation.rules and adds them as extenders to \n            // ko.extenders\n            registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts\n                if (configuration.registerExtenders) {\n                    for (var ruleName in ko.validation.rules) {\n                        if (ko.validation.rules.hasOwnProperty(ruleName)) {\n                            if (!ko.extenders[ruleName]) {\n                                ko.validation.addExtender(ruleName);\n                            }\n                        }\n                    }\n                }\n            },\n\n            //creates a span next to the @element with the specified error class\n            insertValidationMessage: function (element) {\n                var span = document.createElement('SPAN');\n                span.className = configuration.errorMessageClass;\n                utils.insertAfter(element, span);\n                return span;\n            },\n\n            // if html-5 validation attributes have been specified, this parses\n            // the attributes on @element\n            parseInputValidationAttributes: function (element, valueAccessor) {\n                ko.utils.arrayForEach(html5Attributes, function (attr) {\n                    if (utils.hasAttribute(element, attr)) {\n                        ko.validation.addRule(valueAccessor(), {\n                            rule: attr,\n                            params: element.getAttribute(attr) || true\n                        });\n                    }\n                });\n            }\n        };\n    } ());\n    //#endregion\n\n    //#region Core Validation Rules\n\n    //Validation Rules:\n    // You can view and override messages or rules via:\n    // ko.validation.rules[ruleName] \n    // \n    // To implement a custom Rule, simply use this template:\n    // ko.validation.rules['<custom rule name>'] = {\n    //      validator: function (val, param) {\n    //          <custom logic>\n    //          return <true or false>;\n    //      },\n    //      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'\n    // };\n    //\n    // Example:\n    // ko.validation.rules['mustEqual'] = {\n    //      validator: function( val, mustEqualVal ){\n    //          return val === mustEqualVal;\n    //      }, \n    //      message: 'This field must equal {0}'\n    // };\n    //\n    ko.validation.rules = {};\n    ko.validation.rules['required'] = {\n        validator: function (val, required) {\n            var stringTrimRegEx = /^\\s+|\\s+$/g,\n                testVal;\n\n            if (val === undefined || val === null) {\n                return !required;\n            }\n\n            testVal = val;\n            if (typeof (val) == \"string\") {\n                testVal = val.replace(stringTrimRegEx, '');\n            }\n\n            return required && (testVal + '').length > 0;\n        },\n        message: 'This field is required.'\n    };\n\n    ko.validation.rules['min'] = {\n        validator: function (val, min) {\n            return utils.isEmptyVal(val) || val >= min;\n        },\n        message: 'Please enter a value greater than or equal to {0}.'\n    };\n\n    ko.validation.rules['max'] = {\n        validator: function (val, max) {\n            return utils.isEmptyVal(val) || val <= max;\n        },\n        message: 'Please enter a value less than or equal to {0}.'\n    };\n\n    ko.validation.rules['minLength'] = {\n        validator: function (val, minLength) {\n            return utils.isEmptyVal(val) || val.length >= minLength;\n        },\n        message: 'Please enter at least {0} characters.'\n    };\n\n    ko.validation.rules['maxLength'] = {\n        validator: function (val, maxLength) {\n            return utils.isEmptyVal(val) || val.length <= maxLength;\n        },\n        message: 'Please enter no more than {0} characters.'\n    };\n\n    ko.validation.rules['pattern'] = {\n        validator: function (val, regex) {\n            return utils.isEmptyVal(val) || val.match(regex) != null;\n        },\n        message: 'Please check this value.'\n    };\n\n    ko.validation.rules['step'] = {\n        validator: function (val, step) {\n            return utils.isEmptyVal(val) || val % step === 0;\n        },\n        message: 'The value must increment by {0}'\n    };\n\n    ko.validation.rules['email'] = {\n        validator: function (val, validate) {\n            //I think an empty email address is also a valid entry\n            //if one want's to enforce entry it should be done with 'required: true'\n            return utils.isEmptyVal(val) || (\n                validate && /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(val)\n            );\n        },\n        message: '{0} is not a proper email address'\n    };\n\n    ko.validation.rules['date'] = {\n        validator: function (value, validate) {\n            return utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));\n        },\n        message: 'Please enter a proper date'\n    };\n\n    ko.validation.rules['dateISO'] = {\n        validator: function (value, validate) {\n            return utils.isEmptyVal(value) || (validate && /^\\d{4}[\\/-]\\d{1,2}[\\/-]\\d{1,2}$/.test(value));\n        },\n        message: 'Please enter a proper date'\n    };\n\n    ko.validation.rules['number'] = {\n        validator: function (value, validate) {\n            return utils.isEmptyVal(value) || (validate && /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)(?:\\.\\d+)?$/.test(value));\n        },\n        message: 'Please enter a number'\n    };\n\n    ko.validation.rules['digit'] = {\n        validator: function (value, validate) {\n            return utils.isEmptyVal(value) || (validate && /^\\d+$/.test(value));\n        },\n        message: 'Please enter a digit'\n    };\n\n    ko.validation.rules['phoneUS'] = {\n        validator: function (phoneNumber, validate) {\n            if (typeof (phoneNumber) !== 'string') { return false; }\n            if (utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required\n            phoneNumber = phoneNumber.replace(/\\s+/g, \"\");\n            return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\\([2-9]\\d{2}\\)|[2-9]\\d{2})-?[2-9]\\d{2}-?\\d{4}$/);\n        },\n        message: 'Please specify a valid phone number'\n    };\n\n    ko.validation.rules['equal'] = {\n        validator: function (val, params) {\n            var otherValue = params;\n            return val === utils.getValue(otherValue);\n        },\n        message: 'Values must equal'\n    };\n\n    ko.validation.rules['notEqual'] = {\n        validator: function (val, params) {\n            var otherValue = params;\n            return val !== utils.getValue(otherValue);\n        },\n        message: 'Please choose another value.'\n    };\n\n    //unique in collection\n    // options are:\n    //    collection: array or function returning (observable) array \n    //              in which the value has to be unique\n    //    valueAccessor: function that returns value from an object stored in collection\n    //              if it is null the value is compared directly\n    //    external: set to true when object you are validating is automatically updating collection\n    ko.validation.rules['unique'] = {\n        validator: function (val, options) {\n            var c = utils.getValue(options.collection),\n                external = utils.getValue(options.externalValue),\n                counter = 0;\n\n            if (!val || !c) return true;\n\n            ko.utils.arrayFilter(ko.utils.unwrapObservable(c), function (item) {\n                if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) counter++;\n            });\n            // if value is external even 1 same value in collection means the value is not unique\n            return counter < (external !== undefined && val !== external ? 1 : 2);\n        },\n        message: 'Please make sure the value is unique.'\n    };\n\n\n    //now register all of these!\n    (function () {\n        ko.validation.registerExtenders();\n    } ());\n\n    //#endregion\n\n    //#region Knockout Binding Handlers\n    //setup the 'init' bindingHandler override where we inject validation messages\n    (function () {\n        var init = ko.bindingHandlers.value.init;\n\n        ko.bindingHandlers.value.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n\n            init(element, valueAccessor, allBindingsAccessor);\n\n            var config = utils.getConfigOptions(element);\n\n            // parse html5 input validation attributes, optional feature\n            if (config.parseInputAttributes) {\n                async(function () { ko.validation.parseInputValidationAttributes(element, valueAccessor) });\n            }\n\n            //if requested insert message element and apply bindings\n            if (config.insertMessages && utils.isValidatable(valueAccessor())) {\n                var validationMessageElement = ko.validation.insertValidationMessage(element);\n                if (config.messageTemplate) {\n                    ko.renderTemplate(config.messageTemplate, { field: valueAccessor() }, null, validationMessageElement, 'replaceNode');\n                } else {\n                    ko.applyBindingsToNode(validationMessageElement, { validationMessage: valueAccessor() });\n                }\n            }\n            //if requested add binding to decorate element	\n            if (config.decorateElement && utils.isValidatable(valueAccessor())) {\n                ko.applyBindingsToNode(element, { validationElement: valueAccessor() });\n            }\n        };\n    } ());\n\n\n    ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding\n        update: function (element, valueAccessor) {\n            var obsv = valueAccessor(),\n                config = utils.getConfigOptions(element),\n                val = ko.utils.unwrapObservable(obsv),\n                msg = null,\n                isModified = false,\n                isValid = false;\n\n            obsv.extend({ validatable: true });\n\n            isModified = obsv.isModified();\n            isValid = obsv.isValid();\n\n            // create a handler to correctly return an error message\n            var errorMsgAccessor = function () {\n                if (!config.messagesOnModified || isModified) {\n                    return isValid ? null : obsv.error;\n                } else {\n                    return null;\n                }\n            };\n\n            //toggle visibility on validation messages when validation hasn't been evaluated, or when the object isValid\n            var visiblityAccessor = function () {\n                return isModified ? !isValid : false;\n            };\n\n            ko.bindingHandlers.text.update(element, errorMsgAccessor);\n            ko.bindingHandlers.visible.update(element, visiblityAccessor);\n        }\n    };\n\n    ko.bindingHandlers['validationElement'] = {\n        update: function (element, valueAccessor) {\n            var obsv = valueAccessor(),\n                config = utils.getConfigOptions(element),\n                val = ko.utils.unwrapObservable(obsv),\n                msg = null,\n                isModified = false,\n                isValid = false;\n\n            obsv.extend({ validatable: true });\n\n            isModified = obsv.isModified();\n            isValid = obsv.isValid();\n\n            // create an evaluator function that will return something like:\n            // css: { validationElement: true }\n            var cssSettingsAccessor = function () {\n                var css = {};\n\n                var shouldShow = (isModified ? !isValid : false);\n\n                if (!config.decorateElement) { shouldShow = false; }\n\n                // css: { validationElement: false }\n                css[config.errorElementClass] = shouldShow;\n\n                return css;\n            };\n\n            //add or remove class on the element;\n            ko.bindingHandlers.css.update(element, cssSettingsAccessor);\n        }\n    };\n\n    // ValidationOptions:\n    // This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements\n    //\n    // Example:\n    // <div data-bind=\"validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}\">\n    //      <input type=\"text\" data-bind=\"value: someValue\"/>\n    //      <input type=\"text\" data-bind=\"value: someValue2\"/>\n    // </div>\n    ko.bindingHandlers['validationOptions'] = (function () {\n        return {\n            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n                var options = ko.utils.unwrapObservable(valueAccessor());\n                if (options) {\n                    var newConfig = ko.utils.extend({}, configuration);\n                    ko.utils.extend(newConfig, options);\n\n                    //store the validation options on the node so we can retrieve it later\n                    utils.setDomData(element, newConfig);\n                }\n            }\n        };\n    } ());\n    //#endregion\n\n    //#region Knockout Extenders\n\n    // Validation Extender:\n    // This is for creating custom validation logic on the fly\n    // Example:\n    // var test = ko.observable('something').extend{(\n    //      validation: {\n    //          validator: function(val, someOtherVal){\n    //              return true;\n    //          },\n    //          message: \"Something must be really wrong!',\n    //          params: true\n    //      }\n    //  )};\n    ko.extenders['validation'] = function (observable, rules) { // allow single rule or array\n        ko.utils.arrayForEach(utils.isArray(rules) ? rules : [rules], function (rule) {\n            // the 'rule' being passed in here has no name to identify a core Rule,\n            // so we add it as an anonymous rule\n            // If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples\n            ko.validation.addAnonymousRule(observable, rule);\n        });\n        return observable;\n    };\n\n    //This is the extender that makes a Knockout Observable also 'Validatable'\n    //examples include:\n    // 1. var test = ko.observable('something').extend({validatable: true});\n    // this will ensure that the Observable object is setup properly to respond to rules\n    // \n    // 2. test.extend({validatable: false});\n    // this will remove the validation properties from the Observable object should you need to do that.\n    ko.extenders['validatable'] = function (observable, enable) {\n        if (enable && !utils.isValidatable(observable)) {\n\n            observable.error = null; // holds the error message, we only need one since we stop processing validators when one is invalid\n\n            // observable.rules:\n            // ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it\n            //\n            // Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }            \n            observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation\n\n            //in case async validation is occuring\n            observable.isValidating = ko.observable(false);\n\n            //the true holder of whether the observable is valid or not\n            observable.__valid__ = ko.observable(true);\n\n            observable.isModified = ko.observable(false);\n\n            // we use a computed here to ensure that anytime a dependency changes, the \n            // validation logic evaluates\n            var h_obsValidationTrigger = ko.computed(function () {\n                var obs = observable(),\n                    ruleContexts = observable.rules();\n\n                ko.validation.validateObservable(observable);\n\n                return true;\n            });\n\n            // a semi-protected observable  \n            observable.isValid = ko.computed(function () {\n                return observable.__valid__();\n            });\n\n            //subscribe to changes in the observable\n            var h_change = observable.subscribe(function () {\n                observable.isModified(true);\n            });\n\n            observable._disposeValidation = function () {\n                //first dispose of the subscriptions\n                observable.isValid.dispose();\n                observable.rules.removeAll();\n                observable.isModified._subscriptions['change'] = [];\n                observable.isValidating._subscriptions['change'] = [];\n                observable.__valid__._subscriptions['change'] = [];\n                h_change.dispose();\n                h_obsValidationTrigger.dispose();\n\n                delete observable['rules'];\n                delete observable['error'];\n                delete observable['isValid'];\n                delete observable['isValidating'];\n                delete observable['__valid__'];\n                delete observable['isModified'];\n            };\n        } else if (enable === false && utils.isValidatable(observable)) {\n\n            if (observable._disposeValidation) {\n                observable._disposeValidation();\n            }\n        }\n        return observable;\n    };\n\n    function validateSync(observable, rule, ctx) {\n        //Execute the validator and see if its valid\n        if (!rule.validator(observable(), ctx.params || true)) { // default param is true, eg. required = true\n\n            //not valid, so format the error message and stick it in the 'error' variable\n            observable.error = ko.validation.formatMessage(ctx.message || rule.message, ctx.params);\n            observable.__valid__(false);\n            return false;\n        } else {\n            return true;\n        }\n    };\n\n    function validateAsync(observable, rule, ctx) {\n        observable.isValidating(true);\n\n        var callBack = function (valObj) {\n            var isValid = false,\n                msg = '';\n\n            if (!observable.__valid__()) {\n                return; //if its already NOT valid, don't add to that\n            }\n\n            //we were handed back a complex object\n            if (valObj['message']) {\n                isValid = valObj.isValid;\n                msg = valObj.message;\n            } else {\n                isValid = valObj;\n            }\n\n            if (isValid) {//its VALID, so don't mess up anything that may have happened synchronously earlier on\n                return;\n            }\n\n            //not valid, so format the error message and stick it in the 'error' variable\n            observable.error = ko.validation.formatMessage(msg || ctx.message || rule.message, ctx.params);\n            observable.isValidating(false);\n            observable.__valid__(isValid);\n        }\n\n        //fire the validator and hand it the callback\n        rule.validator(observable(), ctx.params || true, callBack);\n    };\n\n    ko.validation.validateObservable = function (observable) {\n        var i = 0,\n            rule, // the rule validator to execute\n            ctx, // the current Rule Context for the loop\n            ruleContexts = observable.rules(), //cache for iterator\n            len = ruleContexts.length; //cache for iterator  \n\n        for (; i < len; i++) {\n\n            //get the Rule Context info to give to the core Rule\n            ctx = ruleContexts[i];\n\n            //get the core Rule to use for validation\n            rule = ko.validation.rules[ctx.rule];\n\n            if (rule['async'] || ctx['async']) {\n                //run async validation\n                validateAsync(observable, rule, ctx);\n\n            } else {\n                //run normal sync validation\n                if (!validateSync(observable, rule, ctx)) {\n                    return false; //break out of the loop\n                }\n            }\n        }\n        //finally if we got this far, make the observable valid again!\n        observable.error = null;\n        observable.__valid__(true);\n        return true;\n    };\n\n    //#endregion\n\n    //#region Validated Observable\n\n    ko.validatedObservable = function (initialValue) {\n        if (!ko.validation.utils.isObject(initialValue)) { return ko.observable(initialValue).extend({ validatable: true }); }\n\n        var obsv = ko.observable(initialValue);\n        obsv.errors = ko.validation.group(initialValue);\n        obsv.isValid = ko.computed(function () {\n            return obsv.errors().length === 0;\n        });\n\n        return obsv;\n    };\n\n    //#endregion\n\n    //#region Localization\n\n    //quick function to override rule messages\n    ko.validation.localize = function (msgTranslations) {\n\n        var msg, rule;\n\n        //loop the properties in the object and assign the msg to the rule\n        for (rule in msgTranslations) {\n            if (ko.validation.rules.hasOwnProperty(rule)) {\n                ko.validation.rules[rule].message = msgTranslations[rule];\n            }\n        }\n    };\n    //#endregion\n\n    //#region ApplyBindings Added Functionality\n    ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {\n        var len = arguments.length,\n            node, config;\n\n        if (len > 2) { // all parameters were passed\n            node = rootNode;\n            config = options;\n        } else if (len < 2) {\n            node = document.body;\n        } else { //have to figure out if they passed in a root node or options\n            if (arguments[1].nodeType) { //its a node\n                node = rootNode;\n            } else {\n                config = arguments[1];\n            }\n        }\n\n        ko.validation.init();\n\n        if (config) { ko.validation.utils.setDomData(node, config); }\n\n        ko.applyBindings(viewModel, rootNode);\n    };\n\n    //override the original applyBindings so that we can ensure all new rules and what not are correctly registered\n    var origApplyBindings = ko.applyBindings;\n    ko.applyBindings = function (viewModel, rootNode) {\n\n        ko.validation.init();\n\n        origApplyBindings(viewModel, rootNode);\n    };\n\n    //#endregion\n\n})();\n//@ sourceURL=tribe://Dependencies/knockout.validation.js");
window.eval("(function () {\n    // adds setWithoutValidation to observables\n    var oldExtender = ko.extenders['validatable'];\n    ko.extenders['validatable'] = function (observable, enable) {\n        oldExtender(observable, enable);\n        observable.setWithoutValidation = setWithoutValidation;\n    };\n\n    function setWithoutValidation(value) {\n        var rules = observable.rules();\n        observable.rules([]);\n        observable(value);\n        observable.isModified(false);\n        observable.rules(rules);\n    }\n})();\n//@ sourceURL=tribe://Infrastructure/observableExtensions.js");
window.eval("TF = window.TF || {};\nTF.renderTemplate = function(name, target) {\n    $(target).empty().append($('head script#template--Forms-' + name).html());\n};\n//@ sourceURL=tribe://Infrastructure/templates.js");
window.eval("ko.validation.rules['date'] = {\n    validator: function (value, validate) {\n        return !value || (validate && Dates.tryParseDate(value));\n    },\n    message: 'Please enter a proper date'\n};\n//@ sourceURL=tribe://Infrastructure/validationRules.js");
window.eval("(function () {\n    addBindingHandler('display');\n    addBindingHandler('textField');\n    addBindingHandler('dateField');\n    addBindingHandler('passwordField');\n    addBindingHandler('selectField');\n    addBindingHandler('radioField');\n    addBindingHandler('booleanField');\n\n    ko.bindingHandlers.field = {\n        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var properties = valueAccessor();\n            renderFieldTemplate(properties.type + 'Field', element, function () { return properties.value; }, valueAccessor, viewModel, bindingContext);\n        }\n    };\n\n    function addBindingHandler(name) {\n        ko.bindingHandlers[name] = {\n            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n                renderFieldTemplate(name, element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);\n                return { controlsDescendantBindings: true };\n            }\n        };\n    }\n\n    function renderFieldTemplate(templateName, element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var data = allBindingsAccessor();\n        data.value = valueAccessor();\n        if (!ko.isObservable(data.value) && _.isFunction(data.value))\n            data.value = data.value();\n\n        var innerBindingContext = bindingContext.extend(data);\n        ko.applyBindingsToDescendants(innerBindingContext, element);\n\n        TF.renderTemplate(templateName, element);\n        \n        for (var i = 0; i < element.children.length; i++)\n            ko.applyBindings(data, element.children[i]);\n            \n        var inputs = $(element).find('input');\n        setIdAttribute();\n        setFocus();\n        clickFirstButtonOnEnterKey();\n\n        // this is a bit of a hack\n        function setFocus() {\n            if (data.isDefault) // && !Configuration.mobile())\n                setTimeout(function () {\n                    inputs.focus();\n                }, 100);\n        }\n\n        function clickFirstButtonOnEnterKey() {\n            if (viewModel.__node)\n                inputs.keyup(function (event) {\n                    if (event.which === 13) {\n                        $(event.target).change().blur();\n                        var clickTarget = $(element).closest('.form').find('button:eq(0)');\n                        if(clickTarget.length === 0 && viewModel.__node)\n                            clickTarget = $(viewModel.__node.pane.element).find('button:eq(0)');\n                        clickTarget.click();\n                    }\n                });\n        }\n\n        // it would be nicer if we could use the attr { id: id } binding in knockout, but the jQuery UI datepicker sets the id of elements, the attr binding then resets it.\n        function setIdAttribute() {\n            inputs.eq(0).attr('id', data.id);\n        }\n    };\n})();\n//@ sourceURL=tribe://Binding Handlers/fields.js");
window.eval("ko.bindingHandlers.focus = {\n    update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var context = viewModel.__context || bindingContext.$root.__context;\n        if (context)\n            $.when(context.renderOperation.promise).done(function () {\n                setTimeout(function() {\n                    $(element).focus();\n                }, 100);\n            });\n    }\n};\n//@ sourceURL=tribe://Binding Handlers/focus.js");
window.eval("(function () {\n    ko.bindingHandlers.select = {\n        update: function (element, valueAccessor, allBindingsAccessor) {\n            var value = valueAccessor();\n            var bindings = allBindingsAccessor();\n            var source = ko.utils.unwrapObservable(bindings.source);\n            var displayList = bindings.property ?\n                _.map(source, function(item) {\n                    return item[bindings.property];\n                }) : \n                source.slice(0);\n\n            displayList.splice(0, 0, [bindings.initialText || 'Select...']);\n\n            setTimeout(function() {\n                TF.renderTemplate('/Templates/select.list', element);\n                ko.applyBindings({ source: displayList, change: change }, element.children[0]);\n            });\n            \n            function change(binding, event) {\n                var index = $(event.target).find('option:selected').index();\n                if(ko.isObservable(value))\n                    value(index ? source[index - 1] : null);\n            }\n        }\n    };\n\n    ko.bindingHandlers.label = {\n        update: function (element, valueAccessor) {\n            $(element).attr('label', ko.utils.unwrapObservable(valueAccessor()));\n        }\n    };\n})();\n//@ sourceURL=tribe://Binding Handlers/select.js");
window.eval("(function() {\n    ko.bindingHandlers.validatedClick = {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {\n            var newValueAccessor = function() {\n                return validatedClick;\n            };\n            return ko.bindingHandlers.click.init(element, newValueAccessor, allBindingsAccessor, viewModel);\n\n            function validatedClick(arg) {\n                // ignore the embedded properties or they cause the validator to loop infinitely\n                var target = $.extend(this, { __context: null, __node: null });\n                var errors = ko.validation.group(target, { deep: true });\n                if (errors().length > 0)\n                    errors.showAllMessages();\n                else\n                    valueAccessor()(arg);\n            }\n        }\n    };\n})();\n//@ sourceURL=tribe://Binding Handlers/validatedClick.js");
window.eval("//ko.bindingHandlers['validationMessage'] = {\n//    init: function (element, valueAccessor) {\n//        var id = uuid.v4();\n//        var observable = valueAccessor();\n//        var $parent = $(element).parent();\n//        var $targetElement;\n\n//        if ($parent.hasClass('display'))\n//            $targetElement = $parent.parent().parent();\n//        else {\n//            var $prev = $(element).prev();\n//            $targetElement = $prev.attr('type') === 'hidden' ? $prev.prev() : $prev;\n//        }\n//        var error = ko.observable();\n//        var pane = TC.insertNodeAfter($targetElement, {\n//            path: '/Common/tooltip',\n//            data: { html: error, position: 'auto', target: $targetElement, timeout: 3000, topic: id }\n//        });\n//        $targetElement.next().addClass('validationMessage');\n//        observable.subscribe(function () {\n//            if (observable.isModified && observable.isModified()) {\n//                TC.context().pubsub.publish(observable.isValid() ? 'tooltip.hide' : 'tooltip.show', { topic: id, immediate: true });\n//                error(observable.error);\n//            }\n//        });\n//        return { controlsDescendantBindings: true };\n//    }\n//};\n\n//@ sourceURL=tribe://Binding Handlers/validationMessage.tooltip.js");
<div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display">
        <input type="checkbox" data-bind="checked: value" />
    </div>
    <div style="clear: both"></div>
</div>
<div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display">
        <input type="text" class="datePicker" data-bind="value: value, restrictKeys: '[^0-9\/]+'" />
    </div>
    <div style="clear: both"></div>
</div><div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display">
        <span data-bind="text: value"></span>
    </div>
    <div style="clear: both"></div>
</div><div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display">
        <input type="password" data-bind="value: value"></input>
    </div>
    <div style="clear: both"></div>
</div><div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display" data-bind="foreach: items">
        <label>
            <input type="radio" data-bind="value: $data, checked: $parent.value, attr: { group: $parent.displayText.replace(/ /g, '_') }" />
            <span data-bind="text: $data"></span>
        </label>
        &nbsp;
    </div>
    <div style="clear: both"></div>
</div><select data-bind="foreach: source">
    <optgroup data-bind="label: group, foreach: list">
        <option data-bind="text: $data"></option>
    </optgroup>
</select><select data-bind="foreach: source, event: { change: change }">
    <option data-bind="text: $data"></option>
</select><div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display" data-bind="pane: '/Common/dropDown', data: $data"></div>
    <div style="clear: both"></div>
</div><div class="field">
    <div class="label">
        <span data-bind="text: displayText"></span>
    </div>
    <div class="display">
        <input type="text" data-bind="value: value" />
    </div>
    <div style="clear: both"></div>
</div><div data-bind="pane: '/Common/tooltip', data: { html: $data.field.error, autoShow: true, position: 'right' }"></div>.lw-dp {
  position: absolute;
  z-index: 100;
  overflow: hidden;
  cursor: default;
  width: 141px;
  border-width: 1px;
  border-style: solid;
  padding: 4px;
  margin: 5.5px;

  background: rgb(69,72,77);
  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzQ1NDg0ZCIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAwMDAiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
  background: -moz-linear-gradient(top,  rgba(69,72,77,1) 0%, rgba(0,0,0,1) 100%);
  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(69,72,77,1)), color-stop(100%,rgba(0,0,0,1)));
  background: -webkit-linear-gradient(top,  rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);
  background: -o-linear-gradient(top,  rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);
  background: -ms-linear-gradient(top,  rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);
  background: linear-gradient(top,  rgba(69,72,77,1) 0%,rgba(0,0,0,1) 100%);
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#45484d', endColorstr='#000000',GradientType=0 );


  border-radius: 6px;
  -moz-border-radius: 6px;
  -webkit-border-radius: 6px;

  box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);    

  -moz-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  user-select: none;
}

.lw-dp-hidden {
  display: none;
  box-shadow: none;
}

.lw-dp-toolbar {
  text-align: center;
  overflow: hidden;
  font-size: 12px;
  line-height: 18px;
  color: #DDDDDD;
  padding: 0 0 2.2px;
}

.lw-dp-month {
  display: inline-block;
  width: 103px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.lw-dp-previous, .lw-dp-next {
  position: absolute;
  overflow: hidden;
  top: 8px;
  width: 0;
  height: 0;
  color: #DDDDDD;
  cursor: pointer;
  border-top: 5.938px solid transparent;
  border-bottom: 5.938px solid transparent;
}

.lw-dp-previous {
  left: 8px;
  border-right: 11.875px solid #DDDDDD;
}

.lw-dp-next {
  right: 8px;
  border-left: 11.875px solid #DDDDDD;
}

.lw-dp-previous:hover {
  border-right-color: #797979;
}

.lw-dp-next:hover {
  border-left-color: #797979;
}

.lw-dp-previous:active {
  border-right-color: #acacac;
}

.lw-dp-next:active {
  border-left-color: #acacac;
}

.lw-dp-dows {
  padding: 0;
  margin: 0;
  overflow: hidden;
}

.lw-dp-dows li, .lw-dp-week li {
  display: block;
  float: left;
  padding: 0;
  margin: 0;
  text-align: center;
  color: #FFFFFF;
}

.lw-dp-dows li {
  font-size: 9px;
  line-height: 7.7px;
  width: 20px;
  height: 10px;
  padding: 0;
  margin: 0;
}

.lw-dp-week {
  padding: 0;
  margin: 0;
  overflow: hidden;
}

.lw-dp-week li {
  padding: 0;
  margin: 0;
  border-width: 0;
  font-size: 11px;
  color: black;
  width: 19px;
  height: 19px;
  line-height: 19px;
  background: #e0e0e0;
  border-left-width: 1px;
  border-top-width: 1px;
  border-style: solid;
  border-color: #f9f9f9;
  cursor: pointer;
}

.lw-dp-dows-last-column, .lw-dp-week-last-column {
  border-right-width: 1px;
}

.lw-dp-lastweek li {
  padding: 0;
  margin: 0;
  border-bottom-width: 1px;
}

.lw-dp-firstweek li:first-child {
  -moz-border-radius: 4px 0 0 0;
  -webkit-border-radius: 4px 0 0 0;
  -o-border-radius: 4px 0 0 0;
  -ms-border-radius: 4px 0 0 0;
  -khtml-border-radius: 4px 0 0 0;
  border-radius: 4px 0 0 0;
}

.lw-dp-firstweek li:last-child {
  -moz-border-radius: 0 4px 0 0;
  -webkit-border-radius: 0 4px 0 0;
  -o-border-radius: 0 4px 0 0;
  -ms-border-radius: 0 4px 0 0;
  -khtml-border-radius: 0 4px 0 0;
  border-radius: 0 4px 0 0;
}

.lw-dp-lastweek li:first-child {
  -moz-border-radius: 0 0 0 4px;
  -webkit-border-radius: 0 0 0 4px;
  -o-border-radius: 0 0 0 4px;
  -ms-border-radius: 0 0 0 4px;
  -khtml-border-radius: 0 0 0 4px;
  border-radius: 0 0 0 4px;
}

.lw-dp-lastweek li:last-child {
  -moz-border-radius: 0 0 4px 0;
  -webkit-border-radius: 0 0 4px 0;
  -o-border-radius: 0 0 4px 0;
  -ms-border-radius: 0 0 4px 0;
  -khtml-border-radius: 0 0 4px 0;
  border-radius: 0 0 4px 0;
}

.lw-dp-week li:hover {
  background: #f4f4f4;
}

li.lw-dp-weekend {
  background: #d0d0d0;
}

li.lw-dp-today {
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  -o-border-radius: 2px;
  -ms-border-radius: 2px;
  -khtml-border-radius: 2px;
  border-radius: 2px;
}

li.lw-dp-today span {
  display: block;
  width: 17px;
  height: 17px;
  line-height: 17px;
  border: 1px solid #acacac;
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  -o-border-radius: 2px;
  -ms-border-radius: 2px;
  -khtml-border-radius: 2px;
  border-radius: 2px;
}

li.lw-dp-today:hover span {
  color: #797979;
}

li.lw-dp-active-day, li.lw-dp-active-day:hover {
  position: relative;
  color: #f9f9f9;
  background: #797979;
}
li.lw-dp-active-day:nth-child(n), li.lw-dp-active-day:hover:nth-child(n) {
  background: none;
}
li.lw-dp-active-day::before, li.lw-dp-active-day:hover::before {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  content: '';
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  -o-border-radius: 2px;
  -ms-border-radius: 2px;
  -khtml-border-radius: 2px;
  border-radius: 2px;
  background: #797979;
  z-index: -1;
}

li.lw-dp-active-day:hover span {
  background: #e0e0e0;
}

li.lw-dp-neighbour-month-day {
  color: #b9b9b9;
}

li.lw-dp-out-of-interval, li.lw-dp-out-of-interval:hover {
  background: #ececec;
  cursor: default;
}
.field {
    clear: left;
    padding-top: 5px;
}

.label {
    float: left;
    width: 150px;    
}

.display {
    float: left;
    position: relative;
}

.fieldColumn {
    float: left;
}

.fieldColumn:nth-child(n+2) {
    padding-left: 20px;
}

.validationMessage {
    display: inline;
    color: salmon;    
}

.validationMessage .tooltipContent {
    padding: 1px 5px;
    border: 1px solid #4F0707;
    white-space: nowrap;
    background: rgb(173,17,17);
}

.desktop .validationMessage .tooltipContent {
    background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2FkMTExMSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiM0ZjA3MDciIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
    background: -moz-linear-gradient(top,  rgba(173,17,17,1) 0%, rgba(79,7,7,1) 100%);
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(173,17,17,1)), color-stop(100%,rgba(79,7,7,1)));
    background: -webkit-linear-gradient(top,  rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);
    background: -o-linear-gradient(top,  rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);
    background: -ms-linear-gradient(top,  rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);
    background: linear-gradient(top,  rgba(173,17,17,1) 0%,rgba(79,7,7,1) 100%);
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ad1111', endColorstr='#4f0707',GradientType=0 );
}

.validationElement {
    border: 2px solid red !important;
}
.TM .field {
    width: 100%;
    margin-bottom: 5px;
}

.TM .label {
    font-size: 0.7em;
}

.TM .display {
    width: 100%;
}

.TM .display input {
    width: 100%;
}

.TM .fieldColumn {
    float: left;
}

.TM .fieldColumn:nth-child(n+2) {
    padding-left: 20px;
}

.TM .validationElement {
    border: 2px solid red !important;
}
