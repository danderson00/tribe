require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/PubSub.extensions' };
var hub = require('./hub'),
    pubsub = require('tribe').pubsub,
    serializer = require('tribe/utilities/serializer'),
    pubsub = require('tribe.pubsub');

Tribe.PubSub.prototype.startSaga = function (id, path, data) {
    if (path.charAt(0) !== '/')
        path = '/' + path;

    var saga = new Tribe.PubSub.Saga(this, sagaDefinition(path));

    if (id) {
        saga.id = id;
        attachToHub(saga);
        hub.startSaga(path, id, data);
    }

    return saga.start(data);
};

Tribe.PubSub.prototype.joinSaga = function (id, path, data) {
    var deferred = $.Deferred();
    var self = this;
    $.when($.get('Data/' + id + '/' + id))
        .done(function (data) {
            var saga = new Tribe.PubSub.Saga(self, sagaDefinition(data.path));
            saga.id = id;
            saga.join(serializer.deserialize(data.data));
            attachToHub(saga);
            deferred.resolve(saga);
        })
        .fail(function (reason) {
            if (reason.status === 404 && path) {
                var saga = self.startSaga(id, path, data);
                deferred.resolve(saga);
            }
            else deferred.reject(reason);

        });
    return deferred;
};

function sagaDefinition(path) {
    return T.context().sagas[path].constructor;
}

// need to also be able to detach
function attachToHub(saga) {
    hub.join(saga.id);
    saga.pubsub.subscribe(saga.topics, function (message, envelope) {
        envelope.sagaId = saga.id;
        hub.publish(envelope);
    });
}

Tribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.prototype.startSaga;
Tribe.PubSub.Lifetime.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;
Tribe.PubSub.Channel.prototype.startSaga = Tribe.PubSub.prototype.startSaga;
Tribe.PubSub.Channel.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;

Tribe.PubSub.Channel.prototype.connect = function (topics) {
    var self = this;

    hub.join(this.id);
    this.subscribe(topics || '*', function(data, envelope) {
        hub.publish(envelope);
    });

    var end = this.end;
    this.end = function() {
        hub.leave(self.channelId);
        end();
    };

    return this;
};

},{"./hub":5,"tribe":"r5NbTJ","tribe.pubsub":12,"tribe/utilities/serializer":16}],2:[function(require,module,exports){
var hub = require('./hub'),
    pubsub = require('tribe').pubsub,
    serializer = require('tribe/utilities/serializer'),
    pubsub = require('tribe.pubsub');

Tribe.PubSub.prototype.startSaga = function (id, path, data) {
    if (path.charAt(0) !== '/')
        path = '/' + path;

    var saga = new Tribe.PubSub.Saga(this, sagaDefinition(path));

    if (id) {
        saga.id = id;
        attachToHub(saga);
        hub.startSaga(path, id, data);
    }

    return saga.start(data);
};

Tribe.PubSub.prototype.joinSaga = function (id, path, data) {
    var deferred = $.Deferred();
    var self = this;
    $.when($.get('Data/' + id + '/' + id))
        .done(function (data) {
            var saga = new Tribe.PubSub.Saga(self, sagaDefinition(data.path));
            saga.id = id;
            saga.join(serializer.deserialize(data.data));
            attachToHub(saga);
            deferred.resolve(saga);
        })
        .fail(function (reason) {
            if (reason.status === 404 && path) {
                var saga = self.startSaga(id, path, data);
                deferred.resolve(saga);
            }
            else deferred.reject(reason);

        });
    return deferred;
};

function sagaDefinition(path) {
    return T.context().sagas[path].constructor;
}

// need to also be able to detach
function attachToHub(saga) {
    hub.join(saga.id);
    saga.pubsub.subscribe(saga.topics, function (message, envelope) {
        envelope.sagaId = saga.id;
        hub.publish(envelope);
    });
}

Tribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.prototype.startSaga;
Tribe.PubSub.Lifetime.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;
Tribe.PubSub.Channel.prototype.startSaga = Tribe.PubSub.prototype.startSaga;
Tribe.PubSub.Channel.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;

Tribe.PubSub.Channel.prototype.connect = function (topics) {
    var self = this;

    hub.join(this.id);
    this.subscribe(topics || '*', function(data, envelope) {
        hub.publish(envelope);
    });

    var end = this.end;
    this.end = function() {
        hub.leave(self.channelId);
        end();
    };

    return this;
};

},{"./hub":5,"tribe":"r5NbTJ","tribe.pubsub":12,"tribe/utilities/serializer":16}],3:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/composite.debug' };
/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */


window.eval("\n(function (global) {\n    if (typeof ($) === 'undefined')\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (typeof (ko) === 'undefined')\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n\n    global.T = T || {};\n    global.T.Events = {};\n    global.T.Factories = {};\n    global.T.LoadHandlers = {};\n    global.T.LoadStrategies = {};\n    global.T.Transitions = {};\n    global.T.Types = {};\n    global.T.Utils = {};\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n    });\n})(window || this);\n\n//@ sourceURL=http://Tribe.Composite/setup.js");


window.eval("\nT.defaultOptions = function() {\n    return {\n        synchronous: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']\n    };\n};\nT.options = T.defaultOptions();\n\n//@ sourceURL=http://Tribe.Composite/options.js");


window.eval("\nvar level = 4;\nvar levels = {\n    debug: 4,\n    info: 3,\n    warn: 2,\n    error: 1,\n    none: 0\n};\n\nT.logger = {\n    setLevel: function (newLevel) {\n        level = levels[newLevel];\n        if (level === undefined) level = 4;\n    },\n    debug: function (message) {\n        if (level >= 4)\n            console.log(('DEBUG: ' + message));\n    },\n    info: function (message) {\n        if (level >= 3)\n            console.info(('INFO: ' + message));\n    },\n    warn: function (message) {\n        if (level >= 2)\n            console.warn(('WARN: ' + message));\n    },\n    error: function (message, error) {\n        if (level >= 1)\n            console.error(('ERROR: ' + message + '\\n'), api.errorDetails(error));\n    },\n    errorDetails: function (ex) {\n        if (!ex) return '';\n        return (ex.constructor === String) ? ex :\n            (ex.stack || '') + (ex.inner ? '\\n\\n' + this.errorDetails(ex.inner) : '\\n');\n    },\n    log: function (message) {\n        console.log(message);\n    }\n};\n\n//@ sourceURL=http://Tribe.Composite/logger.js");


window.eval("\n(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/bindingHandlers.js");


window.eval("\n(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n\n    utils.pluck = function(array, property) {\n        return utils.map(array, function(value) {\n            return value && value[property];\n        });\n    };\n\n    utils.reduce = function (array, initialValue, reduceFunction) {\n        utils.each(array, function(value, index) {\n            initialValue = reduceFunction(initialValue, value, index, array);\n        });\n        return initialValue;\n    };\n})(T.Utils);\n\n//@ sourceURL=http://Tribe.Composite/Utilities/collections.js");


window.eval("\n// this is taken from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 \"Cowboy\" Ben Alman and also released under the MIT license\n\n// Deserialize a params string into an object, optionally coercing numbers,\n// booleans, null and undefined values; this method is the counterpart to the\n// internal jQuery.param method.\nT.Utils.deparam = function (params, coerce) {\n    var decode = decodeURIComponent;\n    var obj = {},\n      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    // Iterate over all name=value pairs.\n    $.each(params.replace(/\\+/g, ' ').split('&'), function (j, v) {\n        var param = v.split('='),\n          key = decode(param[0]),\n          val,\n          cur = obj,\n          i = 0,\n\n          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n          // into its component parts.\n          keys = key.split(']['),\n          keys_last = keys.length - 1;\n\n        // If the first keys part contains [ and the last ends with ], then []\n        // are correctly balanced.\n        if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n            // Remove the trailing ] from the last keys part.\n            keys[keys_last] = keys[keys_last].replace(/\\]$/, '');\n\n            // Split first keys part into two parts on the [ and add them back onto\n            // the beginning of the keys array.\n            keys = keys.shift().split('[').concat(keys);\n\n            keys_last = keys.length - 1;\n        } else {\n            // Basic 'foo' style key.\n            keys_last = 0;\n        }\n\n        // Are we dealing with a name=value pair, or just a name?\n        if (param.length === 2) {\n            val = decode(param[1]);\n\n            // Coerce values.\n            if (coerce) {\n                val = val && !isNaN(val) ? +val              // number\n                  : val === 'undefined' ? undefined         // undefined\n                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n                  : val;                                                // string\n            }\n\n            if (keys_last) {\n                // Complex key, build deep object structure based on a few rules:\n                // * The 'cur' pointer starts at the object top-level.\n                // * [] = array push (n is set to array length), [n] = array if n is \n                //   numeric, otherwise object.\n                // * If at the last keys part, set the value.\n                // * For each keys part, if the current level is undefined create an\n                //   object or array based on the type of the next keys part.\n                // * Move the 'cur' pointer to the next level.\n                // * Rinse & repeat.\n                for (; i <= keys_last; i++) {\n                    key = keys[i] === '' ? cur.length : keys[i];\n                    cur = cur[key] = i < keys_last\n                      ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])\n                      : val;\n                }\n\n            } else {\n                // Simple key, even simpler rules, since only scalars and shallow\n                // arrays are allowed.\n\n                if ($.isArray(obj[key])) {\n                    // val is already an array, so push on the next value.\n                    obj[key].push(val);\n\n                } else if (obj[key] !== undefined) {\n                    // val isn't an array, but since a second value has been specified,\n                    // convert val into an array.\n                    obj[key] = [obj[key], val];\n\n                } else {\n                    // val is a scalar.\n                    obj[key] = val;\n                }\n            }\n\n        } else if (key) {\n            // No value was defined, so set something meaningful.\n            obj[key] = coerce\n              ? undefined\n              : '';\n        }\n    });\n\n    return obj;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/deparam.js");


window.eval("\n(function() {\n    T.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    T.Utils.contextFor = function (element) {\n        return element && T.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    T.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');\n    };\n\n    T.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/embeddedContext.js");


window.eval("\n(function () {\n    T.Utils.elementDestroyed = function (element) {\n        if (element.constructor === jQuery)\n            element = element[0];\n\n        var promise = $.Deferred();\n\n        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n        $(element).on('destroyed', resolve);\n\n        // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n        $(document).on(\"DOMNodeRemoved\", matchElement);\n\n        function matchElement(event) {\n            if (event.target === element)\n                resolve();\n        }\n\n        function resolve() {\n            $(element).off('destroyed', resolve);\n            $(document).off('DOMNodeRemoved', matchElement);\n            promise.resolve();\n        }\n\n        return promise;\n    };\n\n    // this used to use DOM functions to raise events, but IE8 doesn't support custom events\n    // we'll use jQuery, but expose the originalEvent for DOM events and the jQuery event\n    // for custom events (originalEvent is null for custom events).\n    T.Utils.raiseDocumentEvent = function (name, eventData) {\n        var e = $.Event(name);\n        e.eventData = eventData;\n        $(document).trigger(e);\n    };\n\n    var handlers = {};\n\n    // if a handler is used for more than one event, a leak will occur\n    T.Utils.handleDocumentEvent = function (name, handler) {\n        $(document).on(name, internalHandler);\n        handlers[handler] = internalHandler;\n        \n        function internalHandler(e) {\n            handler(e.originalEvent || e);\n        }\n    };\n\n    T.Utils.detachDocumentEvent = function (name, handler) {\n        $(document).off(name, handlers[handler]);\n        delete handlers[handler];\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/events.js");


window.eval("\nT.Utils.tryCatch = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(this, args || []);\n        } catch (ex) {\n            T.logger.error(message, ex);\n        }\n    else\n        func.apply(this, args || []);\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/exceptions.js");


window.eval("\n(function () {\n    T.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = T.Utils.idGenerator();\n    T.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/idGenerator.js");


window.eval("\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\n        'use strict';\n        if (this == null) {\n            throw new TypeError();\n        }\n        var n, k, t = Object(this),\n            len = t.length >>> 0;\n\n        if (len === 0) {\n            return -1;\n        }\n        n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0) ; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    };\n}\n//@ sourceURL=http://Tribe.Composite/Utilities/indexOf.js");


window.eval("\n(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.complete.js");


window.eval("\n(function () {\n    var oldClean = $.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.destroyed.js");


window.eval("\nT.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/knockout.js");


window.eval("\nT.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        func: byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nT.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nT.Utils.inheritOptions = function (from, to, options) {\n    for (var i = 0, l = options.length; i < l; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nT.Utils.cloneData = function (from, except) {\n    if (!from) return;\n    var result = {};\n    for (var property in from) {\n        var value = from[property];\n        if (from.hasOwnProperty(property) &&\n            (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&\n            (!value || (value.constructor !== Function || ko.isObservable(value))))\n\n            result[property] = ko.utils.unwrapObservable(value);\n    }\n    return result;\n};\n\nT.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {\n    var data = allBindingsAccessor();\n    data.value = valueAccessor();\n    if (!ko.isObservable(data.value) && $.isFunction(data.value))\n        data.value = data.value();\n    return data;\n};\n\n\n//@ sourceURL=http://Tribe.Composite/Utilities/objects.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n\n    utils.bindPane = function (node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || T.context();\n        var pane = new T.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new T.Types.Pipeline(T.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    utils.insertPaneAfter = function (node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return utils.bindPane(node, element, paneOptions, context);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/panes.js");


window.eval("\n(function() {\n    T.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path.charAt(0) === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, '');\n            },\n            setExtension: function(extension) {\n                return Path(this.withoutExtension() + '.' + extension);\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/Path.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    T.Utils.Querystring.parse = function (source, seperator, eqSymbol) {\n        stripLeadIn();\n        \n        return T.Utils.reduce(\n            T.Utils.map(\n                source.split(seperator || \"&\"),\n                pieceParser(eqSymbol || \"=\")\n            ),\n            {},\n            mergeParams\n        );\n\n        function stripLeadIn() {\n            if(source.length > 0 && source.charAt(0) === '?')\n                source = source.substring(1);\n        }\n    };\n    \n    function unescape(s) {\n        return decodeURIComponent(s.replace(/\\+/g, ' '));\n    };\n\n    function pieceParser(eq) {\n        return function parsePiece(key, val) {\n\n            var sliced, numVal, head, tail, ret;\n\n            if (arguments.length === 2) {\n                // key=val, called from the map/reduce\n                key = key.split(eq);\n                return parsePiece(\n                    unescape(key.shift()),\n                    unescape(key.join(eq)),\n                    true\n                );\n            }\n            \n            key = key.replace(/^\\s+|\\s+$/g, '');\n            if (val.constructor === String) {\n                val = val.replace(/^\\s+|\\s+$/g, '');\n                // convert numerals to numbers\n                if (!isNaN(val)) {\n                    numVal = +val;\n                    if (val === numVal.toString(10)) {\n                        val = numVal;\n                    }\n                }\n            }\n            \n            sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n            if (!sliced) {\n                ret = {};\n                if (key)\n                    ret[key] = val;\n                return ret;\n            }\n            \n            // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n            tail = sliced[2];\n            head = sliced[1];\n\n            // array: key[]=val\n            if (!tail)\n                return parsePiece(head, [val], true);\n\n            // object: key[subkey]=val\n            ret = {};\n            ret[tail] = val;\n            return parsePiece(head, ret, true);\n        };\n    }\n\n    // the reducer function that merges each query piece together into one set of params\n    function mergeParams(params, addition) {\n        return (\n            // if it's uncontested, then just return the addition.\n            (!params) ? addition\n            // if the existing value is an array, then concat it.\n            : ($.isArray(params)) ? params.concat(addition)\n            // if the existing value is not an array, and either are not objects, arrayify it.\n            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)\n            // else merge them as objects, which is a little more complex\n            : mergeObjects(params, addition)\n        );\n    }\n\n    // Merge two *objects* together. If this is called, we've already ruled\n    // out the simple cases, and need to do the for-in business.\n    function mergeObjects(params, addition) {\n        for (var i in addition)\n            if (i && addition.hasOwnProperty(i))\n                params[i] = mergeParams(params[i], addition[i]);\n\n        return params;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.parse.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    var escape = encodeURIComponent;\n\n    T.Utils.Querystring.stringify = function (source, options) {\n        return stringify(source, options);\n    };\n\n    function stringify(source, options, name, stack) {\n        options = options || {};\n        stack = stack || [];\n        var begin, end, i, l, n, s;\n        var sep = options.seperator || \"&\";\n        var eq = options.eqSymbol || \"=\";\n        var arrayKey = options.arrayKey !== false;\n\n        if (source === null || source === undefined || source.constructor === Function)\n            return name ? escape(name) + eq : '';\n\n        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')\n            source = +source;\n\n        if (!isNaN(source) || source.constructor === String)\n            return escape(name) + eq + escape(source);\n\n        if ($.isArray(source)) {\n            s = [];\n            name = arrayKey ? name + '[]' : name;\n            for (i = 0, l = source.length; i < l; i++) {\n                s.push(stringify(source[i], options, name, stack));\n            }\n\n            return s.join(sep);\n        }\n        \n        // now we know it's an object.\n        // Check for cyclical references in nested objects\n        for (i = stack.length - 1; i >= 0; --i)\n            if (stack[i] === source)\n                throw new Error(\"T.Utils.Querystring.stringify: cyclical reference\");\n\n        stack.push(source);\n        s = [];\n        begin = name ? name + '[' : '';\n        end = name ? ']' : '';\n        for (i in source) {\n            if (source.hasOwnProperty(i)) {\n                n = begin + i + end;\n                s.push(stringify(source[i], options, n, stack));\n            }\n        }\n\n        stack.pop();\n        s = s.join(sep);\n        if (!s && name)\n            return name + \"=\";\n\n        return s;\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.stringify.js");


window.eval("\n(function () {\n    T.Types.Flow = function (navigationSource, definition) {\n        var self = this;\n\n        this.node = navigationNode();\n        this.pubsub = this.node.pane.pubsub.owner;\n        this.sagas = [];\n\n        definition = createDefinition(self, definition);\n        this.saga = new Tribe.PubSub.Saga(this.pubsub, definition);\n\n        this.start = function(data) {\n            self.saga.start(data);\n            return self;\n        };\n\n        this.end = function(data) {\n            self.saga.end(data);\n            T.Utils.each(self.sagas, function(saga) {\n                saga.end(data);\n            });\n            return self;\n        };\n\n        function navigationNode() {\n            if (navigationSource.constructor === T.Types.Node)\n                return navigationSource.findNavigation().node;\n            if (navigationSource.constructor === T.Types.Pane)\n                return navigationSource.node.findNavigation().node;\n            throw new Error(\"navigationSource must be either T.Types.Pane or T.Types.Node\");\n        }\n    };\n\n    T.Types.Flow.prototype.startChild = function(definition, data) {\n        definition = createDefinition(this, definition);\n        this.saga.startChild(definition, data);\n        return this;\n    };\n\n    T.Types.Flow.prototype.navigate = function (pathOrOptions, data) {\n        this.node.navigate(pathOrOptions, data);\n    };\n    \n    // This keeps a separate collection of sagas bound to this flow's lifetime\n    // It would be nice to make them children of the underlying saga, but\n    // then they would end any time a message was executed.\n    T.Types.Flow.prototype.startSaga = function (definition, data) {\n        var saga = this.pubsub.startSaga(definition, data);\n        this.sagas.push(saga);\n        return saga;\n    };\n\n    // flow helpers\n    T.Types.Flow.prototype.to = function (pathOrOptions, data) {\n        var node = this.node;\n        return function () {\n            node.navigate(pathOrOptions, data);\n        };\n    };\n\n    T.Types.Flow.prototype.endsAt = function (pathOrOptions, data) {\n        var flow = this;\n        return function () {\n            flow.node.navigate(pathOrOptions, data);\n            flow.end();\n        };\n    };\n\n    T.Types.Flow.prototype.start = function(flow, data) {\n        var thisFlow = this;\n        return function() {\n            thisFlow.startChild(flow, data);\n        };\n    };\n\n\n    // This is reused by Node and Pane\n    T.Types.Flow.startFlow = function (definition, data) {\n        return new T.Types.Flow(this, definition).start(data);\n    };\n    \n    function createDefinition(flow, definition) {\n        if (definition.constructor === Function)\n            definition = new definition(flow);\n        return definition;\n    }\n})();\n//@ sourceURL=http://Tribe.Composite/Types/Flow.js");


window.eval("\nT.Types.History = function (history) {\n    var currentState = 0;\n    history.replaceState(currentState, window.title);\n\n    var popActions = {\n        raiseEvent: function (e) {\n            T.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });\n            currentState = e.state;\n        },\n        updateStack: function(e) {\n            currentState = e.state;\n            currentAction = popActions.raiseEvent;\n        }\n    };\n    var currentAction = popActions.raiseEvent;\n\n    // this leaves IE7 & 8 high and dry. We'll probably require a polyfill and create a generic event subscription method\n    if(window.addEventListener)\n        window.addEventListener('popstate', executeCurrentAction);\n\n    function executeCurrentAction(e) {\n        if (e.state !== null) currentAction(e);\n    }\n\n    this.navigate = function (urlOptions) {\n        urlOptions = urlOptions || {};\n        history.pushState(++currentState, urlOptions.title, urlOptions.url);\n    };\n\n    this.go = function(frameCount) {\n        history.go(frameCount);\n    };\n\n    this.update = function(frameCount) {\n        currentAction = popActions.updateStack;\n        history.go(frameCount);\n    };\n\n    this.dispose = function () {\n        window.removeEventListener('popstate', executeCurrentAction);\n    };\n};\n\nif (window.history.pushState)\n    T.history = new T.Types.History(window.history);\nelse\n    T.history = new T.Types.History({\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { }\n    });\n//@ sourceURL=http://Tribe.Composite/Types/History.js");


window.eval("\nT.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = T.Path(url).extension().toString();\n        var handler = T.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        T.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//@ sourceURL=http://Tribe.Composite/Types/Loader.js");


window.eval("\nT.Types.Navigation = function (node, options) {\n    normaliseOptions();\n    setInitialPaneState();\n\n    var stack = [initialStackItem()];\n    var currentFrame = 0;\n\n    this.node = node;\n    this.stack = stack;\n\n    this.navigate = function (paneOptions) {\n        if (options.browser)\n            T.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));\n\n        trimStack();\n        stack.push(paneOptions);\n        currentFrame++;\n\n        navigateTo(paneOptions);\n    };\n\n    this.isAtStart = function() {\n        return currentFrame === 0;\n    };\n\n    this.go = function(frameCount) {\n        go(frameCount);\n        if (options.browser) T.history.update(frameCount);\n    };\n    \n    if(options.browser) T.Utils.handleDocumentEvent('browser.go', onBrowserGo);\n    function onBrowserGo(e) {\n        go(e.eventData.count);\n    }\n\n    function go(frameCount) {\n        var newFrame = currentFrame + frameCount;\n        if (newFrame < 0) newFrame = 0;\n        if (newFrame >= stack.length) newFrame = stack.length - 1;\n\n        if (newFrame != currentFrame)\n            navigateTo(stack[newFrame], frameCount < 0);\n\n        currentFrame = newFrame;\n    }\n\n    function navigateTo(paneOptions, reverse) {\n        T.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });\n        node.transitionTo(paneOptions, options.transition, reverse);\n    }\n\n    function trimStack() {\n        stack.splice(currentFrame + 1, stack.length);\n    }\n\n    this.dispose = function() {\n        T.Utils.detachDocumentEvent('browser.go', onBrowserGo);\n    };\n    \n    function normaliseOptions() {\n        options = options || {};\n        if (options.constructor === String)\n            options = { transition: options };\n        if (options.browser === true)\n            options.browser = T.options.defaultUrlProvider;\n    }\n    \n    function setInitialPaneState() {\n        var query = window.location.href.match(/\\#.*/);\n        if (query) query = query[0].substring(1);\n        var urlState = options.browser && options.browser.paneOptionsFrom(query);\n        if (urlState) {\n            node.pane.path = urlState.path;\n            node.pane.data = urlState.data;\n        }\n    }\n    \n    function initialStackItem() {\n        return { path: node.pane.path, data: node.pane.data };\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Types/Navigation.js");


window.eval("\nT.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n    this.id = T.Utils.getUniqueId();\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nT.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = T.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!T.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = T.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();\n    \n    this.findNavigation().navigate(paneOptions);\n};\n\nT.Types.Node.prototype.navigateBack = function () {\n    this.findNavigation().go(-1);\n};\n\nT.Types.Node.prototype.findNavigation = function() {\n    if (this.defaultNavigation)\n        return this.defaultNavigation;\n\n    else if (this.navigation)\n        return this.navigation;\n        \n    if (!this.parent) {\n        this.navigation = new T.Types.Navigation(this);\n        return this.navigation;\n    }\n\n    return this.parent.findNavigation();\n};\n\nT.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    T.transition(this, transition, reverse).to(paneOptions);\n};\n\nT.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.navigation = new T.Types.Navigation(this, pane.handlesNavigation);\n        \n        // this sets this pane as the \"default\", accessible from panes outside the tree. First in best dressed.\n        this.root.defaultNavigation = this.root.defaultNavigation || this.navigation;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nT.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nT.Types.Node.prototype.dispose = function() {\n    if (this.root.defaultNavigation === this.navigation)\n        this.root.defaultNavigation = null;\n\n    if (this.parent)\n        T.Utils.removeItem(this.parent.children, this);\n\n    if (this.pane && this.pane.dispose) {\n        delete this.pane.node;\n        this.pane.dispose();\n    }\n};\n\nT.Types.Node.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Node.js");


window.eval("\nT.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        T.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//@ sourceURL=http://Tribe.Composite/Types/Operation.js");


window.eval("\nT.Types.Pane = function (options) {\n    T.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };    \n};\n\nT.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nT.Types.Pane.prototype.navigateBack = function () {\n    this.node && this.node.navigateBack();\n};\n\nT.Types.Pane.prototype.remove = function () {\n    $(this.element).remove();\n};\n\nT.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        delete this.node.pane;\n        this.node.dispose();\n    }\n\n    if (this.element)\n        T.Utils.cleanElement(this.element);\n};\n\nT.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;    \n    var path = T.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = T.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nT.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nT.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nT.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nT.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n\nT.Types.Pane.prototype.startSaga = function(path, args) {\n    var saga = T.context().sagas[path];\n    this.pubsub.startSaga.apply(this.pubsub, [saga.constructor].concat(Array.prototype.slice.call(arguments, 1)));\n};\n\nT.Types.Pane.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Pane.js");


window.eval("\nT.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var thisEvent = events[eventName];\n\n            if (!thisEvent) {\n                T.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            $.when(thisEvent(target, context))\n                .done(executeNextEvent)\n                .fail(handleFailure);\n\n            function handleFailure() {\n                promise.reject();\n                var targetDescription = target ? target.toString() : \"empty target\";\n                T.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription);\n            }\n        }\n\n        return promise;\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Pipeline.js");


window.eval("\nT.Types.Resources = function () { };\n\nT.Types.Resources.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    T.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//@ sourceURL=http://Tribe.Composite/Types/Resources.js");


window.eval("\nT.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = T.Path(path).asMarkupIdentifier().toString();\n        embedTemplate(template, 'template-' + id);\n    };\n    \n    function embedTemplate(template, id) {\n        var element = document.createElement('script');\n        element.className = '__tribe';\n        element.setAttribute('type', 'text/template');\n        element.id = id;\n        element.text = template;\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n    \n    this.loaded = function(path) {\n        return $('head script#template-' + T.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = T.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Templates.js");


window.eval("\nT.Events.active = function (pane, context) {\n    return T.Utils.elementDestroyed(pane.element);\n};\n//@ sourceURL=http://Tribe.Composite/Events/active.js");


window.eval("\nT.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path];\n    var model = definition && definition.constructor ?\n        new definition.constructor(pane) :\n        { pane: pane, data: pane.data };\n\n    T.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n};\n//@ sourceURL=http://Tribe.Composite/Events/createModel.js");


window.eval("\nT.Events.createPubSub = function (pane, context) {\n    if (context.pubsub)\n        pane.pubsub = context.pubsub.createLifetime ?\n            context.pubsub.createLifetime() :\n            context.pubsub;\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/createPubSub.js");


window.eval("\nT.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/dispose.js");


window.eval("\nT.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/Events/initialiseModel.js");


window.eval("\nT.Events.loadResources = function (pane, context) {\n    var strategy = T.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//@ sourceURL=http://Tribe.Composite/Events/loadResources.js");


window.eval("\nT.Events.renderComplete = function (pane, context) {\n    $.when(\n        T.transition(pane, pane.transition, pane.reverseTransitionIn)['in']())\n     .done(executeRenderComplete);\n    \n    pane.endRender();\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        T.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new T.Types.Operation();\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderComplete.js");


window.eval("\nT.Events.renderPane = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    T.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n\n    function applyBindings() {\n        ko.applyBindingsToDescendants(pane.model, pane.element);\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderPane.js");


window.eval("\nT.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeScript\n    });\n\n    function executeScript(script) {\n        T.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        T.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete T.scriptEnvironment;\n\n        T.logger.debug('Loaded script from ' + url);\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//@ sourceURL=tribe://Application/' + url.replace(/ /g, \"_\");\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/scripts.js");


window.eval("\nT.LoadHandlers.css = function (url, resourcePath, context) {\n    var supportsTextNodes = true;\n    \n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        var element = document.getElementById('__tribeStyles');\n        if (!element) {\n            element = document.createElement('style');\n            element.className = '__tribe';\n            element.id = '__tribeStyles';\n            document.getElementsByTagName('head')[0].appendChild(element);\n        }\n\n        if(supportsTextNodes)\n            try {\n                element.appendChild(document.createTextNode(stylesheet));\n            } catch(ex) {\n                supportsTextNodes = false;\n            }\n\n        if (!supportsTextNodes)\n            if (element.styleSheet) {\n                // using styleSheet.cssText is required for IE8 support\n                // IE8 also has a limit on the number of <style/> elements, so append it to the same node\n                element.styleSheet.cssText += stylesheet;\n            } else throw new Error('Unable to append stylesheet for ' + resourcePath + ' to document.');\n    }\n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/stylesheets.js");


window.eval("\nT.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nT.LoadHandlers.html = T.LoadHandlers.htm;\n\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/templates.js");


window.eval("\nT.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = T.Path(context.options.basePath).combine(T.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            T.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/adhoc.js");


window.eval("\nT.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        T.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/preloaded.js");


window.eval("\nT.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n    \n    transition = transition || (pane && pane.transition) || (node && node.transition);\n    var implementation = T.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = T.Transitions[implementation.reverse];\n\n    return {\n        'in': function () {\n            $(element).show();\n            return implementation && implementation['in'](element);\n        },\n        \n        out: function (remove) {\n            setTransitionMode();\n            \n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n            \n            function removeElement() {\n                if (remove === false) {\n                    $(element).hide().attr('style', '');\n                } else\n                    $(element).remove();\n            }\n        },\n        \n        to: function (paneOptions, remove) {\n            var context = T.context();\n            if (node)\n                T.Utils.insertPaneAfter(node, element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                T.insertNodeAfter(element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove);\n            return context.renderOperation.promise;\n        }\n    };\n    \n    function setTransitionMode() {\n        var $element = $(element);\n        if (T.transition.mode === 'fixed')\n            $element.css({\n                position: 'fixed',\n                width: $element.width(),\n                left: $element.offset().left,\n                top: $element.offset().top\n            });\n        else\n            $element.css({\n                position: 'absolute',\n                width: $element.width(),\n                left: $element.position().left,\n                top: $element.position().top\n            });\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to T.transition\";\n        \n        if (target.constructor === T.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === T.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/Transitions/transition.js");


window.eval("\n(function () {\n    var supported = supportsTransitions();\n    \n    createCssTransition('fade');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n\n    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';\n\n    function createCssTransition(transition, reverse) {\n        T.Transitions[transition] = {\n            'in': function (element) {\n                if (!supported) return null;\n                \n                var promise = $.Deferred();\n                $(element).bind(transitionEndEvents, transitionEnded(element, promise))\n                    .addClass('prepare in ' + transition);\n\n                trigger(element);\n                return promise;\n            },\n\n            out: function (element) {\n                if (!supported) return null;\n                var promise = $.Deferred();\n\n                $(element).addClass('prepare out ' + transition)\n                    .on(transitionEndEvents, transitionEnded(element, promise, true));\n\n                trigger(element);\n                return promise;\n            },\n            reverse: reverse || transition\n        };\n\n        function trigger(element) {\n            setTimeout(function () {\n                $(element).addClass('trigger');\n            }, 30);\n        }\n\n        function transitionEnded(element, promise, hide) {\n            return function() {\n                $(element).unbind(transitionEndEvents)\n                    .removeClass(transition + ' in out prepare trigger');\n                if (hide) $(element).hide();\n                promise.resolve();\n            };\n        }\n    }\n    \n    function supportsTransitions() {\n        var b = document.body || document.documentElement;\n        var style = b.style;\n        var property = 'transition';\n        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n        if (typeof style[property] == 'string') { return true; }\n\n        // Tests for vendor specific prop\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        for (var i = 0, l = vendors.length; i < l; i++) {\n            if (typeof style[vendors[i] + property] == 'string') { return true; }\n        }\n        \n        return false;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/css.js");


window.eval("\n\n//\nwindow.__appendStyle = function (content) {\n    var element = document.getElementById('__tribeStyles');\n    if (!element) {\n        element = document.createElement('style');\n        element.className = '__tribe';\n        element.id = '__tribeStyles';\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n\n    if(element.styleSheet)\n        element.styleSheet.cssText += content;\n    else\n        element.appendChild(document.createTextNode(content));\n};//\nwindow.__appendStyle('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}');\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/style.css.js");


window.eval("\n(function () {\n    T.registerModel = function () {\n        addResource('models', T.Utils.arguments(arguments));\n    };\n\n    T.registerSaga = function () {\n        addResource('sagas', T.Utils.arguments(arguments));\n    };\n    \n    function addResource(contextProperty, args) {\n        var environment = T.scriptEnvironment || {};\n        var context = environment.context || T.context();\n\n        var path = args.string || environment.resourcePath;\n        var constructor = args.func;\n        var options = args.object;\n\n        context[contextProperty].register(path, constructor, options);\n    }\n\n    T.run = function(options) {\n        T.options = $.extend(T.options, options);\n        T.options.pubsub = T.options.pubsub || new Tribe.PubSub({ sync: T.options.synchronous, handleExceptions: T.options.handleExceptions });\n        ko.applyBindings();\n    };\n})(); \n//@ sourceURL=http://Tribe.Composite/Api/api.js");


window.eval("\n(function () {\n    var staticState;\n\n    T.context = function (source) {\n        staticState = staticState || {\n            models: new T.Types.Resources(),\n            sagas: new T.Types.Resources(),\n            loader: new T.Types.Loader(),\n            options: T.options,\n            templates: new T.Types.Templates(),\n            loadedPanes: {}\n        };\n        var perContextState = {\n            renderOperation: new T.Types.Operation(),\n            pubsub: T.options.pubsub\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/context.js");


window.eval("\nT.options.defaultUrlProvider = {\n    urlDataFrom: function(paneOptions) {\n        return paneOptions && { url: '#' + $.param(paneOptions) };\n    },\n    paneOptionsFrom: function(url) {\n        return url && T.Utils.deparam(url.substr(1));\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Api/defaultUrlProvider.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    T.createNode = function (element, paneOptions, parentNode, context) {\n        parentNode = parentNode || T.nodeFor(element);\n        context = context || utils.contextFor(element) || T.context();\n\n        var node = new T.Types.Node(parentNode);\n        utils.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    T.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return T.createNode(element, paneOptions, parentNode, context);\n    };\n\n    T.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return T.createNode(element, paneOptions, parentNode || T.nodeFor(target), context);\n    };\n\n    T.nodeFor = function (element) {\n        return element && T.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/nodes.js");


window.eval("\n(function() {\n    ko.bindingHandlers.foreachProperty = {\n        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.init(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        },\n        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.update(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        }\n    };\n    \n    function makeAccessor(source) {\n        return function() {\n            return source;\n        };\n    }\n\n    function mapToArray(source) {\n        var result = [];\n        for (var property in source)\n            if (source.hasOwnProperty(property))\n                // we don't want to modify the original object, extend it onto a new object\n                result.push($.extend({ $key: property }, source[property]));\n        return result;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/foreachProperty.js");


window.eval("\nko.bindingHandlers.navigate = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, navigate, allBindingsAccessor, viewModel);\n\n        function navigate() {\n            return function () {\n                node.navigate(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigate.js");


window.eval("\nko.bindingHandlers.navigateBack = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);\n\n        function navigateBack() {\n            return function () {\n                node.navigateBack();\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigateBack.js");


window.eval("\n(function() {\n    ko.bindingHandlers.pane = { init: updateBinding };\n\n    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        T.createNode(element, constructPaneOptions(), T.Utils.extractNode(bindingContext), T.Utils.extractContext(bindingContext));\n\n        return { controlsDescendantBindings: true };\n\n        function constructPaneOptions() {\n            return T.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/pane.js");


window.eval("\nko.bindingHandlers.publish = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var pubsub = T.nodeFor(element).pane.pubsub;\n        if (!pubsub) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, publishAccessor, allBindingsAccessor, viewModel);\n\n        function publishAccessor() {\n            return function () {\n                pubsub.publish(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/publish.js");

},{}],4:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/composite' };
/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */


// setup.js

(function (global) {
    if (typeof ($) === 'undefined')
        throw 'jQuery must be loaded before knockout.composite can initialise';
    if (typeof (ko) === 'undefined')
        throw 'knockout.js must be loaded before knockout.composite can initialise';

    global.T = T || {};
    global.T.Events = {};
    global.T.Factories = {};
    global.T.LoadHandlers = {};
    global.T.LoadStrategies = {};
    global.T.Transitions = {};
    global.T.Types = {};
    global.T.Utils = {};

    $(function() {
        $('head').append('<style class="__tribe">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');
    });
})(window || this);



// options.js

T.defaultOptions = function() {
    return {
        synchronous: false,
        handleExceptions: true,
        basePath: '',
        loadStrategy: 'adhoc',
        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']
    };
};
T.options = T.defaultOptions();



// logger.js

var level = 4;
var levels = {
    debug: 4,
    info: 3,
    warn: 2,
    error: 1,
    none: 0
};

T.logger = {
    setLevel: function (newLevel) {
        level = levels[newLevel];
        if (level === undefined) level = 4;
    },
    debug: function (message) {
        if (level >= 4)
            console.log(('DEBUG: ' + message));
    },
    info: function (message) {
        if (level >= 3)
            console.info(('INFO: ' + message));
    },
    warn: function (message) {
        if (level >= 2)
            console.warn(('WARN: ' + message));
    },
    error: function (message, error) {
        if (level >= 1)
            console.error(('ERROR: ' + message + '\n'), api.errorDetails(error));
    },
    errorDetails: function (ex) {
        if (!ex) return '';
        return (ex.constructor === String) ? ex :
            (ex.stack || '') + (ex.inner ? '\n\n' + this.errorDetails(ex.inner) : '\n');
    },
    log: function (message) {
        console.log(message);
    }
};



// Utilities/bindingHandlers.js

(function () {
    ko.bindingHandlers.cssClass = {
        update: function (element, valueAccessor) {
            var value = valueAccessor();
            if (value)
                $(element).addClass(ko.utils.unwrapObservable(value));
        }
    };

    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);
    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);
    
    function keyPressedBindingHandler(which) {
        return {
            init: function (element, valueAccessor) {
                var $element = $(element);
                var callback = valueAccessor();
                if ($.isFunction(callback))
                    $element.keyup(testKey);

                function testKey(event) {
                    if (event.which === which) {
                        //$element.blur();
                        callback($element.val());
                    }
                }
            }
        };
    }

})();


// Utilities/collections.js

(function (utils) {    
    utils.each = function (collection, iterator) {
        return $.each(collection || [], function (index, value) {
            return iterator(value, index);
        });
    };

    // jQuery map flattens returned arrays - we don't want this for grids
    utils.map = function (collection, iterator) {
        var result = [];
        utils.each(collection || [], function(value, index) {
            result.push(iterator(value, index));
        });
        return result;
    };

    utils.filter = function(array, iterator) {
        var result = [];
        $.each(array || [], function(index, value) {
            if (iterator(value, index))
                result.push(value);
        });
        return result;
    };

    utils.pluck = function(array, property) {
        return utils.map(array, function(value) {
            return value && value[property];
        });
    };

    utils.reduce = function (array, initialValue, reduceFunction) {
        utils.each(array, function(value, index) {
            initialValue = reduceFunction(initialValue, value, index, array);
        });
        return initialValue;
    };
})(T.Utils);



// Utilities/deparam.js

// this is taken from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 "Cowboy" Ben Alman and also released under the MIT license

// Deserialize a params string into an object, optionally coercing numbers,
// booleans, null and undefined values; this method is the counterpart to the
// internal jQuery.param method.
T.Utils.deparam = function (params, coerce) {
    var decode = decodeURIComponent;
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };

    // Iterate over all name=value pairs.
    $.each(params.replace(/\+/g, ' ').split('&'), function (j, v) {
        var param = v.split('='),
          key = decode(param[0]),
          val,
          cur = obj,
          i = 0,

          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
          // into its component parts.
          keys = key.split(']['),
          keys_last = keys.length - 1;

        // If the first keys part contains [ and the last ends with ], then []
        // are correctly balanced.
        if (/\[/.test(keys[0]) && /\]$/.test(keys[keys_last])) {
            // Remove the trailing ] from the last keys part.
            keys[keys_last] = keys[keys_last].replace(/\]$/, '');

            // Split first keys part into two parts on the [ and add them back onto
            // the beginning of the keys array.
            keys = keys.shift().split('[').concat(keys);

            keys_last = keys.length - 1;
        } else {
            // Basic 'foo' style key.
            keys_last = 0;
        }

        // Are we dealing with a name=value pair, or just a name?
        if (param.length === 2) {
            val = decode(param[1]);

            // Coerce values.
            if (coerce) {
                val = val && !isNaN(val) ? +val              // number
                  : val === 'undefined' ? undefined         // undefined
                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
                  : val;                                                // string
            }

            if (keys_last) {
                // Complex key, build deep object structure based on a few rules:
                // * The 'cur' pointer starts at the object top-level.
                // * [] = array push (n is set to array length), [n] = array if n is 
                //   numeric, otherwise object.
                // * If at the last keys part, set the value.
                // * For each keys part, if the current level is undefined create an
                //   object or array based on the type of the next keys part.
                // * Move the 'cur' pointer to the next level.
                // * Rinse & repeat.
                for (; i <= keys_last; i++) {
                    key = keys[i] === '' ? cur.length : keys[i];
                    cur = cur[key] = i < keys_last
                      ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])
                      : val;
                }

            } else {
                // Simple key, even simpler rules, since only scalars and shallow
                // arrays are allowed.

                if ($.isArray(obj[key])) {
                    // val is already an array, so push on the next value.
                    obj[key].push(val);

                } else if (obj[key] !== undefined) {
                    // val isn't an array, but since a second value has been specified,
                    // convert val into an array.
                    obj[key] = [obj[key], val];

                } else {
                    // val is a scalar.
                    obj[key] = val;
                }
            }

        } else if (key) {
            // No value was defined, so set something meaningful.
            obj[key] = coerce
              ? undefined
              : '';
        }
    });

    return obj;
};


// Utilities/embeddedContext.js

(function() {
    T.Utils.embedState = function (model, context, node) {
        embedProperty(model, 'context', context);
        embedProperty(model, 'node', node);
    };

    T.Utils.contextFor = function (element) {
        return element && T.Utils.extractContext(ko.contextFor($(element)[0]));
    };

    T.Utils.extractContext = function (koBindingContext) {
        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');
    };

    T.Utils.extractNode = function (koBindingContext) {
        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');
    };

    function embedProperty(target, key, value) {
        if (!target)
            throw "Can't embed property in falsy value";
        target['__' + key] = value;
    }

    function embeddedProperty(target, key) {
        return target && target['__' + key];
    }
})();



// Utilities/events.js

(function () {
    T.Utils.elementDestroyed = function (element) {
        if (element.constructor === jQuery)
            element = element[0];

        var promise = $.Deferred();

        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.
        $(element).on('destroyed', resolve);

        // Resolve using the DOMNodeRemoved event. Not all browsers support this.
        $(document).on("DOMNodeRemoved", matchElement);

        function matchElement(event) {
            if (event.target === element)
                resolve();
        }

        function resolve() {
            $(element).off('destroyed', resolve);
            $(document).off('DOMNodeRemoved', matchElement);
            promise.resolve();
        }

        return promise;
    };

    // this used to use DOM functions to raise events, but IE8 doesn't support custom events
    // we'll use jQuery, but expose the originalEvent for DOM events and the jQuery event
    // for custom events (originalEvent is null for custom events).
    T.Utils.raiseDocumentEvent = function (name, eventData) {
        var e = $.Event(name);
        e.eventData = eventData;
        $(document).trigger(e);
    };

    var handlers = {};

    // if a handler is used for more than one event, a leak will occur
    T.Utils.handleDocumentEvent = function (name, handler) {
        $(document).on(name, internalHandler);
        handlers[handler] = internalHandler;
        
        function internalHandler(e) {
            handler(e.originalEvent || e);
        }
    };

    T.Utils.detachDocumentEvent = function (name, handler) {
        $(document).off(name, handlers[handler]);
        delete handlers[handler];
    };
})();


// Utilities/exceptions.js

T.Utils.tryCatch = function(func, args, handleExceptions, message) {
    if (handleExceptions)
        try {
            func.apply(this, args || []);
        } catch (ex) {
            T.logger.error(message, ex);
        }
    else
        func.apply(this, args || []);
};


// Utilities/idGenerator.js

(function () {
    T.Utils.idGenerator = function () {
        return {
            next: (function () {
                var id = 0;
                return function () {
                    if (arguments[0] == 0) {
                        id = 1;
                        return 0;
                    } else
                        return id++;
                };
            })()
        };
    };

    var generator = T.Utils.idGenerator();
    T.Utils.getUniqueId = function () {
        return generator.next();
    };
})();


// Utilities/indexOf.js

if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {
        'use strict';
        if (this == null) {
            throw new TypeError();
        }
        var n, k, t = Object(this),
            len = t.length >>> 0;

        if (len === 0) {
            return -1;
        }
        n = 0;
        if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n != n) { // shortcut for verifying if it's NaN
                n = 0;
            } else if (n != 0 && n != Infinity && n != -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0) ; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}


// Utilities/jquery.complete.js

(function ($) {
    $.complete = function (deferreds) {
        var wrappers = [];
        var deferred = $.Deferred();
        var resolve = false;

        if ($.isArray(deferreds))
            $.each(deferreds, wrapDeferred);
        else
            wrapDeferred(0, deferreds);

        $.when.apply($, wrappers).done(function() {
            resolve ?
                deferred.resolve() :
                deferred.reject();
        });

        return deferred;

        function wrapDeferred(index, original) {
            wrappers.push($.Deferred(function (thisDeferred) {
                $.when(original)
                    .done(function() {
                        resolve = true;
                    })
                    .always(function () {
                        thisDeferred.resolve();
                    });
            }));
        }
    };
})(jQuery);


// Utilities/jquery.destroyed.js

(function () {
    var oldClean = $.cleanData;

    // knockout also calls cleanData from it's cleanNode method - avoid any loops
    //var cleaning = {};

    $.cleanData = function (elements) {
        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {
            //if (!cleaning[element]) {
                //cleaning[element] = true;
                $(element).triggerHandler("destroyed");
                //delete cleaning[element];
            //}
        }
        oldClean(elements);
    };
})();


// Utilities/knockout.js

T.Utils.cleanElement = function (element) {
    // prevent knockout from calling cleanData 
    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur
    var func = $.cleanData;
    $.cleanData = undefined;
    ko.cleanNode(element);
    $.cleanData = func;
};


// Utilities/objects.js

T.Utils.arguments = function (args) {
    var byConstructor = {};
    $.each(args, function (index, arg) {
        byConstructor[arg.constructor] = arg;
    });

    return {
        byConstructor: function (constructor) {
            return byConstructor(constructor);
        },
        object: byConstructor[Object],
        string: byConstructor[String],
        func: byConstructor[Function],
        array: byConstructor[Array],
        number: byConstructor[Number]
    };
};

T.Utils.removeItem = function (array, item) {
    var index = $.inArray(item, array);
    if (index > -1)
        array.splice(index, 1);
};

T.Utils.inheritOptions = function (from, to, options) {
    for (var i = 0, l = options.length; i < l; i++)
        to[options[i]] = from[options[i]];
    return to;
};

T.Utils.cloneData = function (from, except) {
    if (!from) return;
    var result = {};
    for (var property in from) {
        var value = from[property];
        if (from.hasOwnProperty(property) &&
            (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&
            (!value || (value.constructor !== Function || ko.isObservable(value))))

            result[property] = ko.utils.unwrapObservable(value);
    }
    return result;
};

T.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {
    var data = allBindingsAccessor();
    data.value = valueAccessor();
    if (!ko.isObservable(data.value) && $.isFunction(data.value))
        data.value = data.value();
    return data;
};




// Utilities/panes.js

(function () {
    var utils = T.Utils;

    utils.getPaneOptions = function(value, otherOptions) {
        var options = value.constructor === String ? { path: value } : value;
        return $.extend({}, otherOptions, options);
    };

    utils.bindPane = function (node, element, paneOptions, context) {
        context = context || utils.contextFor(element) || T.context();
        var pane = new T.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));
        node.setPane(pane);

        context.renderOperation.add(pane);

        var pipeline = new T.Types.Pipeline(T.Events, context);
        pipeline.execute(context.options.events, pane);

        return pane;
    };

    utils.insertPaneAfter = function (node, target, paneOptions, context) {
        var element = $('<div/>').insertAfter(target);
        return utils.bindPane(node, element, paneOptions, context);
    };
})();



// Utilities/Path.js

(function() {
    T.Path = Path;

    function Path(path) {
        path = path ? normalise(path.toString()) : '';
        var filenameIndex = path.lastIndexOf("/") + 1;
        var extensionIndex = path.lastIndexOf(".");

        return {
            withoutFilename: function() {
                return Path(path.substring(0, filenameIndex));
            },
            filename: function() {
                return Path(path.substring(filenameIndex));
            },
            extension: function() {
                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);
            },
            withoutExtension: function() {
                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));
            },
            combine: function (additionalPath) {
                return Path((path ? path + '/' : '') + additionalPath.toString());
            },
            isAbsolute: function() {
                return path.charAt(0) === '/' ||
                    path.indexOf('://') > -1;
            },
            makeAbsolute: function() {
                return Path('/' + path);
            },
            makeRelative: function() {
                return Path(path.charAt(0) === '/' ? path.substring(1) : path);
            },
            asMarkupIdentifier: function() {
                return this.withoutExtension().toString().replace(/\//g, '-').replace(/\./g, '');
            },
            setExtension: function(extension) {
                return Path(this.withoutExtension() + '.' + extension);
            },
            toString: function() {
                return path.toString();
            }
        };

        function normalise(input) {
            input = removeDoubleSlashes(input);
            input = removeParentPaths(input);
            input = removeCurrentPaths(input);

            return input;
        }

        function removeDoubleSlashes(input) {
            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;
            var prefix = input.substring(0, prefixEnd);
            var inputPath = input.substring(prefixEnd);
            return prefix + inputPath.replace(/\/{2,}/g, '/');
        }

        function removeParentPaths(input) {
            var regex = /[^\/\.]+\/\.\.\//;

            while (input.match(regex))
                input = input.replace(regex, '');

            return input;
        }

        function removeCurrentPaths(input) {
            var regex = /\.\//g;
            // Ignore leading parent paths - the rest will have been stripped
            // I can't figure out a regex that won't strip the ./ out of ../
            var startIndex = input.lastIndexOf('../');
            startIndex = startIndex == -1 ? 0 : startIndex + 3;
            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');
        }
    };
})();



// Utilities/querystring.parse.js

(function () {
    // This is a modified version of modules from the YUI Library - 
    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html
    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/

    T.Utils.Querystring = T.Utils.Querystring || {};

    T.Utils.Querystring.parse = function (source, seperator, eqSymbol) {
        stripLeadIn();
        
        return T.Utils.reduce(
            T.Utils.map(
                source.split(seperator || "&"),
                pieceParser(eqSymbol || "=")
            ),
            {},
            mergeParams
        );

        function stripLeadIn() {
            if(source.length > 0 && source.charAt(0) === '?')
                source = source.substring(1);
        }
    };
    
    function unescape(s) {
        return decodeURIComponent(s.replace(/\+/g, ' '));
    };

    function pieceParser(eq) {
        return function parsePiece(key, val) {

            var sliced, numVal, head, tail, ret;

            if (arguments.length === 2) {
                // key=val, called from the map/reduce
                key = key.split(eq);
                return parsePiece(
                    unescape(key.shift()),
                    unescape(key.join(eq)),
                    true
                );
            }
            
            key = key.replace(/^\s+|\s+$/g, '');
            if (val.constructor === String) {
                val = val.replace(/^\s+|\s+$/g, '');
                // convert numerals to numbers
                if (!isNaN(val)) {
                    numVal = +val;
                    if (val === numVal.toString(10)) {
                        val = numVal;
                    }
                }
            }
            
            sliced = /(.*)\[([^\]]*)\]$/.exec(key);
            if (!sliced) {
                ret = {};
                if (key)
                    ret[key] = val;
                return ret;
            }
            
            // ["foo[][bar][][baz]", "foo[][bar][]", "baz"]
            tail = sliced[2];
            head = sliced[1];

            // array: key[]=val
            if (!tail)
                return parsePiece(head, [val], true);

            // object: key[subkey]=val
            ret = {};
            ret[tail] = val;
            return parsePiece(head, ret, true);
        };
    }

    // the reducer function that merges each query piece together into one set of params
    function mergeParams(params, addition) {
        return (
            // if it's uncontested, then just return the addition.
            (!params) ? addition
            // if the existing value is an array, then concat it.
            : ($.isArray(params)) ? params.concat(addition)
            // if the existing value is not an array, and either are not objects, arrayify it.
            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)
            // else merge them as objects, which is a little more complex
            : mergeObjects(params, addition)
        );
    }

    // Merge two *objects* together. If this is called, we've already ruled
    // out the simple cases, and need to do the for-in business.
    function mergeObjects(params, addition) {
        for (var i in addition)
            if (i && addition.hasOwnProperty(i))
                params[i] = mergeParams(params[i], addition[i]);

        return params;
    }
})();



// Utilities/querystring.stringify.js

(function () {
    // This is a modified version of modules from the YUI Library - 
    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html
    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/

    T.Utils.Querystring = T.Utils.Querystring || {};

    var escape = encodeURIComponent;

    T.Utils.Querystring.stringify = function (source, options) {
        return stringify(source, options);
    };

    function stringify(source, options, name, stack) {
        options = options || {};
        stack = stack || [];
        var begin, end, i, l, n, s;
        var sep = options.seperator || "&";
        var eq = options.eqSymbol || "=";
        var arrayKey = options.arrayKey !== false;

        if (source === null || source === undefined || source.constructor === Function)
            return name ? escape(name) + eq : '';

        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')
            source = +source;

        if (!isNaN(source) || source.constructor === String)
            return escape(name) + eq + escape(source);

        if ($.isArray(source)) {
            s = [];
            name = arrayKey ? name + '[]' : name;
            for (i = 0, l = source.length; i < l; i++) {
                s.push(stringify(source[i], options, name, stack));
            }

            return s.join(sep);
        }
        
        // now we know it's an object.
        // Check for cyclical references in nested objects
        for (i = stack.length - 1; i >= 0; --i)
            if (stack[i] === source)
                throw new Error("T.Utils.Querystring.stringify: cyclical reference");

        stack.push(source);
        s = [];
        begin = name ? name + '[' : '';
        end = name ? ']' : '';
        for (i in source) {
            if (source.hasOwnProperty(i)) {
                n = begin + i + end;
                s.push(stringify(source[i], options, n, stack));
            }
        }

        stack.pop();
        s = s.join(sep);
        if (!s && name)
            return name + "=";

        return s;
    };
})();



// Types/Flow.js

(function () {
    T.Types.Flow = function (navigationSource, definition) {
        var self = this;

        this.node = navigationNode();
        this.pubsub = this.node.pane.pubsub.owner;
        this.sagas = [];

        definition = createDefinition(self, definition);
        this.saga = new Tribe.PubSub.Saga(this.pubsub, definition);

        this.start = function(data) {
            self.saga.start(data);
            return self;
        };

        this.end = function(data) {
            self.saga.end(data);
            T.Utils.each(self.sagas, function(saga) {
                saga.end(data);
            });
            return self;
        };

        function navigationNode() {
            if (navigationSource.constructor === T.Types.Node)
                return navigationSource.findNavigation().node;
            if (navigationSource.constructor === T.Types.Pane)
                return navigationSource.node.findNavigation().node;
            throw new Error("navigationSource must be either T.Types.Pane or T.Types.Node");
        }
    };

    T.Types.Flow.prototype.startChild = function(definition, data) {
        definition = createDefinition(this, definition);
        this.saga.startChild(definition, data);
        return this;
    };

    T.Types.Flow.prototype.navigate = function (pathOrOptions, data) {
        this.node.navigate(pathOrOptions, data);
    };
    
    // This keeps a separate collection of sagas bound to this flow's lifetime
    // It would be nice to make them children of the underlying saga, but
    // then they would end any time a message was executed.
    T.Types.Flow.prototype.startSaga = function (definition, data) {
        var saga = this.pubsub.startSaga(definition, data);
        this.sagas.push(saga);
        return saga;
    };

    // flow helpers
    T.Types.Flow.prototype.to = function (pathOrOptions, data) {
        var node = this.node;
        return function () {
            node.navigate(pathOrOptions, data);
        };
    };

    T.Types.Flow.prototype.endsAt = function (pathOrOptions, data) {
        var flow = this;
        return function () {
            flow.node.navigate(pathOrOptions, data);
            flow.end();
        };
    };

    T.Types.Flow.prototype.start = function(flow, data) {
        var thisFlow = this;
        return function() {
            thisFlow.startChild(flow, data);
        };
    };


    // This is reused by Node and Pane
    T.Types.Flow.startFlow = function (definition, data) {
        return new T.Types.Flow(this, definition).start(data);
    };
    
    function createDefinition(flow, definition) {
        if (definition.constructor === Function)
            definition = new definition(flow);
        return definition;
    }
})();


// Types/History.js

T.Types.History = function (history) {
    var currentState = 0;
    history.replaceState(currentState, window.title);

    var popActions = {
        raiseEvent: function (e) {
            T.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });
            currentState = e.state;
        },
        updateStack: function(e) {
            currentState = e.state;
            currentAction = popActions.raiseEvent;
        }
    };
    var currentAction = popActions.raiseEvent;

    // this leaves IE7 & 8 high and dry. We'll probably require a polyfill and create a generic event subscription method
    if(window.addEventListener)
        window.addEventListener('popstate', executeCurrentAction);

    function executeCurrentAction(e) {
        if (e.state !== null) currentAction(e);
    }

    this.navigate = function (urlOptions) {
        urlOptions = urlOptions || {};
        history.pushState(++currentState, urlOptions.title, urlOptions.url);
    };

    this.go = function(frameCount) {
        history.go(frameCount);
    };

    this.update = function(frameCount) {
        currentAction = popActions.updateStack;
        history.go(frameCount);
    };

    this.dispose = function () {
        window.removeEventListener('popstate', executeCurrentAction);
    };
};

if (window.history.pushState)
    T.history = new T.Types.History(window.history);
else
    T.history = new T.Types.History({
        replaceState: function () { },
        pushState: function () { },
        go: function () { }
    });


// Types/Loader.js

T.Types.Loader = function () {
    var self = this;
    var resources = {};

    this.get = function(url, resourcePath, context) {
        if (resources[url] !== undefined)
            return resources[url];

        var extension = T.Path(url).extension().toString();
        var handler = T.LoadHandlers[extension];

        if (handler) {
            var result = handler(url, resourcePath, context);
            resources[url] = result;
            
            $.when(result).always(function() {
                resources[url] = null;
            });
            
            return result;
        }

        T.logger.warn("Resource of type " + extension + " but no handler registered.");
        return null;
    };
};



// Types/Navigation.js

T.Types.Navigation = function (node, options) {
    normaliseOptions();
    setInitialPaneState();

    var stack = [initialStackItem()];
    var currentFrame = 0;

    this.node = node;
    this.stack = stack;

    this.navigate = function (paneOptions) {
        if (options.browser)
            T.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));

        trimStack();
        stack.push(paneOptions);
        currentFrame++;

        navigateTo(paneOptions);
    };

    this.isAtStart = function() {
        return currentFrame === 0;
    };

    this.go = function(frameCount) {
        go(frameCount);
        if (options.browser) T.history.update(frameCount);
    };
    
    if(options.browser) T.Utils.handleDocumentEvent('browser.go', onBrowserGo);
    function onBrowserGo(e) {
        go(e.eventData.count);
    }

    function go(frameCount) {
        var newFrame = currentFrame + frameCount;
        if (newFrame < 0) newFrame = 0;
        if (newFrame >= stack.length) newFrame = stack.length - 1;

        if (newFrame != currentFrame)
            navigateTo(stack[newFrame], frameCount < 0);

        currentFrame = newFrame;
    }

    function navigateTo(paneOptions, reverse) {
        T.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });
        node.transitionTo(paneOptions, options.transition, reverse);
    }

    function trimStack() {
        stack.splice(currentFrame + 1, stack.length);
    }

    this.dispose = function() {
        T.Utils.detachDocumentEvent('browser.go', onBrowserGo);
    };
    
    function normaliseOptions() {
        options = options || {};
        if (options.constructor === String)
            options = { transition: options };
        if (options.browser === true)
            options.browser = T.options.defaultUrlProvider;
    }
    
    function setInitialPaneState() {
        var query = window.location.href.match(/\#.*/);
        if (query) query = query[0].substring(1);
        var urlState = options.browser && options.browser.paneOptionsFrom(query);
        if (urlState) {
            node.pane.path = urlState.path;
            node.pane.data = urlState.data;
        }
    }
    
    function initialStackItem() {
        return { path: node.pane.path, data: node.pane.data };
    }
};


// Types/Node.js

T.Types.Node = function (parent, pane) {
    this.parent = parent;
    this.children = [];
    this.root = parent ? parent.root : this;
    this.id = T.Utils.getUniqueId();

    if (parent) parent.children.push(this);
    if (pane) this.setPane(pane);
};

T.Types.Node.prototype.navigate = function (pathOrPane, data) {
    var paneOptions = T.Utils.getPaneOptions(pathOrPane, { data: data });
    if (!T.Path(paneOptions.path).isAbsolute())
        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer
        paneOptions.path = T.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();
    
    this.findNavigation().navigate(paneOptions);
};

T.Types.Node.prototype.navigateBack = function () {
    this.findNavigation().go(-1);
};

T.Types.Node.prototype.findNavigation = function() {
    if (this.defaultNavigation)
        return this.defaultNavigation;

    else if (this.navigation)
        return this.navigation;
        
    if (!this.parent) {
        this.navigation = new T.Types.Navigation(this);
        return this.navigation;
    }

    return this.parent.findNavigation();
};

T.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {
    T.transition(this, transition, reverse).to(paneOptions);
};

T.Types.Node.prototype.setPane = function (pane) {
    if (this.pane)
        this.pane.node = null;

    pane.node = this;
    this.pane = pane;
    this.skipPath = pane.skipPath;

    if (pane.handlesNavigation) {
        this.navigation = new T.Types.Navigation(this, pane.handlesNavigation);
        
        // this sets this pane as the "default", accessible from panes outside the tree. First in best dressed.
        this.root.defaultNavigation = this.root.defaultNavigation || this.navigation;
    }

    pane.inheritPathFrom(this.parent);
};

T.Types.Node.prototype.nodeForPath = function() {
    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;
};

T.Types.Node.prototype.dispose = function() {
    if (this.root.defaultNavigation === this.navigation)
        this.root.defaultNavigation = null;

    if (this.parent)
        T.Utils.removeItem(this.parent.children, this);

    if (this.pane && this.pane.dispose) {
        delete this.pane.node;
        this.pane.dispose();
    }
};

T.Types.Node.prototype.startFlow = T.Types.Flow.startFlow;



// Types/Operation.js

T.Types.Operation = function () {
    var self = this;
    var incomplete = [];

    this.promise = $.Deferred();

    this.add = function(id) {
        incomplete.push(id);
    };

    this.complete = function (id) {
        T.Utils.removeItem(incomplete, id);
        if (incomplete.length === 0)
            self.promise.resolve();
    };
    
};


// Types/Pane.js

T.Types.Pane = function (options) {
    T.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);

    // events we are interested in hooking in to - this could be done completely generically by the pipeline
    this.is = {
        rendered: $.Deferred(),
        disposed: $.Deferred()
    };    
};

T.Types.Pane.prototype.navigate = function (pathOrPane, data) {
    this.node && this.node.navigate(pathOrPane, data);
};

T.Types.Pane.prototype.navigateBack = function () {
    this.node && this.node.navigateBack();
};

T.Types.Pane.prototype.remove = function () {
    $(this.element).remove();
};

T.Types.Pane.prototype.dispose = function () {
    if (this.model && this.model.dispose)
        this.model.dispose();

    if (this.node) {
        delete this.node.pane;
        this.node.dispose();
    }

    if (this.element)
        T.Utils.cleanElement(this.element);
};

T.Types.Pane.prototype.inheritPathFrom = function (node) {
    node = node && node.nodeForPath();
    var pane = node && node.pane;    
    var path = T.Path(this.path);
    if (path.isAbsolute() || !pane)
        this.path = path.makeAbsolute().toString();
    else
        this.path = T.Path(pane.path).withoutFilename().combine(path).toString();
};

T.Types.Pane.prototype.find = function(selector) {
    return $(this.element).find(selector);
};

T.Types.Pane.prototype.startRender = function () {
    $(this.element).addClass('__rendering');
};

T.Types.Pane.prototype.endRender = function () {
    $(this.element).removeClass('__rendering');
};

T.Types.Pane.prototype.toString = function () {
    return "{ path: '" + this.path + "' }";
};

T.Types.Pane.prototype.startSaga = function(path, args) {
    var saga = T.context().sagas[path];
    this.pubsub.startSaga.apply(this.pubsub, [saga.constructor].concat(Array.prototype.slice.call(arguments, 1)));
};

T.Types.Pane.prototype.startFlow = T.Types.Flow.startFlow;



// Types/Pipeline.js

T.Types.Pipeline = function (events, context) {
    this.execute = function (eventsToExecute, target) {
        var currentEvent = -1;
        var promise = $.Deferred();
        executeNextEvent();

        function executeNextEvent() {
            currentEvent++;
            if (currentEvent >= eventsToExecute.length) {
                promise.resolve();
                return;
            }

            var eventName = eventsToExecute[currentEvent];
            var thisEvent = events[eventName];

            if (!thisEvent) {
                T.logger.warn("No event defined for " + eventName);
                executeNextEvent();
                return;
            }

            $.when(thisEvent(target, context))
                .done(executeNextEvent)
                .fail(handleFailure);

            function handleFailure() {
                promise.reject();
                var targetDescription = target ? target.toString() : "empty target";
                T.logger.error("An error occurred in the '" + eventName + "' event for " + targetDescription);
            }
        }

        return promise;
    };
};


// Types/Resources.js

T.Types.Resources = function () { };

T.Types.Resources.prototype.register = function (resourcePath, constructor, options) {
    this[resourcePath] = {
        constructor: constructor,
        options: options || {}
    };
    T.logger.debug("Model loaded for " + resourcePath);
};


// Types/Templates.js

T.Types.Templates = function () {
    var self = this;

    this.store = function (template, path) {
        var id = T.Path(path).asMarkupIdentifier().toString();
        embedTemplate(template, 'template-' + id);
    };
    
    function embedTemplate(template, id) {
        var element = document.createElement('script');
        element.className = '__tribe';
        element.setAttribute('type', 'text/template');
        element.id = id;
        element.text = template;
        document.getElementsByTagName('head')[0].appendChild(element);
    }
    
    this.loaded = function(path) {
        return $('head script#template-' + T.Path(path).asMarkupIdentifier()).length > 0;
    };

    this.render = function (target, path) {
        var id = T.Path(path).asMarkupIdentifier();
        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)
        $(target).empty().append($('head script#template-' + id).html());
    };
};


// Events/active.js

T.Events.active = function (pane, context) {
    return T.Utils.elementDestroyed(pane.element);
};


// Events/createModel.js

T.Events.createModel = function (pane, context) {
    var definition = context.models[pane.path];
    var model = definition && definition.constructor ?
        new definition.constructor(pane) :
        { pane: pane, data: pane.data };

    T.Utils.embedState(model, context, pane.node);

    pane.model = model;
};


// Events/createPubSub.js

T.Events.createPubSub = function (pane, context) {
    if (context.pubsub)
        pane.pubsub = context.pubsub.createLifetime ?
            context.pubsub.createLifetime() :
            context.pubsub;
};



// Events/dispose.js

T.Events.dispose = function (pane, context) {
    pane.pubsub && pane.pubsub.end && pane.pubsub.end();
    pane.dispose();
    pane.is.disposed.resolve();
};



// Events/initialiseModel.js

T.Events.initialiseModel = function (pane, context) {
    if (pane.model.initialise)
        return pane.model.initialise();
    return null;
};


// Events/loadResources.js

T.Events.loadResources = function (pane, context) {
    var strategy = T.LoadStrategies[context.options.loadStrategy];
    
    if (!strategy)
        throw "Unknown resource load strategy";

    return strategy(pane, context);
};


// Events/renderComplete.js

T.Events.renderComplete = function (pane, context) {
    $.when(
        T.transition(pane, pane.transition, pane.reverseTransitionIn)['in']())
     .done(executeRenderComplete);
    
    pane.endRender();

    function executeRenderComplete() {
        if (pane.model.renderComplete)
            pane.model.renderComplete();
        pane.is.rendered.resolve();
        T.Utils.raiseDocumentEvent('renderComplete', pane);
        context.renderOperation = new T.Types.Operation();
    }
};


// Events/renderPane.js

T.Events.renderPane = function (pane, context) {
    var renderOperation = context.renderOperation;

    pane.startRender();
    context.templates.render(pane.element, pane.path);
    T.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());

    if (pane.model.paneRendered)
        pane.model.paneRendered();

    renderOperation.complete(pane);
    return renderOperation.promise;

    function applyBindings() {
        ko.applyBindingsToDescendants(pane.model, pane.element);
    }
};


// LoadHandlers/scripts.js

T.LoadHandlers.js = function (url, resourcePath, context) {
    return $.ajax({
        url: url,
        dataType: 'text',
        async: !context.options.synchronous,
        cache: false,
        success: executeScript
    });

    function executeScript(script) {
        T.scriptEnvironment = {
            url: url,
            resourcePath: resourcePath,
            context: context
        };

        T.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,
            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));

        delete T.scriptEnvironment;

        T.logger.debug('Loaded script from ' + url);
    }

    function appendSourceUrl(script) {
        return script + '\n//@ sourceURL=tribe://Application/' + url.replace(/ /g, "_");
    }    
};


// LoadHandlers/stylesheets.js

T.LoadHandlers.css = function (url, resourcePath, context) {
    var supportsTextNodes = true;
    
    return $.ajax({
        url: url,
        dataType: 'text',
        async: !context.options.synchronous,
        cache: false,
        success: renderStylesheet
    });

    function renderStylesheet(stylesheet) {
        var element = document.getElementById('__tribeStyles');
        if (!element) {
            element = document.createElement('style');
            element.className = '__tribe';
            element.id = '__tribeStyles';
            document.getElementsByTagName('head')[0].appendChild(element);
        }

        if(supportsTextNodes)
            try {
                element.appendChild(document.createTextNode(stylesheet));
            } catch(ex) {
                supportsTextNodes = false;
            }

        if (!supportsTextNodes)
            if (element.styleSheet) {
                // using styleSheet.cssText is required for IE8 support
                // IE8 also has a limit on the number of <style/> elements, so append it to the same node
                element.styleSheet.cssText += stylesheet;
            } else throw new Error('Unable to append stylesheet for ' + resourcePath + ' to document.');
    }
};


// LoadHandlers/templates.js

T.LoadHandlers.htm = function (url, resourcePath, context) {
    return $.ajax({
        url: url,
        dataType: 'html',
        async: !context.options.synchronous,
        cache: false,
        success: storeTemplate
    });

    function storeTemplate(template) {
        context.templates.store(template, resourcePath);
    }
};
T.LoadHandlers.html = T.LoadHandlers.htm;



// LoadStrategies/adhoc.js

T.LoadStrategies.adhoc = function (pane, context) {
    if (context.loadedPanes[pane.path] !== undefined)
        return context.loadedPanes[pane.path];

    var path = T.Path(context.options.basePath).combine(T.Path(pane.path).makeRelative());

    if (context.templates.loaded(pane.path) || context.models[pane.path])
        return null;

    var deferred = $.complete([
        context.loader.get(path.setExtension('js').toString(), pane.path, context),
        context.loader.get(path.setExtension('htm').toString(), pane.path, context),
        context.loader.get(path.setExtension('css').toString(), pane.path, context)
    ]);

    context.loadedPanes[pane.path] = deferred;

    $.when(deferred)
        .fail(function() {
            T.logger.error("Unable to load resources for '" + pane.path + "'.");
        })
        .always(function () {
            context.loadedPanes[pane.path] = null;
        });

    return deferred;
};


// LoadStrategies/preloaded.js

T.LoadStrategies.preloaded = function (pane, context) {
    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {
        T.logger.error("No resources loaded for '" + pane.path + "'.");
        return $.Deferred().reject();
    }
    return null;
};


// Transitions/transition.js

T.transition = function (target, transition, reverse) {
    var node;
    var pane;
    var element;
    setState();
    
    transition = transition || (pane && pane.transition) || (node && node.transition);
    var implementation = T.Transitions[transition];
    if (reverse && implementation && implementation.reverse)
        implementation = T.Transitions[implementation.reverse];

    return {
        'in': function () {
            $(element).show();
            return implementation && implementation['in'](element);
        },
        
        out: function (remove) {
            setTransitionMode();
            
            var promise = implementation && implementation.out(element);
            $.when(promise).done(removeElement);
            return promise;
            
            function removeElement() {
                if (remove === false) {
                    $(element).hide().attr('style', '');
                } else
                    $(element).remove();
            }
        },
        
        to: function (paneOptions, remove) {
            var context = T.context();
            if (node)
                T.Utils.insertPaneAfter(node, element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);
            else
                T.insertNodeAfter(element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);
            this.out(remove);
            return context.renderOperation.promise;
        }
    };
    
    function setTransitionMode() {
        var $element = $(element);
        if (T.transition.mode === 'fixed')
            $element.css({
                position: 'fixed',
                width: $element.width(),
                left: $element.offset().left,
                top: $element.offset().top
            });
        else
            $element.css({
                position: 'absolute',
                width: $element.width(),
                left: $element.position().left,
                top: $element.position().top
            });
    }

    function setState() {
        if (!target) throw "No target passed to T.transition";
        
        if (target.constructor === T.Types.Node) {
            node = target;
            pane = node.pane;
            element = pane.element;
        } else if (target.constructor === T.Types.Pane) {
            pane = target;
            node = pane.node;
            element = pane.element;
        } else {
            element = target;
        }
    }    
};


// Transitions/Css/css.js

(function () {
    var supported = supportsTransitions();
    
    createCssTransition('fade');
    createCssTransition('slideLeft', 'slideRight');
    createCssTransition('slideRight', 'slideLeft');
    createCssTransition('slideUp', 'slideDown');
    createCssTransition('slideDown', 'slideUp');

    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';

    function createCssTransition(transition, reverse) {
        T.Transitions[transition] = {
            'in': function (element) {
                if (!supported) return null;
                
                var promise = $.Deferred();
                $(element).bind(transitionEndEvents, transitionEnded(element, promise))
                    .addClass('prepare in ' + transition);

                trigger(element);
                return promise;
            },

            out: function (element) {
                if (!supported) return null;
                var promise = $.Deferred();

                $(element).addClass('prepare out ' + transition)
                    .on(transitionEndEvents, transitionEnded(element, promise, true));

                trigger(element);
                return promise;
            },
            reverse: reverse || transition
        };

        function trigger(element) {
            setTimeout(function () {
                $(element).addClass('trigger');
            }, 30);
        }

        function transitionEnded(element, promise, hide) {
            return function() {
                $(element).unbind(transitionEndEvents)
                    .removeClass(transition + ' in out prepare trigger');
                if (hide) $(element).hide();
                promise.resolve();
            };
        }
    }
    
    function supportsTransitions() {
        var b = document.body || document.documentElement;
        var style = b.style;
        var property = 'transition';
        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

        if (typeof style[property] == 'string') { return true; }

        // Tests for vendor specific prop
        property = property.charAt(0).toUpperCase() + property.substr(1);
        for (var i = 0, l = vendors.length; i < l; i++) {
            if (typeof style[vendors[i] + property] == 'string') { return true; }
        }
        
        return false;
    }
})();



// Transitions/Css/style.css.js


//
window.__appendStyle = function (content) {
    var element = document.getElementById('__tribeStyles');
    if (!element) {
        element = document.createElement('style');
        element.className = '__tribe';
        element.id = '__tribeStyles';
        document.getElementsByTagName('head')[0].appendChild(element);
    }

    if(element.styleSheet)
        element.styleSheet.cssText += content;
    else
        element.appendChild(document.createTextNode(content));
};//
window.__appendStyle('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}');


// Api/api.js

(function () {
    T.registerModel = function () {
        addResource('models', T.Utils.arguments(arguments));
    };

    T.registerSaga = function () {
        addResource('sagas', T.Utils.arguments(arguments));
    };
    
    function addResource(contextProperty, args) {
        var environment = T.scriptEnvironment || {};
        var context = environment.context || T.context();

        var path = args.string || environment.resourcePath;
        var constructor = args.func;
        var options = args.object;

        context[contextProperty].register(path, constructor, options);
    }

    T.run = function(options) {
        T.options = $.extend(T.options, options);
        T.options.pubsub = T.options.pubsub || new Tribe.PubSub({ sync: T.options.synchronous, handleExceptions: T.options.handleExceptions });
        ko.applyBindings();
    };
})(); 


// Api/context.js

(function () {
    var staticState;

    T.context = function (source) {
        staticState = staticState || {
            models: new T.Types.Resources(),
            sagas: new T.Types.Resources(),
            loader: new T.Types.Loader(),
            options: T.options,
            templates: new T.Types.Templates(),
            loadedPanes: {}
        };
        var perContextState = {
            renderOperation: new T.Types.Operation(),
            pubsub: T.options.pubsub
        };
        return $.extend({}, staticState, perContextState, source);
    };
})();



// Api/defaultUrlProvider.js

T.options.defaultUrlProvider = {
    urlDataFrom: function(paneOptions) {
        return paneOptions && { url: '#' + $.param(paneOptions) };
    },
    paneOptionsFrom: function(url) {
        return url && T.Utils.deparam(url.substr(1));
    }
};


// Api/nodes.js

(function () {
    var utils = T.Utils;

    T.createNode = function (element, paneOptions, parentNode, context) {
        parentNode = parentNode || T.nodeFor(element);
        context = context || utils.contextFor(element) || T.context();

        var node = new T.Types.Node(parentNode);
        utils.bindPane(node, element, paneOptions, context);

        return node;
    };

    T.appendNode = function (target, paneOptions, parentNode, context) {
        var element = $('<div/>').appendTo(target);
        return T.createNode(element, paneOptions, parentNode, context);
    };

    T.insertNodeAfter = function (target, paneOptions, parentNode, context) {
        var element = $('<div/>').insertAfter(target);
        return T.createNode(element, paneOptions, parentNode || T.nodeFor(target), context);
    };

    T.nodeFor = function (element) {
        return element && T.Utils.extractNode(ko.contextFor($(element)[0]));
    };
})();



// BindingHandlers/foreachProperty.js

(function() {
    ko.bindingHandlers.foreachProperty = {
        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            return ko.bindingHandlers.foreach.init(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);
        },
        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            return ko.bindingHandlers.foreach.update(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);
        }
    };
    
    function makeAccessor(source) {
        return function() {
            return source;
        };
    }

    function mapToArray(source) {
        var result = [];
        for (var property in source)
            if (source.hasOwnProperty(property))
                // we don't want to modify the original object, extend it onto a new object
                result.push($.extend({ $key: property }, source[property]));
        return result;
    }
})();



// BindingHandlers/navigate.js

ko.bindingHandlers.navigate = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var node = T.nodeFor(element);
        if (!node) return;

        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);
        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;
        handler.init(element, navigate, allBindingsAccessor, viewModel);

        function navigate() {
            return function () {
                node.navigate(data.value, T.Utils.cloneData(data.data));
            };
        }
    }
};


// BindingHandlers/navigateBack.js

ko.bindingHandlers.navigateBack = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var node = T.nodeFor(element);
        if (!node) return;

        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);

        function navigateBack() {
            return function () {
                node.navigateBack();
            };
        }
    }
};


// BindingHandlers/pane.js

(function() {
    ko.bindingHandlers.pane = { init: updateBinding };

    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        T.createNode(element, constructPaneOptions(), T.Utils.extractNode(bindingContext), T.Utils.extractContext(bindingContext));

        return { controlsDescendantBindings: true };

        function constructPaneOptions() {
            return T.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());
        }
    }
})();



// BindingHandlers/publish.js

ko.bindingHandlers.publish = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var pubsub = T.nodeFor(element).pane.pubsub;
        if (!pubsub) return;

        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);
        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;
        handler.init(element, publishAccessor, allBindingsAccessor, viewModel);

        function publishAccessor() {
            return function () {
                pubsub.publish(data.value, T.Utils.cloneData(data.data));
            };
        }
    }
};

},{}],5:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/hub' };
var pubsub = require('tribe.pubsub'),
    socket;

var hub = module.exports = {
    connect: function () {
        socket = io.connect();

        socket.on('message', function (envelope) {
            envelope.origin = 'server';
            pubsub.publish(envelope);
        });
    },

    publish: function(envelope) {
        if (!socket) hub.connect();

        if(envelope.origin !== 'server')
            socket.emit('message', envelope, function () {
                console.log('message acknowledged');
            });
    },

    join: function(channel) {
        if (!socket) hub.connect();
        socket.emit('join', channel);
    },

    startSaga: function(path, id, data) {
        if (!socket) hub.connect();
        socket.emit('startSaga', { path: path, id: id, data: data });
    }
};
},{"tribe.pubsub":12}],"tribe":[function(require,module,exports){
module.exports=require('r5NbTJ');
},{}],"r5NbTJ":[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/index' };
// composite has a logger packaged, but use the node version as it will likely get updated
T.logger = require('tribe/logger');
require('./Pubsub.extensions');

module.exports = {
    // client
    hub: require('tribe/client/hub'),
    services: require('tribe/client/services'),

    //common
    pubsub: require('tribe.pubsub'),
    register: require('tribe/client/register')
};
},{"./Pubsub.extensions":2,"tribe.pubsub":12,"tribe/client/hub":5,"tribe/client/register":9,"tribe/client/services":10,"tribe/logger":11}],8:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/pubsub.debug' };

window.eval("\nif (typeof (Tribe) === 'undefined')\n    Tribe = {};\n\nTribe.PubSub = function (options) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    this.owner = this;\n    this.options = options || {};\n    this.sync = option('sync');\n     \n    var subscribers = new Tribe.PubSub.SubscriberList();\n    this.subscribers = subscribers;\n\n    function publish(envelope) {\n        var messageSubscribers = subscribers.get(envelope.topic);\n        var sync = envelope.sync === true || self.sync === true;\n\n        for (var i = 0, l = messageSubscribers.length; i < l; i++) {\n            if (sync)\n                executeSubscriber(messageSubscribers[i].handler);\n            else {\n                (function (subscriber) {\n                    setTimeout(function () {\n                        executeSubscriber(subscriber.handler);\n                    });\n                })(messageSubscribers[i]);\n            }\n        }\n\n        function executeSubscriber(func) {\n            var exceptionHandler = option('exceptionHandler');\n            \n            if(option('handleExceptions')  && exceptionHandler)\n                try {\n                    func(envelope.data, envelope);\n                } catch (e) {\n                    exceptionHandler(e, envelope);\n                }\n            else\n                func(envelope.data, envelope);\n        }\n    }\n\n    this.publish = function (topicOrEnvelope, data) {\n        return publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        var envelope = createEnvelope(topicOrEnvelope, data);\n        envelope.sync = true;\n        return publish(envelope);\n    };\n    \n    function createEnvelope(topicOrEnvelope, data) {\n        return topicOrEnvelope && topicOrEnvelope.topic\n            ? topicOrEnvelope\n            : { topic: topicOrEnvelope, data: data };\n    }\n\n    this.subscribe = function (topic, func) {\n        if (typeof (topic) === \"string\")\n            return subscribers.add(topic, func);\n        else if (utils.isArray(topic))\n            return utils.map(topic, function(topicName) {\n                return subscribers.add(topicName, func);\n            });\n        else\n            return utils.map(topic, function (individualFunc, topicName) {\n                return subscribers.add(topicName, individualFunc);\n            });\n    };\n\n    this.unsubscribe = function (tokens) {\n        if (Tribe.PubSub.utils.isArray(tokens)) {\n            var results = [];\n            for (var i = 0, l = tokens.length; i < l; i++)\n                results.push(subscribers.remove(tokens[i]));\n            return results;\n        }\n\n        return subscribers.remove(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n    \n    function option(name) {\n        return (self.options.hasOwnProperty(name)) ? self.options[name] : Tribe.PubSub.options[name];\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/PubSub.js");


window.eval("\nTribe.PubSub.Channel = function (pubsub, channelId) {\n    var self = this;\n    pubsub = pubsub.createLifetime();\n\n    this.id = channelId;\n    this.owner = pubsub.owner;\n\n    this.publish = function (topicOrEnvelope, data) {\n        return pubsub.publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        return pubsub.publishSync(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.subscribe = function(topic, func) {\n        return pubsub.subscribe(topic, filterMessages(func));\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        return pubsub.subscribeOnce(topic, filterMessages(func));\n    };\n    \n    this.unsubscribe = function(token) {\n        return pubsub.unsubscribe(token);\n    };\n\n    this.end = function() {\n        return pubsub.end();\n    };\n\n    this.createLifetime = function () {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n\n    function createEnvelope(topicOrEnvelope, data) {\n        var envelope = topicOrEnvelope && topicOrEnvelope.topic\n          ? topicOrEnvelope\n          : { topic: topicOrEnvelope, data: data };\n        envelope.channelId = channelId;\n        return envelope;\n    }\n    \n    function filterMessages(func) {\n        return function(data, envelope) {\n            if (envelope.channelId === channelId)\n                func(data, envelope);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Channel.js");


window.eval("\nTribe.PubSub.Lifetime = function (parent, owner) {\n    var self = this;\n    var tokens = [];\n\n    this.owner = owner;\n\n    this.publish = function(topicOrEnvelope, data) {\n        return parent.publish(topicOrEnvelope, data);\n    };\n\n    this.publishSync = function(topic, data) {\n        return parent.publishSync(topic, data);\n    };\n\n    this.subscribe = function(topic, func) {\n        var token = parent.subscribe(topic, func);\n        return recordToken(token);\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        var token = parent.subscribeOnce(topic, func);\n        return recordToken(token);\n    };\n    \n    this.unsubscribe = function(token) {\n        // we should really remove the token(s) from our token list, but it has trivial impact if we don't\n        return parent.unsubscribe(token);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n\n    this.end = function() {\n        return parent.unsubscribe(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n    \n    function recordToken(token) {\n        if (Tribe.PubSub.utils.isArray(token))\n            tokens = tokens.concat(token);\n        else\n            tokens.push(token);\n        return token;\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Lifetime.js");


window.eval("\nTribe.PubSub.options = {\n    sync: false,\n    handleExceptions: true,\n    exceptionHandler: function(e, envelope) {\n        typeof(console) !== 'undefined' && console.log(\"Exception occurred in subscriber to '\" + envelope.topic + \"': \" + e.message);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/options.js");


window.eval("\nTribe.PubSub.Saga = function (pubsub, definition) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    pubsub = pubsub.createLifetime();\n    this.pubsub = pubsub;\n    this.children = [];\n\n    configureSaga();\n    var handlers = this.handles || {};\n\n    // this is not ie<9 compatible and includes onstart / onend\n    this.topics = Object.keys(handlers);\n\n    this.start = function (startData) {\n        utils.each(handlers, self.addHandler, self);\n        if (handlers.onstart) handlers.onstart(startData, self);\n        return self;\n    };\n\n    this.startChild = function (child, onstartData) {\n        self.children.push(new Tribe.PubSub.Saga(pubsub, child)\n            .start(onstartData));\n        return self;\n    };\n\n    this.join = function (data, onjoinData) {\n        utils.each(handlers, self.addHandler, self);\n        self.data = data;\n        if (handlers.onjoin) handlers.onjoin(onjoinData, self);\n        return self;\n    };\n\n    this.end = function (onendData) {\n        if (handlers.onend) handlers.onend(onendData, self);\n        pubsub.end();\n        self.endChildren(onendData);\n        return self;\n    };\n\n    this.endChildren = function(data) {\n        Tribe.PubSub.utils.each(self.children, function(child) {\n             child.end(data);\n        });\n    }\n    \n    function configureSaga() {\n        if (definition)\n            if (definition.constructor === Function)\n                definition(self);\n            else\n                Tribe.PubSub.utils.copyProperties(definition, self, ['handles', 'endsChildrenExplicitly']);\n    }\n};\n\nTribe.PubSub.Saga.startSaga = function (definition, data) {\n    return new Tribe.PubSub.Saga(this, definition).start(data);\n};\n\nTribe.PubSub.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\nTribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\n//@ sourceURL=http://Tribe.PubSub/Saga.core.js");


window.eval("\nTribe.PubSub.Saga.prototype.addHandler = function (handler, topic) {\n    var self = this;\n\n    if (topic !== 'onstart' && topic !== 'onend' && topic !== 'onjoin')\n        if (!handler)\n            this.pubsub.subscribe(topic, endHandler());\n        else if (handler.constructor === Function)\n            this.pubsub.subscribe(topic, messageHandlerFor(handler));\n        else\n            this.pubsub.subscribe(topic, childHandlerFor(handler));\n\n    function messageHandlerFor(handler) {\n        return function (messageData, envelope) {\n            if (!self.endsChildrenExplicitly)\n                self.endChildren(messageData);\n            handler(messageData, envelope, self);\n        };\n    }\n\n    function childHandlerFor(childHandlers) {\n        return function (messageData, envelope) {\n            self.startChild({ handles: childHandlers }, messageData);\n        };\n    }\n\n    function endHandler() {\n        return function (messageData) {\n            self.end(messageData);\n        };\n    }\n};\n\n//@ sourceURL=http://Tribe.PubSub/Saga.handlers.js");


window.eval("\nTribe.PubSub.prototype.subscribeOnce = function (topic, handler) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n    var lifetime = this.createLifetime();\n\n    if (typeof (topic) === \"string\")\n        return lifetime.subscribe(topic, wrapHandler(handler));\n    else if (utils.isArray(topic))\n        return lifetime.subscribe(wrapTopicArray());\n    else\n        return lifetime.subscribe(wrapTopicObject());\n\n    function wrapTopicArray() {\n        var result = {};\n        utils.each(topic, function(topicName) {\n            result[topicName] = wrapHandler(handler);\n        });\n        return result;\n    }\n    \n    function wrapTopicObject() {\n        return utils.map(topic, function (func, topicName) {\n            return lifetime.subscribe(topicName, wrapHandler(func));\n        });\n    }\n\n    function wrapHandler(func) {\n        return function() {\n            lifetime.end();\n            func.apply(self, arguments);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/subscribeOnce.js");


window.eval("\nTribe.PubSub.SubscriberList = function() {\n    var subscribers = {};\n    var lastUid = -1;\n\n    this.get = function (publishedTopic) {\n        var matching = [];\n        for (var registeredTopic in subscribers)\n            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))\n                matching = matching.concat(subscribers[registeredTopic]);\n        return matching;\n    };\n\n    this.add = function (topic, handler) {\n        var token = (++lastUid).toString();\n        if (!subscribers.hasOwnProperty(topic))\n            subscribers[topic] = [];\n        subscribers[topic].push({ topic: topic, handler: handler, token: token });\n        return token;\n    };\n\n    this.remove = function(token) {\n        for (var m in subscribers)\n            if (subscribers.hasOwnProperty(m))\n                for (var i = 0, l = subscribers[m].length; i < l; i++)\n                    if (subscribers[m][i].token === token) {\n                        subscribers[m].splice(i, 1);\n                        return token;\n                    }\n\n        return false;\n    };\n\n    function topicMatches(published, subscriber) {\n        if (subscriber === '*')\n            return true;\n        \n        var expression = \"^\" + subscriber\n            .replace(/\\./g, \"\\\\.\")\n            .replace(/\\*/g, \"[^\\.]*\") + \"$\";\n        return published.match(expression);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/SubscriberList.js");


window.eval("\nTribe.PubSub.utils = {};\n(function(utils) {\n    utils.isArray = function (source) {\n        return source.constructor === Array;\n    };\n\n    // The following functions are taken from the underscore library, duplicated to avoid dependency. License at http://underscorejs.org.\n    var nativeForEach = Array.prototype.forEach;\n    var nativeMap = Array.prototype.map;\n    var breaker = {};\n\n    utils.each = function (obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker) return;\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) return;\n                }\n            }\n        }\n    };\n\n    utils.map = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        utils.each(obj, function (value, index, list) {\n            results[results.length] = iterator.call(context, value, index, list);\n        });\n        return results;\n    };\n\n    utils.copyProperties = function (source, target, properties) {\n        for (var i = 0, l = properties.length; i < l; i++) {\n            var property = properties[i];\n            if(source.hasOwnProperty(property))\n                target[property] = source[property];\n        }\n    };\n})(Tribe.PubSub.utils);\n\n//@ sourceURL=http://Tribe.PubSub/utils.js");


window.eval("\nif (typeof(module) !== 'undefined')\n    module.exports = new Tribe.PubSub();\n//@ sourceURL=http://Tribe.PubSub/exports.js");

},{}],9:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/register' };
module.exports = {
    saga: T.registerSaga,
    handler: function () {
        throw new Error("You can't register a static handler on the client (yet)!");
    },
    service: function () {
        throw new Error("You can't register a service on the client!");
    }
};
},{}],10:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/services' };
module.exports = function (name) {
    return {
        invoke: function () {
            return $.get('Services', { name: name, args: Array.prototype.splice.call(arguments, 0) })
                .fail(function (response) {
                    T.logger.error(response.responseText);
                });
        }
    };
};
},{}],11:[function(require,module,exports){
var level = 4;
var levels = {
    debug: 4,
    info: 3,
    warn: 2,
    error: 1,
    none: 0
};

var api = module.exports = {
    setLevel: function (newLevel) {
        level = levels[newLevel];
        if (level === undefined) level = 4;
    },
    debug: function (message) {
        if (level >= 4)
            console.log(('DEBUG: ' + message));
    },
    info: function (message) {
        if (level >= 3)
            console.info(('INFO: ' + message));
    },
    warn: function (message) {
        if (level >= 2)
            console.warn(('WARN: ' + message));
    },
    error: function (message, error) {
        if (level >= 1)
            console.error(('ERROR: ' + message + '\n'), api.errorDetails(error));
    },
    errorDetails: function (ex) {
        if (!ex) return '';
        return (ex.constructor === String) ? ex :
            (ex.stack || '') + (ex.inner ? '\n\n' + this.errorDetails(ex.inner) : '\n');
    },
    log: function (message) {
        console.log(message);
    }
};

},{}],12:[function(require,module,exports){

// PubSub.js

if (typeof (Tribe) === 'undefined')
    Tribe = {};

Tribe.PubSub = function (options) {
    var self = this;
    var utils = Tribe.PubSub.utils;

    this.owner = this;
    this.options = options || {};
    this.sync = option('sync');
     
    var subscribers = new Tribe.PubSub.SubscriberList();
    this.subscribers = subscribers;

    function publish(envelope) {
        var messageSubscribers = subscribers.get(envelope.topic);
        var sync = envelope.sync === true || self.sync === true;

        for (var i = 0, l = messageSubscribers.length; i < l; i++) {
            if (sync)
                executeSubscriber(messageSubscribers[i].handler);
            else {
                (function (subscriber) {
                    setTimeout(function () {
                        executeSubscriber(subscriber.handler);
                    });
                })(messageSubscribers[i]);
            }
        }

        function executeSubscriber(func) {
            var exceptionHandler = option('exceptionHandler');
            
            if(option('handleExceptions')  && exceptionHandler)
                try {
                    func(envelope.data, envelope);
                } catch (e) {
                    exceptionHandler(e, envelope);
                }
            else
                func(envelope.data, envelope);
        }
    }

    this.publish = function (topicOrEnvelope, data) {
        return publish(createEnvelope(topicOrEnvelope, data));
    };

    this.publishSync = function (topicOrEnvelope, data) {
        var envelope = createEnvelope(topicOrEnvelope, data);
        envelope.sync = true;
        return publish(envelope);
    };
    
    function createEnvelope(topicOrEnvelope, data) {
        return topicOrEnvelope && topicOrEnvelope.topic
            ? topicOrEnvelope
            : { topic: topicOrEnvelope, data: data };
    }

    this.subscribe = function (topic, func) {
        if (typeof (topic) === "string")
            return subscribers.add(topic, func);
        else if (utils.isArray(topic))
            return utils.map(topic, function(topicName) {
                return subscribers.add(topicName, func);
            });
        else
            return utils.map(topic, function (individualFunc, topicName) {
                return subscribers.add(topicName, individualFunc);
            });
    };

    this.unsubscribe = function (tokens) {
        if (Tribe.PubSub.utils.isArray(tokens)) {
            var results = [];
            for (var i = 0, l = tokens.length; i < l; i++)
                results.push(subscribers.remove(tokens[i]));
            return results;
        }

        return subscribers.remove(tokens);
    };

    this.createLifetime = function() {
        return new Tribe.PubSub.Lifetime(self, self);
    };

    this.channel = function(channelId) {
        return new Tribe.PubSub.Channel(self, channelId);
    };
    
    function option(name) {
        return (self.options.hasOwnProperty(name)) ? self.options[name] : Tribe.PubSub.options[name];
    }
};


// Channel.js

Tribe.PubSub.Channel = function (pubsub, channelId) {
    var self = this;
    pubsub = pubsub.createLifetime();

    this.id = channelId;
    this.owner = pubsub.owner;

    this.publish = function (topicOrEnvelope, data) {
        return pubsub.publish(createEnvelope(topicOrEnvelope, data));
    };

    this.publishSync = function (topicOrEnvelope, data) {
        return pubsub.publishSync(createEnvelope(topicOrEnvelope, data));
    };

    this.subscribe = function(topic, func) {
        return pubsub.subscribe(topic, filterMessages(func));
    };

    this.subscribeOnce = function(topic, func) {
        return pubsub.subscribeOnce(topic, filterMessages(func));
    };
    
    this.unsubscribe = function(token) {
        return pubsub.unsubscribe(token);
    };

    this.end = function() {
        return pubsub.end();
    };

    this.createLifetime = function () {
        return new Tribe.PubSub.Lifetime(self, self.owner);
    };

    function createEnvelope(topicOrEnvelope, data) {
        var envelope = topicOrEnvelope && topicOrEnvelope.topic
          ? topicOrEnvelope
          : { topic: topicOrEnvelope, data: data };
        envelope.channelId = channelId;
        return envelope;
    }
    
    function filterMessages(func) {
        return function(data, envelope) {
            if (envelope.channelId === channelId)
                func(data, envelope);
        };
    }
};


// Lifetime.js

Tribe.PubSub.Lifetime = function (parent, owner) {
    var self = this;
    var tokens = [];

    this.owner = owner;

    this.publish = function(topicOrEnvelope, data) {
        return parent.publish(topicOrEnvelope, data);
    };

    this.publishSync = function(topic, data) {
        return parent.publishSync(topic, data);
    };

    this.subscribe = function(topic, func) {
        var token = parent.subscribe(topic, func);
        return recordToken(token);
    };

    this.subscribeOnce = function(topic, func) {
        var token = parent.subscribeOnce(topic, func);
        return recordToken(token);
    };
    
    this.unsubscribe = function(token) {
        // we should really remove the token(s) from our token list, but it has trivial impact if we don't
        return parent.unsubscribe(token);
    };

    this.channel = function(channelId) {
        return new Tribe.PubSub.Channel(self, channelId);
    };

    this.end = function() {
        return parent.unsubscribe(tokens);
    };

    this.createLifetime = function() {
        return new Tribe.PubSub.Lifetime(self, self.owner);
    };
    
    function recordToken(token) {
        if (Tribe.PubSub.utils.isArray(token))
            tokens = tokens.concat(token);
        else
            tokens.push(token);
        return token;
    }
};


// options.js

Tribe.PubSub.options = {
    sync: false,
    handleExceptions: true,
    exceptionHandler: function(e, envelope) {
        typeof(console) !== 'undefined' && console.log("Exception occurred in subscriber to '" + envelope.topic + "': " + e.message);
    }
};


// Saga.core.js

Tribe.PubSub.Saga = function (pubsub, definition) {
    var self = this;
    var utils = Tribe.PubSub.utils;

    pubsub = pubsub.createLifetime();
    this.pubsub = pubsub;
    this.children = [];

    configureSaga();
    var handlers = this.handles || {};

    // this is not ie<9 compatible and includes onstart / onend
    this.topics = Object.keys(handlers);

    this.start = function (startData) {
        utils.each(handlers, self.addHandler, self);
        if (handlers.onstart) handlers.onstart(startData, self);
        return self;
    };

    this.startChild = function (child, onstartData) {
        self.children.push(new Tribe.PubSub.Saga(pubsub, child)
            .start(onstartData));
        return self;
    };

    this.join = function (data, onjoinData) {
        utils.each(handlers, self.addHandler, self);
        self.data = data;
        if (handlers.onjoin) handlers.onjoin(onjoinData, self);
        return self;
    };

    this.end = function (onendData) {
        if (handlers.onend) handlers.onend(onendData, self);
        pubsub.end();
        self.endChildren(onendData);
        return self;
    };

    this.endChildren = function(data) {
        Tribe.PubSub.utils.each(self.children, function(child) {
             child.end(data);
        });
    }
    
    function configureSaga() {
        if (definition)
            if (definition.constructor === Function)
                definition(self);
            else
                Tribe.PubSub.utils.copyProperties(definition, self, ['handles', 'endsChildrenExplicitly']);
    }
};

Tribe.PubSub.Saga.startSaga = function (definition, data) {
    return new Tribe.PubSub.Saga(this, definition).start(data);
};

Tribe.PubSub.prototype.startSaga = Tribe.PubSub.Saga.startSaga;
Tribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.Saga.startSaga;


// Saga.handlers.js

Tribe.PubSub.Saga.prototype.addHandler = function (handler, topic) {
    var self = this;

    if (topic !== 'onstart' && topic !== 'onend' && topic !== 'onjoin')
        if (!handler)
            this.pubsub.subscribe(topic, endHandler());
        else if (handler.constructor === Function)
            this.pubsub.subscribe(topic, messageHandlerFor(handler));
        else
            this.pubsub.subscribe(topic, childHandlerFor(handler));

    function messageHandlerFor(handler) {
        return function (messageData, envelope) {
            if (!self.endsChildrenExplicitly)
                self.endChildren(messageData);
            handler(messageData, envelope, self);
        };
    }

    function childHandlerFor(childHandlers) {
        return function (messageData, envelope) {
            self.startChild({ handles: childHandlers }, messageData);
        };
    }

    function endHandler() {
        return function (messageData) {
            self.end(messageData);
        };
    }
};



// subscribeOnce.js

Tribe.PubSub.prototype.subscribeOnce = function (topic, handler) {
    var self = this;
    var utils = Tribe.PubSub.utils;
    var lifetime = this.createLifetime();

    if (typeof (topic) === "string")
        return lifetime.subscribe(topic, wrapHandler(handler));
    else if (utils.isArray(topic))
        return lifetime.subscribe(wrapTopicArray());
    else
        return lifetime.subscribe(wrapTopicObject());

    function wrapTopicArray() {
        var result = {};
        utils.each(topic, function(topicName) {
            result[topicName] = wrapHandler(handler);
        });
        return result;
    }
    
    function wrapTopicObject() {
        return utils.map(topic, function (func, topicName) {
            return lifetime.subscribe(topicName, wrapHandler(func));
        });
    }

    function wrapHandler(func) {
        return function() {
            lifetime.end();
            func.apply(self, arguments);
        };
    }
};


// SubscriberList.js

Tribe.PubSub.SubscriberList = function() {
    var subscribers = {};
    var lastUid = -1;

    this.get = function (publishedTopic) {
        var matching = [];
        for (var registeredTopic in subscribers)
            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))
                matching = matching.concat(subscribers[registeredTopic]);
        return matching;
    };

    this.add = function (topic, handler) {
        var token = (++lastUid).toString();
        if (!subscribers.hasOwnProperty(topic))
            subscribers[topic] = [];
        subscribers[topic].push({ topic: topic, handler: handler, token: token });
        return token;
    };

    this.remove = function(token) {
        for (var m in subscribers)
            if (subscribers.hasOwnProperty(m))
                for (var i = 0, l = subscribers[m].length; i < l; i++)
                    if (subscribers[m][i].token === token) {
                        subscribers[m].splice(i, 1);
                        return token;
                    }

        return false;
    };

    function topicMatches(published, subscriber) {
        if (subscriber === '*')
            return true;
        
        var expression = "^" + subscriber
            .replace(/\./g, "\\.")
            .replace(/\*/g, "[^\.]*") + "$";
        return published.match(expression);
    }
};


// utils.js

Tribe.PubSub.utils = {};
(function(utils) {
    utils.isArray = function (source) {
        return source.constructor === Array;
    };

    // The following functions are taken from the underscore library, duplicated to avoid dependency. License at http://underscorejs.org.
    var nativeForEach = Array.prototype.forEach;
    var nativeMap = Array.prototype.map;
    var breaker = {};

    utils.each = function (obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) return;
                }
            }
        }
    };

    utils.map = function (obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        utils.each(obj, function (value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        return results;
    };

    utils.copyProperties = function (source, target, properties) {
        for (var i = 0, l = properties.length; i < l; i++) {
            var property = properties[i];
            if(source.hasOwnProperty(property))
                target[property] = source[property];
        }
    };
})(Tribe.PubSub.utils);



// exports.js

if (typeof(module) !== 'undefined')
    module.exports = new Tribe.PubSub();

},{}],13:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/pane' };
//pane
},{}],14:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/resource' };
//resource
},{}],15:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/script' };
//script
},{}],16:[function(require,module,exports){
module.exports = {
    serialize: function (source) {
        return JSON.stringify(this.extractMetadata(source));
    },
    extractMetadata: function (source) {
        var target = source,
            metadata = {};
        removeObservables();
        return {
            target: target,
            metadata: metadata
        };

        function removeObservables() {
            metadata.observables = [];
            for (var property in target)
                if (target.hasOwnProperty(property) && ko.isObservable(target[property])) {
                    target[property] = target[property]();
                    metadata.observables.push(property);
                }

        }
    },
    deserialize: function (source) {
        source = JSON.parse(source);
        if (source.target)
            return this.applyMetadata(source.target, source.metadata);
        return source;
    },
    applyMetadata: function (target, metadata) {
        if (metadata)
            restoreObservables();
        return target;

        function restoreObservables() {
            var observables = metadata.observables;
            for (var i = 0, l = observables.length; i < l; i++)
                restoreProperty(observables[i]);
        }

        function restoreProperty(property) {
            target[property] = createObservable(target[property]);
        }

        function createObservable(value) {
            return value.constructor === Array ?
                ko.observableArray(value) :
                ko.observable(value);
        }
    }
};

},{}]},{},[13,14,15,1,3,4,5,"r5NbTJ",8,9,10])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcUHJvamVjdHNcXFRyaWJlXFxOb2RlXFxub2RlX21vZHVsZXNcXHRyaWJlXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9QdWJTdWIuZXh0ZW5zaW9ucy5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9QdWJzdWIuZXh0ZW5zaW9ucy5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9jb21wb3NpdGUuZGVidWcuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvY29tcG9zaXRlLmpzIiwiYzovUHJvamVjdHMvVHJpYmUvTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L2h1Yi5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9pbmRleC5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9wdWJzdWIuZGVidWcuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvcmVnaXN0ZXIuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvc2VydmljZXMuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9sb2dnZXIuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9ub2RlX21vZHVsZXMvdHJpYmUucHVic3ViL0J1aWxkL1RyaWJlLlB1YlN1Yi5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL3Rlc3RzL2ZpbGVzL2J1aWxkL3BhbmVzL3BhbmUuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS90ZXN0cy9maWxlcy9idWlsZC9yZXNvdXJjZXMvcmVzb3VyY2UuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS90ZXN0cy9maWxlcy9idWlsZC9zY3JpcHRzL3NjcmlwdC5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL3V0aWxpdGllcy9zZXJpYWxpemVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2w4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlQuc2NyaXB0RW52aXJvbm1lbnQgPSB7IHJlc291cmNlUGF0aDogJy9QdWJTdWIuZXh0ZW5zaW9ucycgfTtcbnZhciBodWIgPSByZXF1aXJlKCcuL2h1YicpLFxyXG4gICAgcHVic3ViID0gcmVxdWlyZSgndHJpYmUnKS5wdWJzdWIsXHJcbiAgICBzZXJpYWxpemVyID0gcmVxdWlyZSgndHJpYmUvdXRpbGl0aWVzL3NlcmlhbGl6ZXInKSxcclxuICAgIHB1YnN1YiA9IHJlcXVpcmUoJ3RyaWJlLnB1YnN1YicpO1xyXG5cclxuVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBmdW5jdGlvbiAoaWQsIHBhdGgsIGRhdGEpIHtcclxuICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gJy8nKVxyXG4gICAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xyXG5cclxuICAgIHZhciBzYWdhID0gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHRoaXMsIHNhZ2FEZWZpbml0aW9uKHBhdGgpKTtcclxuXHJcbiAgICBpZiAoaWQpIHtcclxuICAgICAgICBzYWdhLmlkID0gaWQ7XHJcbiAgICAgICAgYXR0YWNoVG9IdWIoc2FnYSk7XHJcbiAgICAgICAgaHViLnN0YXJ0U2FnYShwYXRoLCBpZCwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNhZ2Euc3RhcnQoZGF0YSk7XHJcbn07XHJcblxyXG5UcmliZS5QdWJTdWIucHJvdG90eXBlLmpvaW5TYWdhID0gZnVuY3Rpb24gKGlkLCBwYXRoLCBkYXRhKSB7XHJcbiAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAkLndoZW4oJC5nZXQoJ0RhdGEvJyArIGlkICsgJy8nICsgaWQpKVxyXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzYWdhID0gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHNlbGYsIHNhZ2FEZWZpbml0aW9uKGRhdGEucGF0aCkpO1xyXG4gICAgICAgICAgICBzYWdhLmlkID0gaWQ7XHJcbiAgICAgICAgICAgIHNhZ2Euam9pbihzZXJpYWxpemVyLmRlc2VyaWFsaXplKGRhdGEuZGF0YSkpO1xyXG4gICAgICAgICAgICBhdHRhY2hUb0h1YihzYWdhKTtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzYWdhKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5mYWlsKGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAgICAgaWYgKHJlYXNvbi5zdGF0dXMgPT09IDQwNCAmJiBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FnYSA9IHNlbGYuc3RhcnRTYWdhKGlkLCBwYXRoLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2FnYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzYWdhRGVmaW5pdGlvbihwYXRoKSB7XHJcbiAgICByZXR1cm4gVC5jb250ZXh0KCkuc2FnYXNbcGF0aF0uY29uc3RydWN0b3I7XHJcbn1cclxuXHJcbi8vIG5lZWQgdG8gYWxzbyBiZSBhYmxlIHRvIGRldGFjaFxyXG5mdW5jdGlvbiBhdHRhY2hUb0h1YihzYWdhKSB7XHJcbiAgICBodWIuam9pbihzYWdhLmlkKTtcclxuICAgIHNhZ2EucHVic3ViLnN1YnNjcmliZShzYWdhLnRvcGljcywgZnVuY3Rpb24gKG1lc3NhZ2UsIGVudmVsb3BlKSB7XHJcbiAgICAgICAgZW52ZWxvcGUuc2FnYUlkID0gc2FnYS5pZDtcclxuICAgICAgICBodWIucHVibGlzaChlbnZlbG9wZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLnN0YXJ0U2FnYTtcclxuVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5qb2luU2FnYSA9IFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuam9pblNhZ2E7XHJcblRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLnN0YXJ0U2FnYTtcclxuVHJpYmUuUHViU3ViLkNoYW5uZWwucHJvdG90eXBlLmpvaW5TYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5qb2luU2FnYTtcclxuXHJcblRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHRvcGljcykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGh1Yi5qb2luKHRoaXMuaWQpO1xyXG4gICAgdGhpcy5zdWJzY3JpYmUodG9waWNzIHx8ICcqJywgZnVuY3Rpb24oZGF0YSwgZW52ZWxvcGUpIHtcclxuICAgICAgICBodWIucHVibGlzaChlbnZlbG9wZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGh1Yi5sZWF2ZShzZWxmLmNoYW5uZWxJZCk7XHJcbiAgICAgICAgZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJ2YXIgaHViID0gcmVxdWlyZSgnLi9odWInKSxcclxuICAgIHB1YnN1YiA9IHJlcXVpcmUoJ3RyaWJlJykucHVic3ViLFxyXG4gICAgc2VyaWFsaXplciA9IHJlcXVpcmUoJ3RyaWJlL3V0aWxpdGllcy9zZXJpYWxpemVyJyksXHJcbiAgICBwdWJzdWIgPSByZXF1aXJlKCd0cmliZS5wdWJzdWInKTtcclxuXHJcblRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuc3RhcnRTYWdhID0gZnVuY3Rpb24gKGlkLCBwYXRoLCBkYXRhKSB7XHJcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgIT09ICcvJylcclxuICAgICAgICBwYXRoID0gJy8nICsgcGF0aDtcclxuXHJcbiAgICB2YXIgc2FnYSA9IG5ldyBUcmliZS5QdWJTdWIuU2FnYSh0aGlzLCBzYWdhRGVmaW5pdGlvbihwYXRoKSk7XHJcblxyXG4gICAgaWYgKGlkKSB7XHJcbiAgICAgICAgc2FnYS5pZCA9IGlkO1xyXG4gICAgICAgIGF0dGFjaFRvSHViKHNhZ2EpO1xyXG4gICAgICAgIGh1Yi5zdGFydFNhZ2EocGF0aCwgaWQsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzYWdhLnN0YXJ0KGRhdGEpO1xyXG59O1xyXG5cclxuVHJpYmUuUHViU3ViLnByb3RvdHlwZS5qb2luU2FnYSA9IGZ1bmN0aW9uIChpZCwgcGF0aCwgZGF0YSkge1xyXG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgJC53aGVuKCQuZ2V0KCdEYXRhLycgKyBpZCArICcvJyArIGlkKSlcclxuICAgICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2FnYSA9IG5ldyBUcmliZS5QdWJTdWIuU2FnYShzZWxmLCBzYWdhRGVmaW5pdGlvbihkYXRhLnBhdGgpKTtcclxuICAgICAgICAgICAgc2FnYS5pZCA9IGlkO1xyXG4gICAgICAgICAgICBzYWdhLmpvaW4oc2VyaWFsaXplci5kZXNlcmlhbGl6ZShkYXRhLmRhdGEpKTtcclxuICAgICAgICAgICAgYXR0YWNoVG9IdWIoc2FnYSk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2FnYSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmFpbChmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWFzb24uc3RhdHVzID09PSA0MDQgJiYgcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhZ2EgPSBzZWxmLnN0YXJ0U2FnYShpZCwgcGF0aCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNhZ2EpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2FnYURlZmluaXRpb24ocGF0aCkge1xyXG4gICAgcmV0dXJuIFQuY29udGV4dCgpLnNhZ2FzW3BhdGhdLmNvbnN0cnVjdG9yO1xyXG59XHJcblxyXG4vLyBuZWVkIHRvIGFsc28gYmUgYWJsZSB0byBkZXRhY2hcclxuZnVuY3Rpb24gYXR0YWNoVG9IdWIoc2FnYSkge1xyXG4gICAgaHViLmpvaW4oc2FnYS5pZCk7XHJcbiAgICBzYWdhLnB1YnN1Yi5zdWJzY3JpYmUoc2FnYS50b3BpY3MsIGZ1bmN0aW9uIChtZXNzYWdlLCBlbnZlbG9wZSkge1xyXG4gICAgICAgIGVudmVsb3BlLnNhZ2FJZCA9IHNhZ2EuaWQ7XHJcbiAgICAgICAgaHViLnB1Ymxpc2goZW52ZWxvcGUpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblRyaWJlLlB1YlN1Yi5MaWZldGltZS5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2E7XHJcblRyaWJlLlB1YlN1Yi5MaWZldGltZS5wcm90b3R5cGUuam9pblNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLmpvaW5TYWdhO1xyXG5UcmliZS5QdWJTdWIuQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2E7XHJcblRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5qb2luU2FnYSA9IFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuam9pblNhZ2E7XHJcblxyXG5UcmliZS5QdWJTdWIuQ2hhbm5lbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh0b3BpY3MpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBodWIuam9pbih0aGlzLmlkKTtcclxuICAgIHRoaXMuc3Vic2NyaWJlKHRvcGljcyB8fCAnKicsIGZ1bmN0aW9uKGRhdGEsIGVudmVsb3BlKSB7XHJcbiAgICAgICAgaHViLnB1Ymxpc2goZW52ZWxvcGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBodWIubGVhdmUoc2VsZi5jaGFubmVsSWQpO1xyXG4gICAgICAgIGVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL2NvbXBvc2l0ZS5kZWJ1ZycgfTtcbi8qISBUaGUgVHJpYmUgcGxhdGZvcm0gaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgaHR0cDovL3RyaWJlanMuY29tLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gKi9cclxuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcXG4gICAgaWYgKHR5cGVvZiAoJCkgPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgdGhyb3cgJ2pRdWVyeSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUga25vY2tvdXQuY29tcG9zaXRlIGNhbiBpbml0aWFsaXNlJztcXG4gICAgaWYgKHR5cGVvZiAoa28pID09PSAndW5kZWZpbmVkJylcXG4gICAgICAgIHRocm93ICdrbm9ja291dC5qcyBtdXN0IGJlIGxvYWRlZCBiZWZvcmUga25vY2tvdXQuY29tcG9zaXRlIGNhbiBpbml0aWFsaXNlJztcXG5cXG4gICAgZ2xvYmFsLlQgPSBUIHx8IHt9O1xcbiAgICBnbG9iYWwuVC5FdmVudHMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuRmFjdG9yaWVzID0ge307XFxuICAgIGdsb2JhbC5ULkxvYWRIYW5kbGVycyA9IHt9O1xcbiAgICBnbG9iYWwuVC5Mb2FkU3RyYXRlZ2llcyA9IHt9O1xcbiAgICBnbG9iYWwuVC5UcmFuc2l0aW9ucyA9IHt9O1xcbiAgICBnbG9iYWwuVC5UeXBlcyA9IHt9O1xcbiAgICBnbG9iYWwuVC5VdGlscyA9IHt9O1xcblxcbiAgICAkKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgJCgnaGVhZCcpLmFwcGVuZCgnPHN0eWxlIGNsYXNzPVxcXCJfX3RyaWJlXFxcIj4uX19yZW5kZXJpbmcgeyBwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDAwcHg7IGxlZnQ6IC0xMDAwMHB4OyB9PC9zdHlsZT4nKTtcXG4gICAgfSk7XFxufSkod2luZG93IHx8IHRoaXMpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9zZXR1cC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIHN5bmNocm9ub3VzOiBmYWxzZSxcXG4gICAgICAgIGhhbmRsZUV4Y2VwdGlvbnM6IHRydWUsXFxuICAgICAgICBiYXNlUGF0aDogJycsXFxuICAgICAgICBsb2FkU3RyYXRlZ3k6ICdhZGhvYycsXFxuICAgICAgICBldmVudHM6IFsnbG9hZFJlc291cmNlcycsICdjcmVhdGVQdWJTdWInLCAnY3JlYXRlTW9kZWwnLCAnaW5pdGlhbGlzZU1vZGVsJywgJ3JlbmRlclBhbmUnLCAncmVuZGVyQ29tcGxldGUnLCAnYWN0aXZlJywgJ2Rpc3Bvc2UnXVxcbiAgICB9O1xcbn07XFxuVC5vcHRpb25zID0gVC5kZWZhdWx0T3B0aW9ucygpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9vcHRpb25zLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxudmFyIGxldmVsID0gNDtcXG52YXIgbGV2ZWxzID0ge1xcbiAgICBkZWJ1ZzogNCxcXG4gICAgaW5mbzogMyxcXG4gICAgd2FybjogMixcXG4gICAgZXJyb3I6IDEsXFxuICAgIG5vbmU6IDBcXG59O1xcblxcblQubG9nZ2VyID0ge1xcbiAgICBzZXRMZXZlbDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XFxuICAgICAgICBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XFxuICAgICAgICBpZiAobGV2ZWwgPT09IHVuZGVmaW5lZCkgbGV2ZWwgPSA0O1xcbiAgICB9LFxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcXG4gICAgICAgIGlmIChsZXZlbCA+PSA0KVxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCgnREVCVUc6ICcgKyBtZXNzYWdlKSk7XFxuICAgIH0sXFxuICAgIGluZm86IGZ1bmN0aW9uIChtZXNzYWdlKSB7XFxuICAgICAgICBpZiAobGV2ZWwgPj0gMylcXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKCdJTkZPOiAnICsgbWVzc2FnZSkpO1xcbiAgICB9LFxcbiAgICB3YXJuOiBmdW5jdGlvbiAobWVzc2FnZSkge1xcbiAgICAgICAgaWYgKGxldmVsID49IDIpXFxuICAgICAgICAgICAgY29uc29sZS53YXJuKCgnV0FSTjogJyArIG1lc3NhZ2UpKTtcXG4gICAgfSxcXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvcikge1xcbiAgICAgICAgaWYgKGxldmVsID49IDEpXFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcigoJ0VSUk9SOiAnICsgbWVzc2FnZSArICdcXFxcbicpLCBhcGkuZXJyb3JEZXRhaWxzKGVycm9yKSk7XFxuICAgIH0sXFxuICAgIGVycm9yRGV0YWlsczogZnVuY3Rpb24gKGV4KSB7XFxuICAgICAgICBpZiAoIWV4KSByZXR1cm4gJyc7XFxuICAgICAgICByZXR1cm4gKGV4LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpID8gZXggOlxcbiAgICAgICAgICAgIChleC5zdGFjayB8fCAnJykgKyAoZXguaW5uZXIgPyAnXFxcXG5cXFxcbicgKyB0aGlzLmVycm9yRGV0YWlscyhleC5pbm5lcikgOiAnXFxcXG4nKTtcXG4gICAgfSxcXG4gICAgbG9nOiBmdW5jdGlvbiAobWVzc2FnZSkge1xcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XFxuICAgIH1cXG59O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9sb2dnZXIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuY3NzQ2xhc3MgPSB7XFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlKSk7XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5lbnRlclByZXNzZWQgPSBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIoMTMpO1xcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZXNjYXBlUHJlc3NlZCA9IGtleVByZXNzZWRCaW5kaW5nSGFuZGxlcigyNyk7XFxuICAgIFxcbiAgICBmdW5jdGlvbiBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIod2hpY2gpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdmFsdWVBY2Nlc3NvcigpO1xcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSlcXG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmtleXVwKHRlc3RLZXkpO1xcblxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXN0S2V5KGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IHdoaWNoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8kZWxlbWVudC5ibHVyKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJGVsZW1lbnQudmFsKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9iaW5kaW5nSGFuZGxlcnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKHV0aWxzKSB7ICAgIFxcbiAgICB1dGlscy5lYWNoID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XFxuICAgICAgICByZXR1cm4gJC5lYWNoKGNvbGxlY3Rpb24gfHwgW10sIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IodmFsdWUsIGluZGV4KTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvLyBqUXVlcnkgbWFwIGZsYXR0ZW5zIHJldHVybmVkIGFycmF5cyAtIHdlIGRvbid0IHdhbnQgdGhpcyBmb3IgZ3JpZHNcXG4gICAgdXRpbHMubWFwID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICB1dGlscy5lYWNoKGNvbGxlY3Rpb24gfHwgW10sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yKHZhbHVlLCBpbmRleCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5maWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgaXRlcmF0b3IpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgICQuZWFjaChhcnJheSB8fCBbXSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XFxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKHZhbHVlLCBpbmRleCkpXFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfTtcXG5cXG4gICAgdXRpbHMucGx1Y2sgPSBmdW5jdGlvbihhcnJheSwgcHJvcGVydHkpIHtcXG4gICAgICAgIHJldHVybiB1dGlscy5tYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlW3Byb3BlcnR5XTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyYXksIGluaXRpYWxWYWx1ZSwgcmVkdWNlRnVuY3Rpb24pIHtcXG4gICAgICAgIHV0aWxzLmVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHJlZHVjZUZ1bmN0aW9uKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGluZGV4LCBhcnJheSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XFxuICAgIH07XFxufSkoVC5VdGlscyk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9jb2xsZWN0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbi8vIHRoaXMgaXMgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1iYnEvLCBDb3B5cmlnaHQgKGMpIDIwMTAgXFxcIkNvd2JveVxcXCIgQmVuIEFsbWFuIGFuZCBhbHNvIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcblxcbi8vIERlc2VyaWFsaXplIGEgcGFyYW1zIHN0cmluZyBpbnRvIGFuIG9iamVjdCwgb3B0aW9uYWxseSBjb2VyY2luZyBudW1iZXJzLFxcbi8vIGJvb2xlYW5zLCBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzOyB0aGlzIG1ldGhvZCBpcyB0aGUgY291bnRlcnBhcnQgdG8gdGhlXFxuLy8gaW50ZXJuYWwgalF1ZXJ5LnBhcmFtIG1ldGhvZC5cXG5ULlV0aWxzLmRlcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1zLCBjb2VyY2UpIHtcXG4gICAgdmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcXG4gICAgdmFyIG9iaiA9IHt9LFxcbiAgICAgIGNvZXJjZV90eXBlcyA9IHsgJ3RydWUnOiAhMCwgJ2ZhbHNlJzogITEsICdudWxsJzogbnVsbCB9O1xcblxcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5hbWU9dmFsdWUgcGFpcnMuXFxuICAgICQuZWFjaChwYXJhbXMucmVwbGFjZSgvXFxcXCsvZywgJyAnKS5zcGxpdCgnJicpLCBmdW5jdGlvbiAoaiwgdikge1xcbiAgICAgICAgdmFyIHBhcmFtID0gdi5zcGxpdCgnPScpLFxcbiAgICAgICAgICBrZXkgPSBkZWNvZGUocGFyYW1bMF0pLFxcbiAgICAgICAgICB2YWwsXFxuICAgICAgICAgIGN1ciA9IG9iaixcXG4gICAgICAgICAgaSA9IDAsXFxuXFxuICAgICAgICAgIC8vIElmIGtleSBpcyBtb3JlIGNvbXBsZXggdGhhbiAnZm9vJywgbGlrZSAnYVtdJyBvciAnYVtiXVtjXScsIHNwbGl0IGl0XFxuICAgICAgICAgIC8vIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cXG4gICAgICAgICAga2V5cyA9IGtleS5zcGxpdCgnXVsnKSxcXG4gICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xcblxcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGtleXMgcGFydCBjb250YWlucyBbIGFuZCB0aGUgbGFzdCBlbmRzIHdpdGggXSwgdGhlbiBbXVxcbiAgICAgICAgLy8gYXJlIGNvcnJlY3RseSBiYWxhbmNlZC5cXG4gICAgICAgIGlmICgvXFxcXFsvLnRlc3Qoa2V5c1swXSkgJiYgL1xcXFxdJC8udGVzdChrZXlzW2tleXNfbGFzdF0pKSB7XFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyBdIGZyb20gdGhlIGxhc3Qga2V5cyBwYXJ0LlxcbiAgICAgICAgICAgIGtleXNba2V5c19sYXN0XSA9IGtleXNba2V5c19sYXN0XS5yZXBsYWNlKC9cXFxcXSQvLCAnJyk7XFxuXFxuICAgICAgICAgICAgLy8gU3BsaXQgZmlyc3Qga2V5cyBwYXJ0IGludG8gdHdvIHBhcnRzIG9uIHRoZSBbIGFuZCBhZGQgdGhlbSBiYWNrIG9udG9cXG4gICAgICAgICAgICAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBrZXlzIGFycmF5LlxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLnNoaWZ0KCkuc3BsaXQoJ1snKS5jb25jYXQoa2V5cyk7XFxuXFxuICAgICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBCYXNpYyAnZm9vJyBzdHlsZSBrZXkuXFxuICAgICAgICAgICAga2V5c19sYXN0ID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lPXZhbHVlIHBhaXIsIG9yIGp1c3QgYSBuYW1lP1xcbiAgICAgICAgaWYgKHBhcmFtLmxlbmd0aCA9PT0gMikge1xcbiAgICAgICAgICAgIHZhbCA9IGRlY29kZShwYXJhbVsxXSk7XFxuXFxuICAgICAgICAgICAgLy8gQ29lcmNlIHZhbHVlcy5cXG4gICAgICAgICAgICBpZiAoY29lcmNlKSB7XFxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbCAmJiAhaXNOYU4odmFsKSA/ICt2YWwgICAgICAgICAgICAgIC8vIG51bWJlclxcbiAgICAgICAgICAgICAgICAgIDogdmFsID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCAgICAgICAgIC8vIHVuZGVmaW5lZFxcbiAgICAgICAgICAgICAgICAgIDogY29lcmNlX3R5cGVzW3ZhbF0gIT09IHVuZGVmaW5lZCA/IGNvZXJjZV90eXBlc1t2YWxdIC8vIHRydWUsIGZhbHNlLCBudWxsXFxuICAgICAgICAgICAgICAgICAgOiB2YWw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChrZXlzX2xhc3QpIHtcXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxleCBrZXksIGJ1aWxkIGRlZXAgb2JqZWN0IHN0cnVjdHVyZSBiYXNlZCBvbiBhIGZldyBydWxlczpcXG4gICAgICAgICAgICAgICAgLy8gKiBUaGUgJ2N1cicgcG9pbnRlciBzdGFydHMgYXQgdGhlIG9iamVjdCB0b3AtbGV2ZWwuXFxuICAgICAgICAgICAgICAgIC8vICogW10gPSBhcnJheSBwdXNoIChuIGlzIHNldCB0byBhcnJheSBsZW5ndGgpLCBbbl0gPSBhcnJheSBpZiBuIGlzIFxcbiAgICAgICAgICAgICAgICAvLyAgIG51bWVyaWMsIG90aGVyd2lzZSBvYmplY3QuXFxuICAgICAgICAgICAgICAgIC8vICogSWYgYXQgdGhlIGxhc3Qga2V5cyBwYXJ0LCBzZXQgdGhlIHZhbHVlLlxcbiAgICAgICAgICAgICAgICAvLyAqIEZvciBlYWNoIGtleXMgcGFydCwgaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgdW5kZWZpbmVkIGNyZWF0ZSBhblxcbiAgICAgICAgICAgICAgICAvLyAgIG9iamVjdCBvciBhcnJheSBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgbmV4dCBrZXlzIHBhcnQuXFxuICAgICAgICAgICAgICAgIC8vICogTW92ZSB0aGUgJ2N1cicgcG9pbnRlciB0byB0aGUgbmV4dCBsZXZlbC5cXG4gICAgICAgICAgICAgICAgLy8gKiBSaW5zZSAmIHJlcGVhdC5cXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPD0ga2V5c19sYXN0OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV0gPT09ICcnID8gY3VyLmxlbmd0aCA6IGtleXNbaV07XFxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXJba2V5XSA9IGkgPCBrZXlzX2xhc3RcXG4gICAgICAgICAgICAgICAgICAgICAgPyBjdXJba2V5XSB8fCAoa2V5c1tpICsgMV0gJiYgaXNOYU4oa2V5c1tpICsgMV0pID8ge30gOiBbXSlcXG4gICAgICAgICAgICAgICAgICAgICAgOiB2YWw7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUga2V5LCBldmVuIHNpbXBsZXIgcnVsZXMsIHNpbmNlIG9ubHkgc2NhbGFycyBhbmQgc2hhbGxvd1xcbiAgICAgICAgICAgICAgICAvLyBhcnJheXMgYXJlIGFsbG93ZWQuXFxuXFxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkob2JqW2tleV0pKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXMgYWxyZWFkeSBhbiBhcnJheSwgc28gcHVzaCBvbiB0aGUgbmV4dCB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcXG5cXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXNuJ3QgYW4gYXJyYXksIGJ1dCBzaW5jZSBhIHNlY29uZCB2YWx1ZSBoYXMgYmVlbiBzcGVjaWZpZWQsXFxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHZhbCBpbnRvIGFuIGFycmF5LlxcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV0sIHZhbF07XFxuXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXMgYSBzY2FsYXIuXFxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XFxuICAgICAgICAgICAgLy8gTm8gdmFsdWUgd2FzIGRlZmluZWQsIHNvIHNldCBzb21ldGhpbmcgbWVhbmluZ2Z1bC5cXG4gICAgICAgICAgICBvYmpba2V5XSA9IGNvZXJjZVxcbiAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgIDogJyc7XFxuICAgICAgICB9XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gb2JqO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9kZXBhcmFtLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uKCkge1xcbiAgICBULlV0aWxzLmVtYmVkU3RhdGUgPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRleHQsIG5vZGUpIHtcXG4gICAgICAgIGVtYmVkUHJvcGVydHkobW9kZWwsICdjb250ZXh0JywgY29udGV4dCk7XFxuICAgICAgICBlbWJlZFByb3BlcnR5KG1vZGVsLCAnbm9kZScsIG5vZGUpO1xcbiAgICB9O1xcblxcbiAgICBULlV0aWxzLmNvbnRleHRGb3IgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Q29udGV4dChrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcXG4gICAgfTtcXG5cXG4gICAgVC5VdGlscy5leHRyYWN0Q29udGV4dCA9IGZ1bmN0aW9uIChrb0JpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICByZXR1cm4ga29CaW5kaW5nQ29udGV4dCAmJiBlbWJlZGRlZFByb3BlcnR5KGtvQmluZGluZ0NvbnRleHQuJHJvb3QsICdjb250ZXh0Jyk7XFxuICAgIH07XFxuXFxuICAgIFQuVXRpbHMuZXh0cmFjdE5vZGUgPSBmdW5jdGlvbiAoa29CaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuIGtvQmluZGluZ0NvbnRleHQgJiYgZW1iZWRkZWRQcm9wZXJ0eShrb0JpbmRpbmdDb250ZXh0LiRyb290LCAnbm9kZScpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBlbWJlZFByb3BlcnR5KHRhcmdldCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKCF0YXJnZXQpXFxuICAgICAgICAgICAgdGhyb3cgXFxcIkNhbid0IGVtYmVkIHByb3BlcnR5IGluIGZhbHN5IHZhbHVlXFxcIjtcXG4gICAgICAgIHRhcmdldFsnX18nICsga2V5XSA9IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGVtYmVkZGVkUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcXG4gICAgICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0WydfXycgKyBrZXldO1xcbiAgICB9XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2VtYmVkZGVkQ29udGV4dC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQuVXRpbHMuZWxlbWVudERlc3Ryb3llZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgICAgICBpZiAoZWxlbWVudC5jb25zdHJ1Y3RvciA9PT0galF1ZXJ5KVxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50WzBdO1xcblxcbiAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuXFxuICAgICAgICAvLyBSZXNvbHZlIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIHVzaW5nIGpRdWVyeS4gVGhpcyBpcyBhIGZhbGxiYWNrIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBET01Ob2RlUmVtb3ZlZCBhbmQgYWxzbyBleGVjdXRlcyBzeW5jaHJvbm91c2x5LlxcbiAgICAgICAgJChlbGVtZW50KS5vbignZGVzdHJveWVkJywgcmVzb2x2ZSk7XFxuXFxuICAgICAgICAvLyBSZXNvbHZlIHVzaW5nIHRoZSBET01Ob2RlUmVtb3ZlZCBldmVudC4gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHRoaXMuXFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwiRE9NTm9kZVJlbW92ZWRcXFwiLCBtYXRjaEVsZW1lbnQpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hFbGVtZW50KGV2ZW50KSB7XFxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudClcXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcXG4gICAgICAgICAgICAkKGVsZW1lbnQpLm9mZignZGVzdHJveWVkJywgcmVzb2x2ZSk7XFxuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdET01Ob2RlUmVtb3ZlZCcsIG1hdGNoRWxlbWVudCk7XFxuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgfTtcXG5cXG4gICAgLy8gdGhpcyB1c2VkIHRvIHVzZSBET00gZnVuY3Rpb25zIHRvIHJhaXNlIGV2ZW50cywgYnV0IElFOCBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tIGV2ZW50c1xcbiAgICAvLyB3ZSdsbCB1c2UgalF1ZXJ5LCBidXQgZXhwb3NlIHRoZSBvcmlnaW5hbEV2ZW50IGZvciBET00gZXZlbnRzIGFuZCB0aGUgalF1ZXJ5IGV2ZW50XFxuICAgIC8vIGZvciBjdXN0b20gZXZlbnRzIChvcmlnaW5hbEV2ZW50IGlzIG51bGwgZm9yIGN1c3RvbSBldmVudHMpLlxcbiAgICBULlV0aWxzLnJhaXNlRG9jdW1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudERhdGEpIHtcXG4gICAgICAgIHZhciBlID0gJC5FdmVudChuYW1lKTtcXG4gICAgICAgIGUuZXZlbnREYXRhID0gZXZlbnREYXRhO1xcbiAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcihlKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGhhbmRsZXJzID0ge307XFxuXFxuICAgIC8vIGlmIGEgaGFuZGxlciBpcyB1c2VkIGZvciBtb3JlIHRoYW4gb25lIGV2ZW50LCBhIGxlYWsgd2lsbCBvY2N1clxcbiAgICBULlV0aWxzLmhhbmRsZURvY3VtZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xcbiAgICAgICAgJChkb2N1bWVudCkub24obmFtZSwgaW50ZXJuYWxIYW5kbGVyKTtcXG4gICAgICAgIGhhbmRsZXJzW2hhbmRsZXJdID0gaW50ZXJuYWxIYW5kbGVyO1xcbiAgICAgICAgXFxuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEhhbmRsZXIoZSkge1xcbiAgICAgICAgICAgIGhhbmRsZXIoZS5vcmlnaW5hbEV2ZW50IHx8IGUpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBULlV0aWxzLmRldGFjaERvY3VtZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKG5hbWUsIGhhbmRsZXJzW2hhbmRsZXJdKTtcXG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1toYW5kbGVyXTtcXG4gICAgfTtcXG59KSgpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvZXZlbnRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy50cnlDYXRjaCA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGhhbmRsZUV4Y2VwdGlvbnMsIG1lc3NhZ2UpIHtcXG4gICAgaWYgKGhhbmRsZUV4Y2VwdGlvbnMpXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XFxuICAgICAgICB9IGNhdGNoIChleCkge1xcbiAgICAgICAgICAgIFQubG9nZ2VyLmVycm9yKG1lc3NhZ2UsIGV4KTtcXG4gICAgICAgIH1cXG4gICAgZWxzZVxcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvZXhjZXB0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQuVXRpbHMuaWRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG5leHQ6IChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpZCA9IDA7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQrKztcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9KSgpXFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB2YXIgZ2VuZXJhdG9yID0gVC5VdGlscy5pZEdlbmVyYXRvcigpO1xcbiAgICBULlV0aWxzLmdldFVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvci5uZXh0KCk7XFxuICAgIH07XFxufSkoKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2lkR2VuZXJhdG9yLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pIHtcXG4gICAgICAgICd1c2Ugc3RyaWN0JztcXG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbiwgaywgdCA9IE9iamVjdCh0aGlzKSxcXG4gICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcXG5cXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBuID0gMDtcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcXG4gICAgICAgICAgICBpZiAobiAhPSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cXG4gICAgICAgICAgICAgICAgbiA9IDA7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9IDAgJiYgbiAhPSBJbmZpbml0eSAmJiBuICE9IC1JbmZpbml0eSkge1xcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChuID49IGxlbikge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCkgOyBrIDwgbGVuOyBrKyspIHtcXG4gICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9O1xcbn1cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2luZGV4T2YuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCQpIHtcXG4gICAgJC5jb21wbGV0ZSA9IGZ1bmN0aW9uIChkZWZlcnJlZHMpIHtcXG4gICAgICAgIHZhciB3cmFwcGVycyA9IFtdO1xcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xcbiAgICAgICAgdmFyIHJlc29sdmUgPSBmYWxzZTtcXG5cXG4gICAgICAgIGlmICgkLmlzQXJyYXkoZGVmZXJyZWRzKSlcXG4gICAgICAgICAgICAkLmVhY2goZGVmZXJyZWRzLCB3cmFwRGVmZXJyZWQpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHdyYXBEZWZlcnJlZCgwLCBkZWZlcnJlZHMpO1xcblxcbiAgICAgICAgJC53aGVuLmFwcGx5KCQsIHdyYXBwZXJzKS5kb25lKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJlc29sdmUgP1xcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCkgOlxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcblxcbiAgICAgICAgZnVuY3Rpb24gd3JhcERlZmVycmVkKGluZGV4LCBvcmlnaW5hbCkge1xcbiAgICAgICAgICAgIHdyYXBwZXJzLnB1c2goJC5EZWZlcnJlZChmdW5jdGlvbiAodGhpc0RlZmVycmVkKSB7XFxuICAgICAgICAgICAgICAgICQud2hlbihvcmlnaW5hbClcXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEZWZlcnJlZC5yZXNvbHZlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgIH07XFxufSkoalF1ZXJ5KTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2pxdWVyeS5jb21wbGV0ZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBvbGRDbGVhbiA9ICQuY2xlYW5EYXRhO1xcblxcbiAgICAvLyBrbm9ja291dCBhbHNvIGNhbGxzIGNsZWFuRGF0YSBmcm9tIGl0J3MgY2xlYW5Ob2RlIG1ldGhvZCAtIGF2b2lkIGFueSBsb29wc1xcbiAgICAvL3ZhciBjbGVhbmluZyA9IHt9O1xcblxcbiAgICAkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IChlbGVtZW50ID0gZWxlbWVudHNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xcbiAgICAgICAgICAgIC8vaWYgKCFjbGVhbmluZ1tlbGVtZW50XSkge1xcbiAgICAgICAgICAgICAgICAvL2NsZWFuaW5nW2VsZW1lbnRdID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiZGVzdHJveWVkXFxcIik7XFxuICAgICAgICAgICAgICAgIC8vZGVsZXRlIGNsZWFuaW5nW2VsZW1lbnRdO1xcbiAgICAgICAgICAgIC8vfVxcbiAgICAgICAgfVxcbiAgICAgICAgb2xkQ2xlYW4oZWxlbWVudHMpO1xcbiAgICB9O1xcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9qcXVlcnkuZGVzdHJveWVkLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy5jbGVhbkVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAvLyBwcmV2ZW50IGtub2Nrb3V0IGZyb20gY2FsbGluZyBjbGVhbkRhdGEgXFxuICAgIC8vIC0gY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiB1bHRpbWF0ZWx5IHJlc3VsdCBmcm9tIGNsZWFuRGF0YSBiZWluZyBjYWxsZWQgYnkgalF1ZXJ5LCBzbyBhIGxvb3Agd2lsbCBvY2N1clxcbiAgICB2YXIgZnVuYyA9ICQuY2xlYW5EYXRhO1xcbiAgICAkLmNsZWFuRGF0YSA9IHVuZGVmaW5lZDtcXG4gICAga28uY2xlYW5Ob2RlKGVsZW1lbnQpO1xcbiAgICAkLmNsZWFuRGF0YSA9IGZ1bmM7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2tub2Nrb3V0LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy5hcmd1bWVudHMgPSBmdW5jdGlvbiAoYXJncykge1xcbiAgICB2YXIgYnlDb25zdHJ1Y3RvciA9IHt9O1xcbiAgICAkLmVhY2goYXJncywgZnVuY3Rpb24gKGluZGV4LCBhcmcpIHtcXG4gICAgICAgIGJ5Q29uc3RydWN0b3JbYXJnLmNvbnN0cnVjdG9yXSA9IGFyZztcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgICBieUNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gYnlDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvcik7XFxuICAgICAgICB9LFxcbiAgICAgICAgb2JqZWN0OiBieUNvbnN0cnVjdG9yW09iamVjdF0sXFxuICAgICAgICBzdHJpbmc6IGJ5Q29uc3RydWN0b3JbU3RyaW5nXSxcXG4gICAgICAgIGZ1bmM6IGJ5Q29uc3RydWN0b3JbRnVuY3Rpb25dLFxcbiAgICAgICAgYXJyYXk6IGJ5Q29uc3RydWN0b3JbQXJyYXldLFxcbiAgICAgICAgbnVtYmVyOiBieUNvbnN0cnVjdG9yW051bWJlcl1cXG4gICAgfTtcXG59O1xcblxcblQuVXRpbHMucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xcbiAgICB2YXIgaW5kZXggPSAkLmluQXJyYXkoaXRlbSwgYXJyYXkpO1xcbiAgICBpZiAoaW5kZXggPiAtMSlcXG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XFxufTtcXG5cXG5ULlV0aWxzLmluaGVyaXRPcHRpb25zID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspXFxuICAgICAgICB0b1tvcHRpb25zW2ldXSA9IGZyb21bb3B0aW9uc1tpXV07XFxuICAgIHJldHVybiB0bztcXG59O1xcblxcblQuVXRpbHMuY2xvbmVEYXRhID0gZnVuY3Rpb24gKGZyb20sIGV4Y2VwdCkge1xcbiAgICBpZiAoIWZyb20pIHJldHVybjtcXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmcm9tKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBmcm9tW3Byb3BlcnR5XTtcXG4gICAgICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxcbiAgICAgICAgICAgICghZXhjZXB0IHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJndW1lbnRzLCBwcm9wZXJ0eSkgPT09IC0xKSAmJlxcbiAgICAgICAgICAgICghdmFsdWUgfHwgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbiB8fCBrby5pc09ic2VydmFibGUodmFsdWUpKSkpXFxuXFxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5ULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzID0gZnVuY3Rpb24gKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpIHtcXG4gICAgdmFyIGRhdGEgPSBhbGxCaW5kaW5nc0FjY2Vzc29yKCk7XFxuICAgIGRhdGEudmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XFxuICAgIGlmICgha28uaXNPYnNlcnZhYmxlKGRhdGEudmFsdWUpICYmICQuaXNGdW5jdGlvbihkYXRhLnZhbHVlKSlcXG4gICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLnZhbHVlKCk7XFxuICAgIHJldHVybiBkYXRhO1xcbn07XFxuXFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9vYmplY3RzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHV0aWxzID0gVC5VdGlscztcXG5cXG4gICAgdXRpbHMuZ2V0UGFuZU9wdGlvbnMgPSBmdW5jdGlvbih2YWx1ZSwgb3RoZXJPcHRpb25zKSB7XFxuICAgICAgICB2YXIgb3B0aW9ucyA9IHZhbHVlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyB7IHBhdGg6IHZhbHVlIH0gOiB2YWx1ZTtcXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb3RoZXJPcHRpb25zLCBvcHRpb25zKTtcXG4gICAgfTtcXG5cXG4gICAgdXRpbHMuYmluZFBhbmUgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpIHtcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHV0aWxzLmNvbnRleHRGb3IoZWxlbWVudCkgfHwgVC5jb250ZXh0KCk7XFxuICAgICAgICB2YXIgcGFuZSA9IG5ldyBULlR5cGVzLlBhbmUoJC5leHRlbmQoeyBlbGVtZW50OiAkKGVsZW1lbnQpWzBdIH0sIHBhbmVPcHRpb25zKSk7XFxuICAgICAgICBub2RlLnNldFBhbmUocGFuZSk7XFxuXFxuICAgICAgICBjb250ZXh0LnJlbmRlck9wZXJhdGlvbi5hZGQocGFuZSk7XFxuXFxuICAgICAgICB2YXIgcGlwZWxpbmUgPSBuZXcgVC5UeXBlcy5QaXBlbGluZShULkV2ZW50cywgY29udGV4dCk7XFxuICAgICAgICBwaXBlbGluZS5leGVjdXRlKGNvbnRleHQub3B0aW9ucy5ldmVudHMsIHBhbmUpO1xcblxcbiAgICAgICAgcmV0dXJuIHBhbmU7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLmluc2VydFBhbmVBZnRlciA9IGZ1bmN0aW9uIChub2RlLCB0YXJnZXQsIHBhbmVPcHRpb25zLCBjb250ZXh0KSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoJzxkaXYvPicpLmluc2VydEFmdGVyKHRhcmdldCk7XFxuICAgICAgICByZXR1cm4gdXRpbHMuYmluZFBhbmUobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9wYW5lcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbigpIHtcXG4gICAgVC5QYXRoID0gUGF0aDtcXG5cXG4gICAgZnVuY3Rpb24gUGF0aChwYXRoKSB7XFxuICAgICAgICBwYXRoID0gcGF0aCA/IG5vcm1hbGlzZShwYXRoLnRvU3RyaW5nKCkpIDogJyc7XFxuICAgICAgICB2YXIgZmlsZW5hbWVJbmRleCA9IHBhdGgubGFzdEluZGV4T2YoXFxcIi9cXFwiKSArIDE7XFxuICAgICAgICB2YXIgZXh0ZW5zaW9uSW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFxcXCIuXFxcIik7XFxuXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHdpdGhvdXRGaWxlbmFtZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHBhdGguc3Vic3RyaW5nKDAsIGZpbGVuYW1lSW5kZXgpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgocGF0aC5zdWJzdHJpbmcoZmlsZW5hbWVJbmRleCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbkluZGV4ID09PSAtMSA/ICcnIDogcGF0aC5zdWJzdHJpbmcoZXh0ZW5zaW9uSW5kZXggKyAxKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHdpdGhvdXRFeHRlbnNpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChleHRlbnNpb25JbmRleCA9PT0gLTEgPyBwYXRoIDogcGF0aC5zdWJzdHJpbmcoMCwgZXh0ZW5zaW9uSW5kZXgpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvbWJpbmU6IGZ1bmN0aW9uIChhZGRpdGlvbmFsUGF0aCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aCgocGF0aCA/IHBhdGggKyAnLycgOiAnJykgKyBhZGRpdGlvbmFsUGF0aC50b1N0cmluZygpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fFxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5pbmRleE9mKCc6Ly8nKSA+IC0xO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgbWFrZUFic29sdXRlOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgoJy8nICsgcGF0aCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBtYWtlUmVsYXRpdmU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGFzTWFya3VwSWRlbnRpZmllcjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhvdXRFeHRlbnNpb24oKS50b1N0cmluZygpLnJlcGxhY2UoL1xcXFwvL2csICctJykucmVwbGFjZSgvXFxcXC4vZywgJycpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgc2V0RXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgodGhpcy53aXRob3V0RXh0ZW5zaW9uKCkgKyAnLicgKyBleHRlbnNpb24pO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpc2UoaW5wdXQpIHtcXG4gICAgICAgICAgICBpbnB1dCA9IHJlbW92ZURvdWJsZVNsYXNoZXMoaW5wdXQpO1xcbiAgICAgICAgICAgIGlucHV0ID0gcmVtb3ZlUGFyZW50UGF0aHMoaW5wdXQpO1xcbiAgICAgICAgICAgIGlucHV0ID0gcmVtb3ZlQ3VycmVudFBhdGhzKGlucHV0KTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiByZW1vdmVEb3VibGVTbGFzaGVzKGlucHV0KSB7XFxuICAgICAgICAgICAgdmFyIHByZWZpeEVuZCA9IGlucHV0LmluZGV4T2YoJzovLycpID4gLTEgPyBpbnB1dC5pbmRleE9mKCc6Ly8nKSArIDMgOiAwO1xcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4RW5kKTtcXG4gICAgICAgICAgICB2YXIgaW5wdXRQYXRoID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeEVuZCk7XFxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGlucHV0UGF0aC5yZXBsYWNlKC9cXFxcL3syLH0vZywgJy8nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBhcmVudFBhdGhzKGlucHV0KSB7XFxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL1teXFxcXC9cXFxcLl0rXFxcXC9cXFxcLlxcXFwuXFxcXC8vO1xcblxcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5tYXRjaChyZWdleCkpXFxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShyZWdleCwgJycpO1xcblxcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUN1cnJlbnRQYXRocyhpbnB1dCkge1xcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9cXFxcLlxcXFwvL2c7XFxuICAgICAgICAgICAgLy8gSWdub3JlIGxlYWRpbmcgcGFyZW50IHBhdGhzIC0gdGhlIHJlc3Qgd2lsbCBoYXZlIGJlZW4gc3RyaXBwZWRcXG4gICAgICAgICAgICAvLyBJIGNhbid0IGZpZ3VyZSBvdXQgYSByZWdleCB0aGF0IHdvbid0IHN0cmlwIHRoZSAuLyBvdXQgb2YgLi4vXFxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBpbnB1dC5sYXN0SW5kZXhPZignLi4vJyk7XFxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gLTEgPyAwIDogc3RhcnRJbmRleCArIDM7XFxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZygwLCBzdGFydEluZGV4KSArIGlucHV0LnN1YnN0cmluZyhzdGFydEluZGV4KS5yZXBsYWNlKHJlZ2V4LCAnJyk7XFxuICAgICAgICB9XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL1BhdGguanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICAvLyBUaGlzIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBtb2R1bGVzIGZyb20gdGhlIFlVSSBMaWJyYXJ5IC0gXFxuICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9hcGkvZmlsZXMvcXVlcnlzdHJpbmdfanNfcXVlcnlzdHJpbmctcGFyc2UuanMuaHRtbFxcbiAgICAvLyBFaXRoZXIgaXQgc2hvdWxkIGJlIHJld3JpdHRlbiBvciBhdHRyaWJ1dGlvbiBhbmQgbGljZW5zaW5nIGJlIGF2YWlsYWJsZSBoZXJlIGFuZCBvbiB0aGUgd2Vic2l0ZSBsaWtlIGluIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xcblxcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nID0gVC5VdGlscy5RdWVyeXN0cmluZyB8fCB7fTtcXG5cXG4gICAgVC5VdGlscy5RdWVyeXN0cmluZy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHNlcGVyYXRvciwgZXFTeW1ib2wpIHtcXG4gICAgICAgIHN0cmlwTGVhZEluKCk7XFxuICAgICAgICBcXG4gICAgICAgIHJldHVybiBULlV0aWxzLnJlZHVjZShcXG4gICAgICAgICAgICBULlV0aWxzLm1hcChcXG4gICAgICAgICAgICAgICAgc291cmNlLnNwbGl0KHNlcGVyYXRvciB8fCBcXFwiJlxcXCIpLFxcbiAgICAgICAgICAgICAgICBwaWVjZVBhcnNlcihlcVN5bWJvbCB8fCBcXFwiPVxcXCIpXFxuICAgICAgICAgICAgKSxcXG4gICAgICAgICAgICB7fSxcXG4gICAgICAgICAgICBtZXJnZVBhcmFtc1xcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIHN0cmlwTGVhZEluKCkge1xcbiAgICAgICAgICAgIGlmKHNvdXJjZS5sZW5ndGggPiAwICYmIHNvdXJjZS5jaGFyQXQoMCkgPT09ICc/JylcXG4gICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygxKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHMpIHtcXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocy5yZXBsYWNlKC9cXFxcKy9nLCAnICcpKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcGllY2VQYXJzZXIoZXEpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZVBpZWNlKGtleSwgdmFsKSB7XFxuXFxuICAgICAgICAgICAgdmFyIHNsaWNlZCwgbnVtVmFsLCBoZWFkLCB0YWlsLCByZXQ7XFxuXFxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgLy8ga2V5PXZhbCwgY2FsbGVkIGZyb20gdGhlIG1hcC9yZWR1Y2VcXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnNwbGl0KGVxKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGllY2UoXFxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZShrZXkuc2hpZnQoKSksXFxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZShrZXkuam9pbihlcSkpLFxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKTtcXG4gICAgICAgICAgICBpZiAodmFsLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJyk7XFxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbnVtZXJhbHMgdG8gbnVtYmVyc1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIG51bVZhbCA9ICt2YWw7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudW1WYWwudG9TdHJpbmcoMTApKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVtVmFsO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHNsaWNlZCA9IC8oLiopXFxcXFsoW15cXFxcXV0qKVxcXFxdJC8uZXhlYyhrZXkpO1xcbiAgICAgICAgICAgIGlmICghc2xpY2VkKSB7XFxuICAgICAgICAgICAgICAgIHJldCA9IHt9O1xcbiAgICAgICAgICAgICAgICBpZiAoa2V5KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSB2YWw7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIFtcXFwiZm9vW11bYmFyXVtdW2Jhel1cXFwiLCBcXFwiZm9vW11bYmFyXVtdXFxcIiwgXFxcImJhelxcXCJdXFxuICAgICAgICAgICAgdGFpbCA9IHNsaWNlZFsyXTtcXG4gICAgICAgICAgICBoZWFkID0gc2xpY2VkWzFdO1xcblxcbiAgICAgICAgICAgIC8vIGFycmF5OiBrZXlbXT12YWxcXG4gICAgICAgICAgICBpZiAoIXRhaWwpXFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBpZWNlKGhlYWQsIFt2YWxdLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAvLyBvYmplY3Q6IGtleVtzdWJrZXldPXZhbFxcbiAgICAgICAgICAgIHJldCA9IHt9O1xcbiAgICAgICAgICAgIHJldFt0YWlsXSA9IHZhbDtcXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VQaWVjZShoZWFkLCByZXQsIHRydWUpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvLyB0aGUgcmVkdWNlciBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIHF1ZXJ5IHBpZWNlIHRvZ2V0aGVyIGludG8gb25lIHNldCBvZiBwYXJhbXNcXG4gICAgZnVuY3Rpb24gbWVyZ2VQYXJhbXMocGFyYW1zLCBhZGRpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIChcXG4gICAgICAgICAgICAvLyBpZiBpdCdzIHVuY29udGVzdGVkLCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBhZGRpdGlvbi5cXG4gICAgICAgICAgICAoIXBhcmFtcykgPyBhZGRpdGlvblxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiBjb25jYXQgaXQuXFxuICAgICAgICAgICAgOiAoJC5pc0FycmF5KHBhcmFtcykpID8gcGFyYW1zLmNvbmNhdChhZGRpdGlvbilcXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGFuIGFycmF5LCBhbmQgZWl0aGVyIGFyZSBub3Qgb2JqZWN0cywgYXJyYXlpZnkgaXQuXFxuICAgICAgICAgICAgOiAoISQuaXNQbGFpbk9iamVjdChwYXJhbXMpIHx8ICEkLmlzUGxhaW5PYmplY3QoYWRkaXRpb24pKSA/IFtwYXJhbXNdLmNvbmNhdChhZGRpdGlvbilcXG4gICAgICAgICAgICAvLyBlbHNlIG1lcmdlIHRoZW0gYXMgb2JqZWN0cywgd2hpY2ggaXMgYSBsaXR0bGUgbW9yZSBjb21wbGV4XFxuICAgICAgICAgICAgOiBtZXJnZU9iamVjdHMocGFyYW1zLCBhZGRpdGlvbilcXG4gICAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgLy8gTWVyZ2UgdHdvICpvYmplY3RzKiB0b2dldGhlci4gSWYgdGhpcyBpcyBjYWxsZWQsIHdlJ3ZlIGFscmVhZHkgcnVsZWRcXG4gICAgLy8gb3V0IHRoZSBzaW1wbGUgY2FzZXMsIGFuZCBuZWVkIHRvIGRvIHRoZSBmb3ItaW4gYnVzaW5lc3MuXFxuICAgIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhwYXJhbXMsIGFkZGl0aW9uKSB7XFxuICAgICAgICBmb3IgKHZhciBpIGluIGFkZGl0aW9uKVxcbiAgICAgICAgICAgIGlmIChpICYmIGFkZGl0aW9uLmhhc093blByb3BlcnR5KGkpKVxcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBtZXJnZVBhcmFtcyhwYXJhbXNbaV0sIGFkZGl0aW9uW2ldKTtcXG5cXG4gICAgICAgIHJldHVybiBwYXJhbXM7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvcXVlcnlzdHJpbmcucGFyc2UuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICAvLyBUaGlzIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBtb2R1bGVzIGZyb20gdGhlIFlVSSBMaWJyYXJ5IC0gXFxuICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9hcGkvZmlsZXMvcXVlcnlzdHJpbmdfanNfcXVlcnlzdHJpbmctc3RyaW5naWZ5LmpzLmh0bWxcXG4gICAgLy8gRWl0aGVyIGl0IHNob3VsZCBiZSByZXdyaXR0ZW4gb3IgYXR0cmlidXRpb24gYW5kIGxpY2Vuc2luZyBiZSBhdmFpbGFibGUgaGVyZSBhbmQgb24gdGhlIHdlYnNpdGUgbGlrZSBpbiBodHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cXG5cXG4gICAgVC5VdGlscy5RdWVyeXN0cmluZyA9IFQuVXRpbHMuUXVlcnlzdHJpbmcgfHwge307XFxuXFxuICAgIHZhciBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XFxuXFxuICAgIFQuVXRpbHMuUXVlcnlzdHJpbmcuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShzb3VyY2UsIG9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoc291cmNlLCBvcHRpb25zLCBuYW1lLCBzdGFjaykge1xcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgICAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcbiAgICAgICAgdmFyIGJlZ2luLCBlbmQsIGksIGwsIG4sIHM7XFxuICAgICAgICB2YXIgc2VwID0gb3B0aW9ucy5zZXBlcmF0b3IgfHwgXFxcIiZcXFwiO1xcbiAgICAgICAgdmFyIGVxID0gb3B0aW9ucy5lcVN5bWJvbCB8fCBcXFwiPVxcXCI7XFxuICAgICAgICB2YXIgYXJyYXlLZXkgPSBvcHRpb25zLmFycmF5S2V5ICE9PSBmYWxzZTtcXG5cXG4gICAgICAgIGlmIChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgc291cmNlLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICByZXR1cm4gbmFtZSA/IGVzY2FwZShuYW1lKSArIGVxIDogJyc7XFxuXFxuICAgICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yID09PSBCb29sZWFuIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzb3VyY2UpID09PSAnW29iamVjdCBCb29sZWFuXScpXFxuICAgICAgICAgICAgc291cmNlID0gK3NvdXJjZTtcXG5cXG4gICAgICAgIGlmICghaXNOYU4oc291cmNlKSB8fCBzb3VyY2UuY29uc3RydWN0b3IgPT09IFN0cmluZylcXG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlKG5hbWUpICsgZXEgKyBlc2NhcGUoc291cmNlKTtcXG5cXG4gICAgICAgIGlmICgkLmlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgICAgICAgIHMgPSBbXTtcXG4gICAgICAgICAgICBuYW1lID0gYXJyYXlLZXkgPyBuYW1lICsgJ1tdJyA6IG5hbWU7XFxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcy5wdXNoKHN0cmluZ2lmeShzb3VyY2VbaV0sIG9wdGlvbnMsIG5hbWUsIHN0YWNrKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBzLmpvaW4oc2VwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgLy8gbm93IHdlIGtub3cgaXQncyBhbiBvYmplY3QuXFxuICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljYWwgcmVmZXJlbmNlcyBpbiBuZXN0ZWQgb2JqZWN0c1xcbiAgICAgICAgZm9yIChpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXFxuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSBzb3VyY2UpXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVC5VdGlscy5RdWVyeXN0cmluZy5zdHJpbmdpZnk6IGN5Y2xpY2FsIHJlZmVyZW5jZVxcXCIpO1xcblxcbiAgICAgICAgc3RhY2sucHVzaChzb3VyY2UpO1xcbiAgICAgICAgcyA9IFtdO1xcbiAgICAgICAgYmVnaW4gPSBuYW1lID8gbmFtZSArICdbJyA6ICcnO1xcbiAgICAgICAgZW5kID0gbmFtZSA/ICddJyA6ICcnO1xcbiAgICAgICAgZm9yIChpIGluIHNvdXJjZSkge1xcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgbiA9IGJlZ2luICsgaSArIGVuZDtcXG4gICAgICAgICAgICAgICAgcy5wdXNoKHN0cmluZ2lmeShzb3VyY2VbaV0sIG9wdGlvbnMsIG4sIHN0YWNrKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhY2sucG9wKCk7XFxuICAgICAgICBzID0gcy5qb2luKHNlcCk7XFxuICAgICAgICBpZiAoIXMgJiYgbmFtZSlcXG4gICAgICAgICAgICByZXR1cm4gbmFtZSArIFxcXCI9XFxcIjtcXG5cXG4gICAgICAgIHJldHVybiBzO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9xdWVyeXN0cmluZy5zdHJpbmdpZnkuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBULlR5cGVzLkZsb3cgPSBmdW5jdGlvbiAobmF2aWdhdGlvblNvdXJjZSwgZGVmaW5pdGlvbikge1xcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgICAgdGhpcy5ub2RlID0gbmF2aWdhdGlvbk5vZGUoKTtcXG4gICAgICAgIHRoaXMucHVic3ViID0gdGhpcy5ub2RlLnBhbmUucHVic3ViLm93bmVyO1xcbiAgICAgICAgdGhpcy5zYWdhcyA9IFtdO1xcblxcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24oc2VsZiwgZGVmaW5pdGlvbik7XFxuICAgICAgICB0aGlzLnNhZ2EgPSBuZXcgVHJpYmUuUHViU3ViLlNhZ2EodGhpcy5wdWJzdWIsIGRlZmluaXRpb24pO1xcblxcbiAgICAgICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgICAgICBzZWxmLnNhZ2Euc3RhcnQoZGF0YSk7XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgdGhpcy5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgc2VsZi5zYWdhLmVuZChkYXRhKTtcXG4gICAgICAgICAgICBULlV0aWxzLmVhY2goc2VsZi5zYWdhcywgZnVuY3Rpb24oc2FnYSkge1xcbiAgICAgICAgICAgICAgICBzYWdhLmVuZChkYXRhKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBuYXZpZ2F0aW9uTm9kZSgpIHtcXG4gICAgICAgICAgICBpZiAobmF2aWdhdGlvblNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5Ob2RlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvblNvdXJjZS5maW5kTmF2aWdhdGlvbigpLm5vZGU7XFxuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25Tb3VyY2UuY29uc3RydWN0b3IgPT09IFQuVHlwZXMuUGFuZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRpb25Tb3VyY2Uubm9kZS5maW5kTmF2aWdhdGlvbigpLm5vZGU7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJuYXZpZ2F0aW9uU291cmNlIG11c3QgYmUgZWl0aGVyIFQuVHlwZXMuUGFuZSBvciBULlR5cGVzLk5vZGVcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydENoaWxkID0gZnVuY3Rpb24oZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24odGhpcywgZGVmaW5pdGlvbik7XFxuICAgICAgICB0aGlzLnNhZ2Euc3RhcnRDaGlsZChkZWZpbml0aW9uLCBkYXRhKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPck9wdGlvbnMsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMubm9kZS5uYXZpZ2F0ZShwYXRoT3JPcHRpb25zLCBkYXRhKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIC8vIFRoaXMga2VlcHMgYSBzZXBhcmF0ZSBjb2xsZWN0aW9uIG9mIHNhZ2FzIGJvdW5kIHRvIHRoaXMgZmxvdydzIGxpZmV0aW1lXFxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgdG8gbWFrZSB0aGVtIGNoaWxkcmVuIG9mIHRoZSB1bmRlcmx5aW5nIHNhZ2EsIGJ1dFxcbiAgICAvLyB0aGVuIHRoZXkgd291bGQgZW5kIGFueSB0aW1lIGEgbWVzc2FnZSB3YXMgZXhlY3V0ZWQuXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUuc3RhcnRTYWdhID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGRhdGEpIHtcXG4gICAgICAgIHZhciBzYWdhID0gdGhpcy5wdWJzdWIuc3RhcnRTYWdhKGRlZmluaXRpb24sIGRhdGEpO1xcbiAgICAgICAgdGhpcy5zYWdhcy5wdXNoKHNhZ2EpO1xcbiAgICAgICAgcmV0dXJuIHNhZ2E7XFxuICAgIH07XFxuXFxuICAgIC8vIGZsb3cgaGVscGVyc1xcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBhdGhPck9wdGlvbnMsIGRhdGEpIHtcXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBub2RlLm5hdmlnYXRlKHBhdGhPck9wdGlvbnMsIGRhdGEpO1xcbiAgICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5lbmRzQXQgPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xcbiAgICAgICAgdmFyIGZsb3cgPSB0aGlzO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBmbG93Lm5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XFxuICAgICAgICAgICAgZmxvdy5lbmQoKTtcXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbG93LCBkYXRhKSB7XFxuICAgICAgICB2YXIgdGhpc0Zsb3cgPSB0aGlzO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHRoaXNGbG93LnN0YXJ0Q2hpbGQoZmxvdywgZGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcblxcbiAgICAvLyBUaGlzIGlzIHJldXNlZCBieSBOb2RlIGFuZCBQYW5lXFxuICAgIFQuVHlwZXMuRmxvdy5zdGFydEZsb3cgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBULlR5cGVzLkZsb3codGhpcywgZGVmaW5pdGlvbikuc3RhcnQoZGF0YSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKGZsb3csIGRlZmluaXRpb24pIHtcXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICBkZWZpbml0aW9uID0gbmV3IGRlZmluaXRpb24oZmxvdyk7XFxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcXG4gICAgfVxcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL0Zsb3cuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLkhpc3RvcnkgPSBmdW5jdGlvbiAoaGlzdG9yeSkge1xcbiAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCB3aW5kb3cudGl0bGUpO1xcblxcbiAgICB2YXIgcG9wQWN0aW9ucyA9IHtcXG4gICAgICAgIHJhaXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgVC5VdGlscy5yYWlzZURvY3VtZW50RXZlbnQoJ2Jyb3dzZXIuZ28nLCB7IGNvdW50OiAoZS5zdGF0ZSAtIGN1cnJlbnRTdGF0ZSkgfSk7XFxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZS5zdGF0ZTtcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGVTdGFjazogZnVuY3Rpb24oZSkge1xcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGUuc3RhdGU7XFxuICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHBvcEFjdGlvbnMucmFpc2VFdmVudDtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdmFyIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnJhaXNlRXZlbnQ7XFxuXFxuICAgIC8vIHRoaXMgbGVhdmVzIElFNyAmIDggaGlnaCBhbmQgZHJ5LiBXZSdsbCBwcm9iYWJseSByZXF1aXJlIGEgcG9seWZpbGwgYW5kIGNyZWF0ZSBhIGdlbmVyaWMgZXZlbnQgc3Vic2NyaXB0aW9uIG1ldGhvZFxcbiAgICBpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcilcXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGV4ZWN1dGVDdXJyZW50QWN0aW9uKTtcXG5cXG4gICAgZnVuY3Rpb24gZXhlY3V0ZUN1cnJlbnRBY3Rpb24oZSkge1xcbiAgICAgICAgaWYgKGUuc3RhdGUgIT09IG51bGwpIGN1cnJlbnRBY3Rpb24oZSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICh1cmxPcHRpb25zKSB7XFxuICAgICAgICB1cmxPcHRpb25zID0gdXJsT3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKCsrY3VycmVudFN0YXRlLCB1cmxPcHRpb25zLnRpdGxlLCB1cmxPcHRpb25zLnVybCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbihmcmFtZUNvdW50KSB7XFxuICAgICAgICBoaXN0b3J5LmdvKGZyYW1lQ291bnQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGZyYW1lQ291bnQpIHtcXG4gICAgICAgIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnVwZGF0ZVN0YWNrO1xcbiAgICAgICAgaGlzdG9yeS5nbyhmcmFtZUNvdW50KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZXhlY3V0ZUN1cnJlbnRBY3Rpb24pO1xcbiAgICB9O1xcbn07XFxuXFxuaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSlcXG4gICAgVC5oaXN0b3J5ID0gbmV3IFQuVHlwZXMuSGlzdG9yeSh3aW5kb3cuaGlzdG9yeSk7XFxuZWxzZVxcbiAgICBULmhpc3RvcnkgPSBuZXcgVC5UeXBlcy5IaXN0b3J5KHtcXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgICAgICBnbzogZnVuY3Rpb24gKCkgeyB9XFxuICAgIH0pO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9IaXN0b3J5LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5Mb2FkZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHJlc291cmNlcyA9IHt9O1xcblxcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgICAgICBpZiAocmVzb3VyY2VzW3VybF0gIT09IHVuZGVmaW5lZClcXG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzW3VybF07XFxuXFxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gVC5QYXRoKHVybCkuZXh0ZW5zaW9uKCkudG9TdHJpbmcoKTtcXG4gICAgICAgIHZhciBoYW5kbGVyID0gVC5Mb2FkSGFuZGxlcnNbZXh0ZW5zaW9uXTtcXG5cXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpO1xcbiAgICAgICAgICAgIHJlc291cmNlc1t1cmxdID0gcmVzdWx0O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICQud2hlbihyZXN1bHQpLmFsd2F5cyhmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzW3VybF0gPSBudWxsO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBULmxvZ2dlci53YXJuKFxcXCJSZXNvdXJjZSBvZiB0eXBlIFxcXCIgKyBleHRlbnNpb24gKyBcXFwiIGJ1dCBubyBoYW5kbGVyIHJlZ2lzdGVyZWQuXFxcIik7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfTtcXG59O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9Mb2FkZXIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLk5hdmlnYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xcbiAgICBub3JtYWxpc2VPcHRpb25zKCk7XFxuICAgIHNldEluaXRpYWxQYW5lU3RhdGUoKTtcXG5cXG4gICAgdmFyIHN0YWNrID0gW2luaXRpYWxTdGFja0l0ZW0oKV07XFxuICAgIHZhciBjdXJyZW50RnJhbWUgPSAwO1xcblxcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XFxuXFxuICAgIHRoaXMubmF2aWdhdGUgPSBmdW5jdGlvbiAocGFuZU9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChvcHRpb25zLmJyb3dzZXIpXFxuICAgICAgICAgICAgVC5oaXN0b3J5Lm5hdmlnYXRlKG9wdGlvbnMuYnJvd3NlciAmJiBvcHRpb25zLmJyb3dzZXIudXJsRGF0YUZyb20ocGFuZU9wdGlvbnMpKTtcXG5cXG4gICAgICAgIHRyaW1TdGFjaygpO1xcbiAgICAgICAgc3RhY2sucHVzaChwYW5lT3B0aW9ucyk7XFxuICAgICAgICBjdXJyZW50RnJhbWUrKztcXG5cXG4gICAgICAgIG5hdmlnYXRlVG8ocGFuZU9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmlzQXRTdGFydCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGcmFtZSA9PT0gMDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5nbyA9IGZ1bmN0aW9uKGZyYW1lQ291bnQpIHtcXG4gICAgICAgIGdvKGZyYW1lQ291bnQpO1xcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvd3NlcikgVC5oaXN0b3J5LnVwZGF0ZShmcmFtZUNvdW50KTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGlmKG9wdGlvbnMuYnJvd3NlcikgVC5VdGlscy5oYW5kbGVEb2N1bWVudEV2ZW50KCdicm93c2VyLmdvJywgb25Ccm93c2VyR28pO1xcbiAgICBmdW5jdGlvbiBvbkJyb3dzZXJHbyhlKSB7XFxuICAgICAgICBnbyhlLmV2ZW50RGF0YS5jb3VudCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ28oZnJhbWVDb3VudCkge1xcbiAgICAgICAgdmFyIG5ld0ZyYW1lID0gY3VycmVudEZyYW1lICsgZnJhbWVDb3VudDtcXG4gICAgICAgIGlmIChuZXdGcmFtZSA8IDApIG5ld0ZyYW1lID0gMDtcXG4gICAgICAgIGlmIChuZXdGcmFtZSA+PSBzdGFjay5sZW5ndGgpIG5ld0ZyYW1lID0gc3RhY2subGVuZ3RoIC0gMTtcXG5cXG4gICAgICAgIGlmIChuZXdGcmFtZSAhPSBjdXJyZW50RnJhbWUpXFxuICAgICAgICAgICAgbmF2aWdhdGVUbyhzdGFja1tuZXdGcmFtZV0sIGZyYW1lQ291bnQgPCAwKTtcXG5cXG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IG5ld0ZyYW1lO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlVG8ocGFuZU9wdGlvbnMsIHJldmVyc2UpIHtcXG4gICAgICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50KCduYXZpZ2F0aW5nJywgeyBub2RlOiBub2RlLCBvcHRpb25zOiBwYW5lT3B0aW9ucywgYnJvd3NlckRhdGE6IG9wdGlvbnMuYnJvd3NlckRhdGEgfSk7XFxuICAgICAgICBub2RlLnRyYW5zaXRpb25UbyhwYW5lT3B0aW9ucywgb3B0aW9ucy50cmFuc2l0aW9uLCByZXZlcnNlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB0cmltU3RhY2soKSB7XFxuICAgICAgICBzdGFjay5zcGxpY2UoY3VycmVudEZyYW1lICsgMSwgc3RhY2subGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIFQuVXRpbHMuZGV0YWNoRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIG9uQnJvd3NlckdvKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMoKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXFxuICAgICAgICAgICAgb3B0aW9ucyA9IHsgdHJhbnNpdGlvbjogb3B0aW9ucyB9O1xcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvd3NlciA9PT0gdHJ1ZSlcXG4gICAgICAgICAgICBvcHRpb25zLmJyb3dzZXIgPSBULm9wdGlvbnMuZGVmYXVsdFVybFByb3ZpZGVyO1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzZXRJbml0aWFsUGFuZVN0YXRlKCkge1xcbiAgICAgICAgdmFyIHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goL1xcXFwjLiovKTtcXG4gICAgICAgIGlmIChxdWVyeSkgcXVlcnkgPSBxdWVyeVswXS5zdWJzdHJpbmcoMSk7XFxuICAgICAgICB2YXIgdXJsU3RhdGUgPSBvcHRpb25zLmJyb3dzZXIgJiYgb3B0aW9ucy5icm93c2VyLnBhbmVPcHRpb25zRnJvbShxdWVyeSk7XFxuICAgICAgICBpZiAodXJsU3RhdGUpIHtcXG4gICAgICAgICAgICBub2RlLnBhbmUucGF0aCA9IHVybFN0YXRlLnBhdGg7XFxuICAgICAgICAgICAgbm9kZS5wYW5lLmRhdGEgPSB1cmxTdGF0ZS5kYXRhO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBpbml0aWFsU3RhY2tJdGVtKCkge1xcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogbm9kZS5wYW5lLnBhdGgsIGRhdGE6IG5vZGUucGFuZS5kYXRhIH07XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9OYXZpZ2F0aW9uLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5Ob2RlID0gZnVuY3Rpb24gKHBhcmVudCwgcGFuZSkge1xcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IHRoaXM7XFxuICAgIHRoaXMuaWQgPSBULlV0aWxzLmdldFVuaXF1ZUlkKCk7XFxuXFxuICAgIGlmIChwYXJlbnQpIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xcbiAgICBpZiAocGFuZSkgdGhpcy5zZXRQYW5lKHBhbmUpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYXRoT3JQYW5lLCBkYXRhKSB7XFxuICAgIHZhciBwYW5lT3B0aW9ucyA9IFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGF0aE9yUGFuZSwgeyBkYXRhOiBkYXRhIH0pO1xcbiAgICBpZiAoIVQuUGF0aChwYW5lT3B0aW9ucy5wYXRoKS5pc0Fic29sdXRlKCkpXFxuICAgICAgICAvLyB0aGlzIGlzIGR1cGxpY2F0ZWQgaW4gUGFuZS5pbmhlcml0UGF0aEZyb20gLSB0aGUgY29uY2VwdCAocmVsYXRpdmUgcGF0aHMgaW5oZXJpdCBleGlzdGluZyBwYXRocykgbmVlZHMgdG8gYmUgY2xlYXJlclxcbiAgICAgICAgcGFuZU9wdGlvbnMucGF0aCA9IFQuUGF0aCh0aGlzLm5vZGVGb3JQYXRoKCkucGFuZS5wYXRoKS53aXRob3V0RmlsZW5hbWUoKS5jb21iaW5lKHBhbmVPcHRpb25zLnBhdGgpLnRvU3RyaW5nKCk7XFxuICAgIFxcbiAgICB0aGlzLmZpbmROYXZpZ2F0aW9uKCkubmF2aWdhdGUocGFuZU9wdGlvbnMpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5uYXZpZ2F0ZUJhY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZmluZE5hdmlnYXRpb24oKS5nbygtMSk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLmZpbmROYXZpZ2F0aW9uID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmRlZmF1bHROYXZpZ2F0aW9uKVxcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdE5hdmlnYXRpb247XFxuXFxuICAgIGVsc2UgaWYgKHRoaXMubmF2aWdhdGlvbilcXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb247XFxuICAgICAgICBcXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmV3IFQuVHlwZXMuTmF2aWdhdGlvbih0aGlzKTtcXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb247XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROYXZpZ2F0aW9uKCk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uKHBhbmVPcHRpb25zLCB0cmFuc2l0aW9uLCByZXZlcnNlKSB7XFxuICAgIFQudHJhbnNpdGlvbih0aGlzLCB0cmFuc2l0aW9uLCByZXZlcnNlKS50byhwYW5lT3B0aW9ucyk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLnNldFBhbmUgPSBmdW5jdGlvbiAocGFuZSkge1xcbiAgICBpZiAodGhpcy5wYW5lKVxcbiAgICAgICAgdGhpcy5wYW5lLm5vZGUgPSBudWxsO1xcblxcbiAgICBwYW5lLm5vZGUgPSB0aGlzO1xcbiAgICB0aGlzLnBhbmUgPSBwYW5lO1xcbiAgICB0aGlzLnNraXBQYXRoID0gcGFuZS5za2lwUGF0aDtcXG5cXG4gICAgaWYgKHBhbmUuaGFuZGxlc05hdmlnYXRpb24pIHtcXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBULlR5cGVzLk5hdmlnYXRpb24odGhpcywgcGFuZS5oYW5kbGVzTmF2aWdhdGlvbik7XFxuICAgICAgICBcXG4gICAgICAgIC8vIHRoaXMgc2V0cyB0aGlzIHBhbmUgYXMgdGhlIFxcXCJkZWZhdWx0XFxcIiwgYWNjZXNzaWJsZSBmcm9tIHBhbmVzIG91dHNpZGUgdGhlIHRyZWUuIEZpcnN0IGluIGJlc3QgZHJlc3NlZC5cXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiB8fCB0aGlzLm5hdmlnYXRpb247XFxuICAgIH1cXG5cXG4gICAgcGFuZS5pbmhlcml0UGF0aEZyb20odGhpcy5wYXJlbnQpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5ub2RlRm9yUGF0aCA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5za2lwUGF0aCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Lm5vZGVGb3JQYXRoKCkgOiB0aGlzO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLnJvb3QuZGVmYXVsdE5hdmlnYXRpb24gPT09IHRoaXMubmF2aWdhdGlvbilcXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IG51bGw7XFxuXFxuICAgIGlmICh0aGlzLnBhcmVudClcXG4gICAgICAgIFQuVXRpbHMucmVtb3ZlSXRlbSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcyk7XFxuXFxuICAgIGlmICh0aGlzLnBhbmUgJiYgdGhpcy5wYW5lLmRpc3Bvc2UpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhbmUubm9kZTtcXG4gICAgICAgIHRoaXMucGFuZS5kaXNwb3NlKCk7XFxuICAgIH1cXG59O1xcblxcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUuc3RhcnRGbG93ID0gVC5UeXBlcy5GbG93LnN0YXJ0RmxvdztcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvTm9kZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuT3BlcmF0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciBpbmNvbXBsZXRlID0gW107XFxuXFxuICAgIHRoaXMucHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG5cXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgICAgaW5jb21wbGV0ZS5wdXNoKGlkKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgICAgVC5VdGlscy5yZW1vdmVJdGVtKGluY29tcGxldGUsIGlkKTtcXG4gICAgICAgIGlmIChpbmNvbXBsZXRlLmxlbmd0aCA9PT0gMClcXG4gICAgICAgICAgICBzZWxmLnByb21pc2UucmVzb2x2ZSgpO1xcbiAgICB9O1xcbiAgICBcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9PcGVyYXRpb24uanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLlBhbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICBULlV0aWxzLmluaGVyaXRPcHRpb25zKG9wdGlvbnMsIHRoaXMsIFsncGF0aCcsICdkYXRhJywgJ2VsZW1lbnQnLCAndHJhbnNpdGlvbicsICdyZXZlcnNlVHJhbnNpdGlvbkluJywgJ2hhbmRsZXNOYXZpZ2F0aW9uJywgJ3B1YnN1YicsICdpZCcsICdza2lwUGF0aCddKTtcXG5cXG4gICAgLy8gZXZlbnRzIHdlIGFyZSBpbnRlcmVzdGVkIGluIGhvb2tpbmcgaW4gdG8gLSB0aGlzIGNvdWxkIGJlIGRvbmUgY29tcGxldGVseSBnZW5lcmljYWxseSBieSB0aGUgcGlwZWxpbmVcXG4gICAgdGhpcy5pcyA9IHtcXG4gICAgICAgIHJlbmRlcmVkOiAkLkRlZmVycmVkKCksXFxuICAgICAgICBkaXNwb3NlZDogJC5EZWZlcnJlZCgpXFxuICAgIH07ICAgIFxcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYXRoT3JQYW5lLCBkYXRhKSB7XFxuICAgIHRoaXMubm9kZSAmJiB0aGlzLm5vZGUubmF2aWdhdGUocGF0aE9yUGFuZSwgZGF0YSk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5ub2RlICYmIHRoaXMubm9kZS5uYXZpZ2F0ZUJhY2soKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKHRoaXMuZWxlbWVudCkucmVtb3ZlKCk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuZGlzcG9zZSlcXG4gICAgICAgIHRoaXMubW9kZWwuZGlzcG9zZSgpO1xcblxcbiAgICBpZiAodGhpcy5ub2RlKSB7XFxuICAgICAgICBkZWxldGUgdGhpcy5ub2RlLnBhbmU7XFxuICAgICAgICB0aGlzLm5vZGUuZGlzcG9zZSgpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmVsZW1lbnQpXFxuICAgICAgICBULlV0aWxzLmNsZWFuRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5pbmhlcml0UGF0aEZyb20gPSBmdW5jdGlvbiAobm9kZSkge1xcbiAgICBub2RlID0gbm9kZSAmJiBub2RlLm5vZGVGb3JQYXRoKCk7XFxuICAgIHZhciBwYW5lID0gbm9kZSAmJiBub2RlLnBhbmU7ICAgIFxcbiAgICB2YXIgcGF0aCA9IFQuUGF0aCh0aGlzLnBhdGgpO1xcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKCkgfHwgIXBhbmUpXFxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoLm1ha2VBYnNvbHV0ZSgpLnRvU3RyaW5nKCk7XFxuICAgIGVsc2VcXG4gICAgICAgIHRoaXMucGF0aCA9IFQuUGF0aChwYW5lLnBhdGgpLndpdGhvdXRGaWxlbmFtZSgpLmNvbWJpbmUocGF0aCkudG9TdHJpbmcoKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XFxuICAgIHJldHVybiAkKHRoaXMuZWxlbWVudCkuZmluZChzZWxlY3Rvcik7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnN0YXJ0UmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKHRoaXMuZWxlbWVudCkuYWRkQ2xhc3MoJ19fcmVuZGVyaW5nJyk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmVuZFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgJCh0aGlzLmVsZW1lbnQpLnJlbW92ZUNsYXNzKCdfX3JlbmRlcmluZycpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIFxcXCJ7IHBhdGg6ICdcXFwiICsgdGhpcy5wYXRoICsgXFxcIicgfVxcXCI7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnN0YXJ0U2FnYSA9IGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcXG4gICAgdmFyIHNhZ2EgPSBULmNvbnRleHQoKS5zYWdhc1twYXRoXTtcXG4gICAgdGhpcy5wdWJzdWIuc3RhcnRTYWdhLmFwcGx5KHRoaXMucHVic3ViLCBbc2FnYS5jb25zdHJ1Y3Rvcl0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuc3RhcnRGbG93ID0gVC5UeXBlcy5GbG93LnN0YXJ0RmxvdztcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvUGFuZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuUGlwZWxpbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBjb250ZXh0KSB7XFxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uIChldmVudHNUb0V4ZWN1dGUsIHRhcmdldCkge1xcbiAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IC0xO1xcbiAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuICAgICAgICBleGVjdXRlTmV4dEV2ZW50KCk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlTmV4dEV2ZW50KCkge1xcbiAgICAgICAgICAgIGN1cnJlbnRFdmVudCsrO1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50RXZlbnQgPj0gZXZlbnRzVG9FeGVjdXRlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRzVG9FeGVjdXRlW2N1cnJlbnRFdmVudF07XFxuICAgICAgICAgICAgdmFyIHRoaXNFdmVudCA9IGV2ZW50c1tldmVudE5hbWVdO1xcblxcbiAgICAgICAgICAgIGlmICghdGhpc0V2ZW50KSB7XFxuICAgICAgICAgICAgICAgIFQubG9nZ2VyLndhcm4oXFxcIk5vIGV2ZW50IGRlZmluZWQgZm9yIFxcXCIgKyBldmVudE5hbWUpO1xcbiAgICAgICAgICAgICAgICBleGVjdXRlTmV4dEV2ZW50KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJC53aGVuKHRoaXNFdmVudCh0YXJnZXQsIGNvbnRleHQpKVxcbiAgICAgICAgICAgICAgICAuZG9uZShleGVjdXRlTmV4dEV2ZW50KVxcbiAgICAgICAgICAgICAgICAuZmFpbChoYW5kbGVGYWlsdXJlKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVGYWlsdXJlKCkge1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RGVzY3JpcHRpb24gPSB0YXJnZXQgPyB0YXJnZXQudG9TdHJpbmcoKSA6IFxcXCJlbXB0eSB0YXJnZXRcXFwiO1xcbiAgICAgICAgICAgICAgICBULmxvZ2dlci5lcnJvcihcXFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlICdcXFwiICsgZXZlbnROYW1lICsgXFxcIicgZXZlbnQgZm9yIFxcXCIgKyB0YXJnZXREZXNjcmlwdGlvbik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgIH07XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvUGlwZWxpbmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLlJlc291cmNlcyA9IGZ1bmN0aW9uICgpIHsgfTtcXG5cXG5ULlR5cGVzLlJlc291cmNlcy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAocmVzb3VyY2VQYXRoLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xcbiAgICB0aGlzW3Jlc291cmNlUGF0aF0gPSB7XFxuICAgICAgICBjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XFxuICAgIH07XFxuICAgIFQubG9nZ2VyLmRlYnVnKFxcXCJNb2RlbCBsb2FkZWQgZm9yIFxcXCIgKyByZXNvdXJjZVBhdGgpO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL1Jlc291cmNlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuVGVtcGxhdGVzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuc3RvcmUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhdGgpIHtcXG4gICAgICAgIHZhciBpZCA9IFQuUGF0aChwYXRoKS5hc01hcmt1cElkZW50aWZpZXIoKS50b1N0cmluZygpO1xcbiAgICAgICAgZW1iZWRUZW1wbGF0ZSh0ZW1wbGF0ZSwgJ3RlbXBsYXRlLScgKyBpZCk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBlbWJlZFRlbXBsYXRlKHRlbXBsYXRlLCBpZCkge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC90ZW1wbGF0ZScpO1xcbiAgICAgICAgZWxlbWVudC5pZCA9IGlkO1xcbiAgICAgICAgZWxlbWVudC50ZXh0ID0gdGVtcGxhdGU7XFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xcbiAgICB9XFxuICAgIFxcbiAgICB0aGlzLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGgpIHtcXG4gICAgICAgIHJldHVybiAkKCdoZWFkIHNjcmlwdCN0ZW1wbGF0ZS0nICsgVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpKS5sZW5ndGggPiAwO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhdGgpIHtcXG4gICAgICAgIHZhciBpZCA9IFQuUGF0aChwYXRoKS5hc01hcmt1cElkZW50aWZpZXIoKTtcXG4gICAgICAgIC8vIGNhbid0IHVzZSBodG1sKCkgdG8gYXBwZW5kIC0gdGhpcyB1c2VzIHRoZSBlbGVtZW50IGlubmVySFRNTCBwcm9wZXJ0eSBhbmQgSUU3IGFuZCA4IHdpbGwgc3RyaXAgY29tbWVudHMgKGkuZS4gY29udGFpbmVybGVzcyBjb250cm9sIGZsb3cgYmluZGluZ3MpXFxuICAgICAgICAkKHRhcmdldCkuZW1wdHkoKS5hcHBlbmQoJCgnaGVhZCBzY3JpcHQjdGVtcGxhdGUtJyArIGlkKS5odG1sKCkpO1xcbiAgICB9O1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL1RlbXBsYXRlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLmFjdGl2ZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHJldHVybiBULlV0aWxzLmVsZW1lbnREZXN0cm95ZWQocGFuZS5lbGVtZW50KTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvYWN0aXZlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnRleHQubW9kZWxzW3BhbmUucGF0aF07XFxuICAgIHZhciBtb2RlbCA9IGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciA/XFxuICAgICAgICBuZXcgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcihwYW5lKSA6XFxuICAgICAgICB7IHBhbmU6IHBhbmUsIGRhdGE6IHBhbmUuZGF0YSB9O1xcblxcbiAgICBULlV0aWxzLmVtYmVkU3RhdGUobW9kZWwsIGNvbnRleHQsIHBhbmUubm9kZSk7XFxuXFxuICAgIHBhbmUubW9kZWwgPSBtb2RlbDtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvY3JlYXRlTW9kZWwuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5jcmVhdGVQdWJTdWIgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAoY29udGV4dC5wdWJzdWIpXFxuICAgICAgICBwYW5lLnB1YnN1YiA9IGNvbnRleHQucHVic3ViLmNyZWF0ZUxpZmV0aW1lID9cXG4gICAgICAgICAgICBjb250ZXh0LnB1YnN1Yi5jcmVhdGVMaWZldGltZSgpIDpcXG4gICAgICAgICAgICBjb250ZXh0LnB1YnN1YjtcXG59O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvY3JlYXRlUHViU3ViLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuZGlzcG9zZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHBhbmUucHVic3ViICYmIHBhbmUucHVic3ViLmVuZCAmJiBwYW5lLnB1YnN1Yi5lbmQoKTtcXG4gICAgcGFuZS5kaXNwb3NlKCk7XFxuICAgIHBhbmUuaXMuZGlzcG9zZWQucmVzb2x2ZSgpO1xcbn07XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9kaXNwb3NlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuaW5pdGlhbGlzZU1vZGVsID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgaWYgKHBhbmUubW9kZWwuaW5pdGlhbGlzZSlcXG4gICAgICAgIHJldHVybiBwYW5lLm1vZGVsLmluaXRpYWxpc2UoKTtcXG4gICAgcmV0dXJuIG51bGw7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL2luaXRpYWxpc2VNb2RlbC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLmxvYWRSZXNvdXJjZXMgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgc3RyYXRlZ3kgPSBULkxvYWRTdHJhdGVnaWVzW2NvbnRleHQub3B0aW9ucy5sb2FkU3RyYXRlZ3ldO1xcbiAgICBcXG4gICAgaWYgKCFzdHJhdGVneSlcXG4gICAgICAgIHRocm93IFxcXCJVbmtub3duIHJlc291cmNlIGxvYWQgc3RyYXRlZ3lcXFwiO1xcblxcbiAgICByZXR1cm4gc3RyYXRlZ3kocGFuZSwgY29udGV4dCk7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL2xvYWRSZXNvdXJjZXMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5yZW5kZXJDb21wbGV0ZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgICQud2hlbihcXG4gICAgICAgIFQudHJhbnNpdGlvbihwYW5lLCBwYW5lLnRyYW5zaXRpb24sIHBhbmUucmV2ZXJzZVRyYW5zaXRpb25JbilbJ2luJ10oKSlcXG4gICAgIC5kb25lKGV4ZWN1dGVSZW5kZXJDb21wbGV0ZSk7XFxuICAgIFxcbiAgICBwYW5lLmVuZFJlbmRlcigpO1xcblxcbiAgICBmdW5jdGlvbiBleGVjdXRlUmVuZGVyQ29tcGxldGUoKSB7XFxuICAgICAgICBpZiAocGFuZS5tb2RlbC5yZW5kZXJDb21wbGV0ZSlcXG4gICAgICAgICAgICBwYW5lLm1vZGVsLnJlbmRlckNvbXBsZXRlKCk7XFxuICAgICAgICBwYW5lLmlzLnJlbmRlcmVkLnJlc29sdmUoKTtcXG4gICAgICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50KCdyZW5kZXJDb21wbGV0ZScsIHBhbmUpO1xcbiAgICAgICAgY29udGV4dC5yZW5kZXJPcGVyYXRpb24gPSBuZXcgVC5UeXBlcy5PcGVyYXRpb24oKTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9yZW5kZXJDb21wbGV0ZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLnJlbmRlclBhbmUgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgcmVuZGVyT3BlcmF0aW9uID0gY29udGV4dC5yZW5kZXJPcGVyYXRpb247XFxuXFxuICAgIHBhbmUuc3RhcnRSZW5kZXIoKTtcXG4gICAgY29udGV4dC50ZW1wbGF0ZXMucmVuZGVyKHBhbmUuZWxlbWVudCwgcGFuZS5wYXRoKTtcXG4gICAgVC5VdGlscy50cnlDYXRjaChhcHBseUJpbmRpbmdzLCBudWxsLCBjb250ZXh0Lm9wdGlvbnMuaGFuZGxlRXhjZXB0aW9ucywgJ0FuIGVycm9yIG9jY3VycmVkIGFwcGx5aW5nIHRoZSBiaW5kaW5ncyBmb3IgJyArIHBhbmUudG9TdHJpbmcoKSk7XFxuXFxuICAgIGlmIChwYW5lLm1vZGVsLnBhbmVSZW5kZXJlZClcXG4gICAgICAgIHBhbmUubW9kZWwucGFuZVJlbmRlcmVkKCk7XFxuXFxuICAgIHJlbmRlck9wZXJhdGlvbi5jb21wbGV0ZShwYW5lKTtcXG4gICAgcmV0dXJuIHJlbmRlck9wZXJhdGlvbi5wcm9taXNlO1xcblxcbiAgICBmdW5jdGlvbiBhcHBseUJpbmRpbmdzKCkge1xcbiAgICAgICAga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMocGFuZS5tb2RlbCwgcGFuZS5lbGVtZW50KTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9yZW5kZXJQYW5lLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuanMgPSBmdW5jdGlvbiAodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcXG4gICAgcmV0dXJuICQuYWpheCh7XFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGRhdGFUeXBlOiAndGV4dCcsXFxuICAgICAgICBhc3luYzogIWNvbnRleHQub3B0aW9ucy5zeW5jaHJvbm91cyxcXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgIHN1Y2Nlc3M6IGV4ZWN1dGVTY3JpcHRcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVTY3JpcHQoc2NyaXB0KSB7XFxuICAgICAgICBULnNjcmlwdEVudmlyb25tZW50ID0ge1xcbiAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgIHJlc291cmNlUGF0aDogcmVzb3VyY2VQYXRoLFxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBULlV0aWxzLnRyeUNhdGNoKCQuZ2xvYmFsRXZhbCwgW2FwcGVuZFNvdXJjZVVybChzY3JpcHQpXSwgY29udGV4dC5vcHRpb25zLmhhbmRsZUV4Y2VwdGlvbnMsXFxuICAgICAgICAgICAgJ0FuIGVycm9yIG9jY3VycmVkIGV4ZWN1dGluZyBzY3JpcHQgbG9hZGVkIGZyb20gJyArIHVybCArIChyZXNvdXJjZVBhdGggPyAnIGZvciByZXNvdXJjZSAnICsgcmVzb3VyY2VQYXRoIDogJycpKTtcXG5cXG4gICAgICAgIGRlbGV0ZSBULnNjcmlwdEVudmlyb25tZW50O1xcblxcbiAgICAgICAgVC5sb2dnZXIuZGVidWcoJ0xvYWRlZCBzY3JpcHQgZnJvbSAnICsgdXJsKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhcHBlbmRTb3VyY2VVcmwoc2NyaXB0KSB7XFxuICAgICAgICByZXR1cm4gc2NyaXB0ICsgJ1xcXFxuLy9AIHNvdXJjZVVSTD10cmliZTovL0FwcGxpY2F0aW9uLycgKyB1cmwucmVwbGFjZSgvIC9nLCBcXFwiX1xcXCIpO1xcbiAgICB9ICAgIFxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0xvYWRIYW5kbGVycy9zY3JpcHRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuY3NzID0gZnVuY3Rpb24gKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdXBwb3J0c1RleHROb2RlcyA9IHRydWU7XFxuICAgIFxcbiAgICByZXR1cm4gJC5hamF4KHtcXG4gICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcXG4gICAgICAgIGFzeW5jOiAhY29udGV4dC5vcHRpb25zLnN5bmNocm9ub3VzLFxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxcbiAgICAgICAgc3VjY2VzczogcmVuZGVyU3R5bGVzaGVldFxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gcmVuZGVyU3R5bGVzaGVldChzdHlsZXNoZWV0KSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX3RyaWJlU3R5bGVzJyk7XFxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICdfX3RyaWJlJztcXG4gICAgICAgICAgICBlbGVtZW50LmlkID0gJ19fdHJpYmVTdHlsZXMnO1xcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZihzdXBwb3J0c1RleHROb2RlcylcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlc2hlZXQpKTtcXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XFxuICAgICAgICAgICAgICAgIHN1cHBvcnRzVGV4dE5vZGVzID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFzdXBwb3J0c1RleHROb2RlcylcXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHN0eWxlU2hlZXQuY3NzVGV4dCBpcyByZXF1aXJlZCBmb3IgSUU4IHN1cHBvcnRcXG4gICAgICAgICAgICAgICAgLy8gSUU4IGFsc28gaGFzIGEgbGltaXQgb24gdGhlIG51bWJlciBvZiA8c3R5bGUvPiBlbGVtZW50cywgc28gYXBwZW5kIGl0IHRvIHRoZSBzYW1lIG5vZGVcXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gc3R5bGVzaGVldDtcXG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gYXBwZW5kIHN0eWxlc2hlZXQgZm9yICcgKyByZXNvdXJjZVBhdGggKyAnIHRvIGRvY3VtZW50LicpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZEhhbmRsZXJzL3N0eWxlc2hlZXRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuaHRtID0gZnVuY3Rpb24gKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgIHJldHVybiAkLmFqYXgoe1xcbiAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxcbiAgICAgICAgYXN5bmM6ICFjb250ZXh0Lm9wdGlvbnMuc3luY2hyb25vdXMsXFxuICAgICAgICBjYWNoZTogZmFsc2UsXFxuICAgICAgICBzdWNjZXNzOiBzdG9yZVRlbXBsYXRlXFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBzdG9yZVRlbXBsYXRlKHRlbXBsYXRlKSB7XFxuICAgICAgICBjb250ZXh0LnRlbXBsYXRlcy5zdG9yZSh0ZW1wbGF0ZSwgcmVzb3VyY2VQYXRoKTtcXG4gICAgfVxcbn07XFxuVC5Mb2FkSGFuZGxlcnMuaHRtbCA9IFQuTG9hZEhhbmRsZXJzLmh0bTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZEhhbmRsZXJzL3RlbXBsYXRlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuTG9hZFN0cmF0ZWdpZXMuYWRob2MgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAoY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdICE9PSB1bmRlZmluZWQpXFxuICAgICAgICByZXR1cm4gY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdO1xcblxcbiAgICB2YXIgcGF0aCA9IFQuUGF0aChjb250ZXh0Lm9wdGlvbnMuYmFzZVBhdGgpLmNvbWJpbmUoVC5QYXRoKHBhbmUucGF0aCkubWFrZVJlbGF0aXZlKCkpO1xcblxcbiAgICBpZiAoY29udGV4dC50ZW1wbGF0ZXMubG9hZGVkKHBhbmUucGF0aCkgfHwgY29udGV4dC5tb2RlbHNbcGFuZS5wYXRoXSlcXG4gICAgICAgIHJldHVybiBudWxsO1xcblxcbiAgICB2YXIgZGVmZXJyZWQgPSAkLmNvbXBsZXRlKFtcXG4gICAgICAgIGNvbnRleHQubG9hZGVyLmdldChwYXRoLnNldEV4dGVuc2lvbignanMnKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpLFxcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdodG0nKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpLFxcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdjc3MnKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpXFxuICAgIF0pO1xcblxcbiAgICBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gPSBkZWZlcnJlZDtcXG5cXG4gICAgJC53aGVuKGRlZmVycmVkKVxcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IoXFxcIlVuYWJsZSB0byBsb2FkIHJlc291cmNlcyBmb3IgJ1xcXCIgKyBwYW5lLnBhdGggKyBcXFwiJy5cXFwiKTtcXG4gICAgICAgIH0pXFxuICAgICAgICAuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gPSBudWxsO1xcbiAgICAgICAgfSk7XFxuXFxuICAgIHJldHVybiBkZWZlcnJlZDtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9Mb2FkU3RyYXRlZ2llcy9hZGhvYy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuTG9hZFN0cmF0ZWdpZXMucHJlbG9hZGVkID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgaWYgKCFjb250ZXh0Lm1vZGVsc1twYW5lLnBhdGhdICYmICFjb250ZXh0LnRlbXBsYXRlcy5sb2FkZWQocGFuZS5wYXRoKSkge1xcbiAgICAgICAgVC5sb2dnZXIuZXJyb3IoXFxcIk5vIHJlc291cmNlcyBsb2FkZWQgZm9yICdcXFwiICsgcGFuZS5wYXRoICsgXFxcIicuXFxcIik7XFxuICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlamVjdCgpO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0xvYWRTdHJhdGVnaWVzL3ByZWxvYWRlZC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQudHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHRyYW5zaXRpb24sIHJldmVyc2UpIHtcXG4gICAgdmFyIG5vZGU7XFxuICAgIHZhciBwYW5lO1xcbiAgICB2YXIgZWxlbWVudDtcXG4gICAgc2V0U3RhdGUoKTtcXG4gICAgXFxuICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHx8IChwYW5lICYmIHBhbmUudHJhbnNpdGlvbikgfHwgKG5vZGUgJiYgbm9kZS50cmFuc2l0aW9uKTtcXG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gVC5UcmFuc2l0aW9uc1t0cmFuc2l0aW9uXTtcXG4gICAgaWYgKHJldmVyc2UgJiYgaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ucmV2ZXJzZSlcXG4gICAgICAgIGltcGxlbWVudGF0aW9uID0gVC5UcmFuc2l0aW9uc1tpbXBsZW1lbnRhdGlvbi5yZXZlcnNlXTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAgICdpbic6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkKGVsZW1lbnQpLnNob3coKTtcXG4gICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb25bJ2luJ10oZWxlbWVudCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICBvdXQ6IGZ1bmN0aW9uIChyZW1vdmUpIHtcXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uTW9kZSgpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ub3V0KGVsZW1lbnQpO1xcbiAgICAgICAgICAgICQud2hlbihwcm9taXNlKS5kb25lKHJlbW92ZUVsZW1lbnQpO1xcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XFxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmhpZGUoKS5hdHRyKCdzdHlsZScsICcnKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlXFxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBcXG4gICAgICAgIHRvOiBmdW5jdGlvbiAocGFuZU9wdGlvbnMsIHJlbW92ZSkge1xcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gVC5jb250ZXh0KCk7XFxuICAgICAgICAgICAgaWYgKG5vZGUpXFxuICAgICAgICAgICAgICAgIFQuVXRpbHMuaW5zZXJ0UGFuZUFmdGVyKG5vZGUsIGVsZW1lbnQsIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGFuZU9wdGlvbnMsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgcmV2ZXJzZVRyYW5zaXRpb25JbjogcmV2ZXJzZSB9KSwgY29udGV4dCk7XFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICBULmluc2VydE5vZGVBZnRlcihlbGVtZW50LCBULlV0aWxzLmdldFBhbmVPcHRpb25zKHBhbmVPcHRpb25zLCB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHJldmVyc2VUcmFuc2l0aW9uSW46IHJldmVyc2UgfSksIG51bGwsIGNvbnRleHQpO1xcbiAgICAgICAgICAgIHRoaXMub3V0KHJlbW92ZSk7XFxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucmVuZGVyT3BlcmF0aW9uLnByb21pc2U7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uTW9kZSgpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuICAgICAgICBpZiAoVC50cmFuc2l0aW9uLm1vZGUgPT09ICdmaXhlZCcpXFxuICAgICAgICAgICAgJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAkZWxlbWVudC53aWR0aCgpLFxcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZWxlbWVudC5vZmZzZXQoKS5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6ICRlbGVtZW50Lm9mZnNldCgpLnRvcFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgICAgICAgICAgICB3aWR0aDogJGVsZW1lbnQud2lkdGgoKSxcXG4gICAgICAgICAgICAgICAgbGVmdDogJGVsZW1lbnQucG9zaXRpb24oKS5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6ICRlbGVtZW50LnBvc2l0aW9uKCkudG9wXFxuICAgICAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0U3RhdGUoKSB7XFxuICAgICAgICBpZiAoIXRhcmdldCkgdGhyb3cgXFxcIk5vIHRhcmdldCBwYXNzZWQgdG8gVC50cmFuc2l0aW9uXFxcIjtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5Ob2RlKSB7XFxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldDtcXG4gICAgICAgICAgICBwYW5lID0gbm9kZS5wYW5lO1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYW5lLmVsZW1lbnQ7XFxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5QYW5lKSB7XFxuICAgICAgICAgICAgcGFuZSA9IHRhcmdldDtcXG4gICAgICAgICAgICBub2RlID0gcGFuZS5ub2RlO1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYW5lLmVsZW1lbnQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0YXJnZXQ7XFxuICAgICAgICB9XFxuICAgIH0gICAgXFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHJhbnNpdGlvbnMvdHJhbnNpdGlvbi5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0c1RyYW5zaXRpb25zKCk7XFxuICAgIFxcbiAgICBjcmVhdGVDc3NUcmFuc2l0aW9uKCdmYWRlJyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlTGVmdCcsICdzbGlkZVJpZ2h0Jyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlUmlnaHQnLCAnc2xpZGVMZWZ0Jyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlVXAnLCAnc2xpZGVEb3duJyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlRG93bicsICdzbGlkZVVwJyk7XFxuXFxuICAgIHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgdHJhbnNpdGlvbmVuZCBtc1RyYW5zaXRpb25FbmQnO1xcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVDc3NUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHJldmVyc2UpIHtcXG4gICAgICAgIFQuVHJhbnNpdGlvbnNbdHJhbnNpdGlvbl0gPSB7XFxuICAgICAgICAgICAgJ2luJzogZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHJldHVybiBudWxsO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYmluZCh0cmFuc2l0aW9uRW5kRXZlbnRzLCB0cmFuc2l0aW9uRW5kZWQoZWxlbWVudCwgcHJvbWlzZSkpXFxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3ByZXBhcmUgaW4gJyArIHRyYW5zaXRpb24pO1xcblxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIG91dDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHJldHVybiBudWxsO1xcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG5cXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygncHJlcGFyZSBvdXQgJyArIHRyYW5zaXRpb24pXFxuICAgICAgICAgICAgICAgICAgICAub24odHJhbnNpdGlvbkVuZEV2ZW50cywgdHJhbnNpdGlvbkVuZGVkKGVsZW1lbnQsIHByb21pc2UsIHRydWUpKTtcXG5cXG4gICAgICAgICAgICAgICAgdHJpZ2dlcihlbGVtZW50KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICByZXZlcnNlOiByZXZlcnNlIHx8IHRyYW5zaXRpb25cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygndHJpZ2dlcicpO1xcbiAgICAgICAgICAgIH0sIDMwKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRlZChlbGVtZW50LCBwcm9taXNlLCBoaWRlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnVuYmluZCh0cmFuc2l0aW9uRW5kRXZlbnRzKVxcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRyYW5zaXRpb24gKyAnIGluIG91dCBwcmVwYXJlIHRyaWdnZXInKTtcXG4gICAgICAgICAgICAgICAgaWYgKGhpZGUpICQoZWxlbWVudCkuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25zKCkge1xcbiAgICAgICAgdmFyIGIgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG4gICAgICAgIHZhciBzdHlsZSA9IGIuc3R5bGU7XFxuICAgICAgICB2YXIgcHJvcGVydHkgPSAndHJhbnNpdGlvbic7XFxuICAgICAgICB2YXIgdmVuZG9ycyA9IFsnTW96JywgJ1dlYmtpdCcsICdLaHRtbCcsICdPJywgJ21zJ107XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BlcnR5XSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxcblxcbiAgICAgICAgLy8gVGVzdHMgZm9yIHZlbmRvciBzcGVjaWZpYyBwcm9wXFxuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbdmVuZG9yc1tpXSArIHByb3BlcnR5XSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UcmFuc2l0aW9ucy9Dc3MvY3NzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuXFxuLy9cXG53aW5kb3cuX19hcHBlbmRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XFxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fdHJpYmVTdHlsZXMnKTtcXG4gICAgaWYgKCFlbGVtZW50KSB7XFxuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xcbiAgICAgICAgZWxlbWVudC5pZCA9ICdfX3RyaWJlU3R5bGVzJztcXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYoZWxlbWVudC5zdHlsZVNoZWV0KVxcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gY29udGVudDtcXG4gICAgZWxzZVxcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XFxufTsvL1xcbndpbmRvdy5fX2FwcGVuZFN0eWxlKCcudHJpZ2dlcnstd2Via2l0LXRyYW5zaXRpb246YWxsIDI1MG1zIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246YWxsIDI1MG1zIGVhc2UtaW4tb3V0fS5mYWRlLmluLnByZXBhcmV7b3BhY2l0eTowfS5mYWRlLmluLnRyaWdnZXJ7b3BhY2l0eToxfS5mYWRlLm91dC5wcmVwYXJle29wYWNpdHk6MX0uZmFkZS5vdXQudHJpZ2dlcntvcGFjaXR5OjB9LnNsaWRlUmlnaHQuaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LnNsaWRlUmlnaHQuaW4udHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfS5zbGlkZVJpZ2h0Lm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSl9LnNsaWRlTGVmdC5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSl9LnNsaWRlTGVmdC5pbi50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnNsaWRlTGVmdC5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LnNsaWRlRG93bi5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKX0uc2xpZGVEb3duLmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX0uc2xpZGVEb3duLm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSl9LnNsaWRlVXAuaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpfS5zbGlkZVVwLmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX0uc2xpZGVVcC5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwJSl9Jyk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1RyYW5zaXRpb25zL0Nzcy9zdHlsZS5jc3MuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBULnJlZ2lzdGVyTW9kZWwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhZGRSZXNvdXJjZSgnbW9kZWxzJywgVC5VdGlscy5hcmd1bWVudHMoYXJndW1lbnRzKSk7XFxuICAgIH07XFxuXFxuICAgIFQucmVnaXN0ZXJTYWdhID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYWRkUmVzb3VyY2UoJ3NhZ2FzJywgVC5VdGlscy5hcmd1bWVudHMoYXJndW1lbnRzKSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBhZGRSZXNvdXJjZShjb250ZXh0UHJvcGVydHksIGFyZ3MpIHtcXG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IFQuc2NyaXB0RW52aXJvbm1lbnQgfHwge307XFxuICAgICAgICB2YXIgY29udGV4dCA9IGVudmlyb25tZW50LmNvbnRleHQgfHwgVC5jb250ZXh0KCk7XFxuXFxuICAgICAgICB2YXIgcGF0aCA9IGFyZ3Muc3RyaW5nIHx8IGVudmlyb25tZW50LnJlc291cmNlUGF0aDtcXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZ3MuZnVuYztcXG4gICAgICAgIHZhciBvcHRpb25zID0gYXJncy5vYmplY3Q7XFxuXFxuICAgICAgICBjb250ZXh0W2NvbnRleHRQcm9wZXJ0eV0ucmVnaXN0ZXIocGF0aCwgY29uc3RydWN0b3IsIG9wdGlvbnMpO1xcbiAgICB9XFxuXFxuICAgIFQucnVuID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICAgICAgVC5vcHRpb25zID0gJC5leHRlbmQoVC5vcHRpb25zLCBvcHRpb25zKTtcXG4gICAgICAgIFQub3B0aW9ucy5wdWJzdWIgPSBULm9wdGlvbnMucHVic3ViIHx8IG5ldyBUcmliZS5QdWJTdWIoeyBzeW5jOiBULm9wdGlvbnMuc3luY2hyb25vdXMsIGhhbmRsZUV4Y2VwdGlvbnM6IFQub3B0aW9ucy5oYW5kbGVFeGNlcHRpb25zIH0pO1xcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncygpO1xcbiAgICB9O1xcbn0pKCk7IFxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9BcGkvYXBpLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRpY1N0YXRlO1xcblxcbiAgICBULmNvbnRleHQgPSBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICBzdGF0aWNTdGF0ZSA9IHN0YXRpY1N0YXRlIHx8IHtcXG4gICAgICAgICAgICBtb2RlbHM6IG5ldyBULlR5cGVzLlJlc291cmNlcygpLFxcbiAgICAgICAgICAgIHNhZ2FzOiBuZXcgVC5UeXBlcy5SZXNvdXJjZXMoKSxcXG4gICAgICAgICAgICBsb2FkZXI6IG5ldyBULlR5cGVzLkxvYWRlcigpLFxcbiAgICAgICAgICAgIG9wdGlvbnM6IFQub3B0aW9ucyxcXG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IG5ldyBULlR5cGVzLlRlbXBsYXRlcygpLFxcbiAgICAgICAgICAgIGxvYWRlZFBhbmVzOiB7fVxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBwZXJDb250ZXh0U3RhdGUgPSB7XFxuICAgICAgICAgICAgcmVuZGVyT3BlcmF0aW9uOiBuZXcgVC5UeXBlcy5PcGVyYXRpb24oKSxcXG4gICAgICAgICAgICBwdWJzdWI6IFQub3B0aW9ucy5wdWJzdWJcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIHN0YXRpY1N0YXRlLCBwZXJDb250ZXh0U3RhdGUsIHNvdXJjZSk7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL2NvbnRleHQuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULm9wdGlvbnMuZGVmYXVsdFVybFByb3ZpZGVyID0ge1xcbiAgICB1cmxEYXRhRnJvbTogZnVuY3Rpb24ocGFuZU9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBwYW5lT3B0aW9ucyAmJiB7IHVybDogJyMnICsgJC5wYXJhbShwYW5lT3B0aW9ucykgfTtcXG4gICAgfSxcXG4gICAgcGFuZU9wdGlvbnNGcm9tOiBmdW5jdGlvbih1cmwpIHtcXG4gICAgICAgIHJldHVybiB1cmwgJiYgVC5VdGlscy5kZXBhcmFtKHVybC5zdWJzdHIoMSkpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL2RlZmF1bHRVcmxQcm92aWRlci5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB1dGlscyA9IFQuVXRpbHM7XFxuXFxuICAgIFQuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCkge1xcbiAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgVC5ub2RlRm9yKGVsZW1lbnQpO1xcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdXRpbHMuY29udGV4dEZvcihlbGVtZW50KSB8fCBULmNvbnRleHQoKTtcXG5cXG4gICAgICAgIHZhciBub2RlID0gbmV3IFQuVHlwZXMuTm9kZShwYXJlbnROb2RlKTtcXG4gICAgICAgIHV0aWxzLmJpbmRQYW5lKG5vZGUsIGVsZW1lbnQsIHBhbmVPcHRpb25zLCBjb250ZXh0KTtcXG5cXG4gICAgICAgIHJldHVybiBub2RlO1xcbiAgICB9O1xcblxcbiAgICBULmFwcGVuZE5vZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCkge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKCc8ZGl2Lz4nKS5hcHBlbmRUbyh0YXJnZXQpO1xcbiAgICAgICAgcmV0dXJuIFQuY3JlYXRlTm9kZShlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCk7XFxuICAgIH07XFxuXFxuICAgIFQuaW5zZXJ0Tm9kZUFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCgnPGRpdi8+JykuaW5zZXJ0QWZ0ZXIodGFyZ2V0KTtcXG4gICAgICAgIHJldHVybiBULmNyZWF0ZU5vZGUoZWxlbWVudCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUgfHwgVC5ub2RlRm9yKHRhcmdldCksIGNvbnRleHQpO1xcbiAgICB9O1xcblxcbiAgICBULm5vZGVGb3IgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Tm9kZShrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcXG4gICAgfTtcXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9BcGkvbm9kZXMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24oKSB7XFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5mb3JlYWNoUHJvcGVydHkgPSB7XFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaC5pbml0KGVsZW1lbnQsIG1ha2VBY2Nlc3NvcihtYXBUb0FycmF5KHZhbHVlQWNjZXNzb3IoKSkpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5mb3JlYWNoLnVwZGF0ZShlbGVtZW50LCBtYWtlQWNjZXNzb3IobWFwVG9BcnJheSh2YWx1ZUFjY2Vzc29yKCkpKSwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3Ioc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWFwVG9BcnJheShzb3VyY2UpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSlcXG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdCwgZXh0ZW5kIGl0IG9udG8gYSBuZXcgb2JqZWN0XFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCQuZXh0ZW5kKHsgJGtleTogcHJvcGVydHkgfSwgc291cmNlW3Byb3BlcnR5XSkpO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0JpbmRpbmdIYW5kbGVycy9mb3JlYWNoUHJvcGVydHkuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5rby5iaW5kaW5nSGFuZGxlcnMubmF2aWdhdGUgPSB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICB2YXIgbm9kZSA9IFQubm9kZUZvcihlbGVtZW50KTtcXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xcblxcbiAgICAgICAgdmFyIGRhdGEgPSBULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBrby5iaW5kaW5nSGFuZGxlcnMudmFsaWRhdGVkQ2xpY2sgfHwga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrO1xcbiAgICAgICAgaGFuZGxlci5pbml0KGVsZW1lbnQsIG5hdmlnYXRlLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gbmF2aWdhdGUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5uYXZpZ2F0ZShkYXRhLnZhbHVlLCBULlV0aWxzLmNsb25lRGF0YShkYXRhLmRhdGEpKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL25hdmlnYXRlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxua28uYmluZGluZ0hhbmRsZXJzLm5hdmlnYXRlQmFjayA9IHtcXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcXG4gICAgICAgIHZhciBub2RlID0gVC5ub2RlRm9yKGVsZW1lbnQpO1xcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XFxuXFxuICAgICAgICBrby5iaW5kaW5nSGFuZGxlcnMuY2xpY2suaW5pdChlbGVtZW50LCBuYXZpZ2F0ZUJhY2ssIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBuYXZpZ2F0ZUJhY2soKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5uYXZpZ2F0ZUJhY2soKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL25hdmlnYXRlQmFjay5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbigpIHtcXG4gICAga28uYmluZGluZ0hhbmRsZXJzLnBhbmUgPSB7IGluaXQ6IHVwZGF0ZUJpbmRpbmcgfTtcXG5cXG4gICAgZnVuY3Rpb24gdXBkYXRlQmluZGluZyhlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICBULmNyZWF0ZU5vZGUoZWxlbWVudCwgY29uc3RydWN0UGFuZU9wdGlvbnMoKSwgVC5VdGlscy5leHRyYWN0Tm9kZShiaW5kaW5nQ29udGV4dCksIFQuVXRpbHMuZXh0cmFjdENvbnRleHQoYmluZGluZ0NvbnRleHQpKTtcXG5cXG4gICAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RQYW5lT3B0aW9ucygpIHtcXG4gICAgICAgICAgICByZXR1cm4gVC5VdGlscy5nZXRQYW5lT3B0aW9ucyhrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSksIGFsbEJpbmRpbmdzQWNjZXNzb3IoKSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9CaW5kaW5nSGFuZGxlcnMvcGFuZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmtvLmJpbmRpbmdIYW5kbGVycy5wdWJsaXNoID0ge1xcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgdmFyIHB1YnN1YiA9IFQubm9kZUZvcihlbGVtZW50KS5wYW5lLnB1YnN1YjtcXG4gICAgICAgIGlmICghcHVic3ViKSByZXR1cm47XFxuXFxuICAgICAgICB2YXIgZGF0YSA9IFQuVXRpbHMubm9ybWFsaXNlQmluZGluZ3ModmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvcik7XFxuICAgICAgICB2YXIgaGFuZGxlciA9IGtvLmJpbmRpbmdIYW5kbGVycy52YWxpZGF0ZWRDbGljayB8fCBrby5iaW5kaW5nSGFuZGxlcnMuY2xpY2s7XFxuICAgICAgICBoYW5kbGVyLmluaXQoZWxlbWVudCwgcHVibGlzaEFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEFjY2Vzc29yKCkge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHB1YnN1Yi5wdWJsaXNoKGRhdGEudmFsdWUsIFQuVXRpbHMuY2xvbmVEYXRhKGRhdGEuZGF0YSkpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9CaW5kaW5nSGFuZGxlcnMvcHVibGlzaC5qc1wiKTtcbiIsIlQuc2NyaXB0RW52aXJvbm1lbnQgPSB7IHJlc291cmNlUGF0aDogJy9jb21wb3NpdGUnIH07XG4vKiEgVGhlIFRyaWJlIHBsYXRmb3JtIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIGh0dHA6Ly90cmliZWpzLmNvbS8gZm9yIG1vcmUgaW5mb3JtYXRpb24uICovXHJcblxuXG4vLyBzZXR1cC5qc1xuXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gICAgaWYgKHR5cGVvZiAoJCkgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIHRocm93ICdqUXVlcnkgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIGtub2Nrb3V0LmNvbXBvc2l0ZSBjYW4gaW5pdGlhbGlzZSc7XHJcbiAgICBpZiAodHlwZW9mIChrbykgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIHRocm93ICdrbm9ja291dC5qcyBtdXN0IGJlIGxvYWRlZCBiZWZvcmUga25vY2tvdXQuY29tcG9zaXRlIGNhbiBpbml0aWFsaXNlJztcclxuXHJcbiAgICBnbG9iYWwuVCA9IFQgfHwge307XHJcbiAgICBnbG9iYWwuVC5FdmVudHMgPSB7fTtcclxuICAgIGdsb2JhbC5ULkZhY3RvcmllcyA9IHt9O1xyXG4gICAgZ2xvYmFsLlQuTG9hZEhhbmRsZXJzID0ge307XHJcbiAgICBnbG9iYWwuVC5Mb2FkU3RyYXRlZ2llcyA9IHt9O1xyXG4gICAgZ2xvYmFsLlQuVHJhbnNpdGlvbnMgPSB7fTtcclxuICAgIGdsb2JhbC5ULlR5cGVzID0ge307XHJcbiAgICBnbG9iYWwuVC5VdGlscyA9IHt9O1xyXG5cclxuICAgICQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCgnaGVhZCcpLmFwcGVuZCgnPHN0eWxlIGNsYXNzPVwiX190cmliZVwiPi5fX3JlbmRlcmluZyB7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAtMTAwMDBweDsgbGVmdDogLTEwMDAwcHg7IH08L3N0eWxlPicpO1xyXG4gICAgfSk7XHJcbn0pKHdpbmRvdyB8fCB0aGlzKTtcclxuXG5cblxuLy8gb3B0aW9ucy5qc1xuXG5ULmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN5bmNocm9ub3VzOiBmYWxzZSxcclxuICAgICAgICBoYW5kbGVFeGNlcHRpb25zOiB0cnVlLFxyXG4gICAgICAgIGJhc2VQYXRoOiAnJyxcclxuICAgICAgICBsb2FkU3RyYXRlZ3k6ICdhZGhvYycsXHJcbiAgICAgICAgZXZlbnRzOiBbJ2xvYWRSZXNvdXJjZXMnLCAnY3JlYXRlUHViU3ViJywgJ2NyZWF0ZU1vZGVsJywgJ2luaXRpYWxpc2VNb2RlbCcsICdyZW5kZXJQYW5lJywgJ3JlbmRlckNvbXBsZXRlJywgJ2FjdGl2ZScsICdkaXNwb3NlJ11cclxuICAgIH07XHJcbn07XHJcblQub3B0aW9ucyA9IFQuZGVmYXVsdE9wdGlvbnMoKTtcclxuXG5cblxuLy8gbG9nZ2VyLmpzXG5cbnZhciBsZXZlbCA9IDQ7XHJcbnZhciBsZXZlbHMgPSB7XHJcbiAgICBkZWJ1ZzogNCxcclxuICAgIGluZm86IDMsXHJcbiAgICB3YXJuOiAyLFxyXG4gICAgZXJyb3I6IDEsXHJcbiAgICBub25lOiAwXHJcbn07XHJcblxyXG5ULmxvZ2dlciA9IHtcclxuICAgIHNldExldmVsOiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcclxuICAgICAgICBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XHJcbiAgICAgICAgaWYgKGxldmVsID09PSB1bmRlZmluZWQpIGxldmVsID0gNDtcclxuICAgIH0sXHJcbiAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobGV2ZWwgPj0gNClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coKCdERUJVRzogJyArIG1lc3NhZ2UpKTtcclxuICAgIH0sXHJcbiAgICBpbmZvOiBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChsZXZlbCA+PSAzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKCdJTkZPOiAnICsgbWVzc2FnZSkpO1xyXG4gICAgfSxcclxuICAgIHdhcm46IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID49IDIpXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigoJ1dBUk46ICcgKyBtZXNzYWdlKSk7XHJcbiAgICB9LFxyXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvcikge1xyXG4gICAgICAgIGlmIChsZXZlbCA+PSAxKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCgnRVJST1I6ICcgKyBtZXNzYWdlICsgJ1xcbicpLCBhcGkuZXJyb3JEZXRhaWxzKGVycm9yKSk7XHJcbiAgICB9LFxyXG4gICAgZXJyb3JEZXRhaWxzOiBmdW5jdGlvbiAoZXgpIHtcclxuICAgICAgICBpZiAoIWV4KSByZXR1cm4gJyc7XHJcbiAgICAgICAgcmV0dXJuIChleC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSA/IGV4IDpcclxuICAgICAgICAgICAgKGV4LnN0YWNrIHx8ICcnKSArIChleC5pbm5lciA/ICdcXG5cXG4nICsgdGhpcy5lcnJvckRldGFpbHMoZXguaW5uZXIpIDogJ1xcbicpO1xyXG4gICAgfSxcclxuICAgIGxvZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuXG5cblxuLy8gVXRpbGl0aWVzL2JpbmRpbmdIYW5kbGVycy5qc1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAga28uYmluZGluZ0hhbmRsZXJzLmNzc0NsYXNzID0ge1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5lbnRlclByZXNzZWQgPSBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIoMTMpO1xyXG4gICAga28uYmluZGluZ0hhbmRsZXJzLmVzY2FwZVByZXNzZWQgPSBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIoMjcpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIod2hpY2gpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHZhbHVlQWNjZXNzb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oY2FsbGJhY2spKVxyXG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmtleXVwKHRlc3RLZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RLZXkoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IHdoaWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vJGVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygkZWxlbWVudC52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbn0pKCk7XG5cblxuLy8gVXRpbGl0aWVzL2NvbGxlY3Rpb25zLmpzXG5cbihmdW5jdGlvbiAodXRpbHMpIHsgICAgXHJcbiAgICB1dGlscy5lYWNoID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuICQuZWFjaChjb2xsZWN0aW9uIHx8IFtdLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcih2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBqUXVlcnkgbWFwIGZsYXR0ZW5zIHJldHVybmVkIGFycmF5cyAtIHdlIGRvbid0IHdhbnQgdGhpcyBmb3IgZ3JpZHNcclxuICAgIHV0aWxzLm1hcCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVyYXRvcikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB1dGlscy5lYWNoKGNvbGxlY3Rpb24gfHwgW10sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVyYXRvcih2YWx1ZSwgaW5kZXgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICB1dGlscy5maWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgaXRlcmF0b3IpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgJC5lYWNoKGFycmF5IHx8IFtdLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKHZhbHVlLCBpbmRleCkpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgdXRpbHMucGx1Y2sgPSBmdW5jdGlvbihhcnJheSwgcHJvcGVydHkpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMubWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB1dGlscy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyYXksIGluaXRpYWxWYWx1ZSwgcmVkdWNlRnVuY3Rpb24pIHtcclxuICAgICAgICB1dGlscy5lYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gcmVkdWNlRnVuY3Rpb24oaW5pdGlhbFZhbHVlLCB2YWx1ZSwgaW5kZXgsIGFycmF5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xyXG4gICAgfTtcclxufSkoVC5VdGlscyk7XHJcblxuXG5cbi8vIFV0aWxpdGllcy9kZXBhcmFtLmpzXG5cbi8vIHRoaXMgaXMgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1iYnEvLCBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW4gYW5kIGFsc28gcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcblxyXG4vLyBEZXNlcmlhbGl6ZSBhIHBhcmFtcyBzdHJpbmcgaW50byBhbiBvYmplY3QsIG9wdGlvbmFsbHkgY29lcmNpbmcgbnVtYmVycyxcclxuLy8gYm9vbGVhbnMsIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXM7IHRoaXMgbWV0aG9kIGlzIHRoZSBjb3VudGVycGFydCB0byB0aGVcclxuLy8gaW50ZXJuYWwgalF1ZXJ5LnBhcmFtIG1ldGhvZC5cclxuVC5VdGlscy5kZXBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcywgY29lcmNlKSB7XHJcbiAgICB2YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xyXG4gICAgdmFyIG9iaiA9IHt9LFxyXG4gICAgICBjb2VyY2VfdHlwZXMgPSB7ICd0cnVlJzogITAsICdmYWxzZSc6ICExLCAnbnVsbCc6IG51bGwgfTtcclxuXHJcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5hbWU9dmFsdWUgcGFpcnMuXHJcbiAgICAkLmVhY2gocGFyYW1zLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCcmJyksIGZ1bmN0aW9uIChqLCB2KSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gdi5zcGxpdCgnPScpLFxyXG4gICAgICAgICAga2V5ID0gZGVjb2RlKHBhcmFtWzBdKSxcclxuICAgICAgICAgIHZhbCxcclxuICAgICAgICAgIGN1ciA9IG9iaixcclxuICAgICAgICAgIGkgPSAwLFxyXG5cclxuICAgICAgICAgIC8vIElmIGtleSBpcyBtb3JlIGNvbXBsZXggdGhhbiAnZm9vJywgbGlrZSAnYVtdJyBvciAnYVtiXVtjXScsIHNwbGl0IGl0XHJcbiAgICAgICAgICAvLyBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXHJcbiAgICAgICAgICBrZXlzID0ga2V5LnNwbGl0KCddWycpLFxyXG4gICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3Qga2V5cyBwYXJ0IGNvbnRhaW5zIFsgYW5kIHRoZSBsYXN0IGVuZHMgd2l0aCBdLCB0aGVuIFtdXHJcbiAgICAgICAgLy8gYXJlIGNvcnJlY3RseSBiYWxhbmNlZC5cclxuICAgICAgICBpZiAoL1xcWy8udGVzdChrZXlzWzBdKSAmJiAvXFxdJC8udGVzdChrZXlzW2tleXNfbGFzdF0pKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdHJhaWxpbmcgXSBmcm9tIHRoZSBsYXN0IGtleXMgcGFydC5cclxuICAgICAgICAgICAga2V5c1trZXlzX2xhc3RdID0ga2V5c1trZXlzX2xhc3RdLnJlcGxhY2UoL1xcXSQvLCAnJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdCBmaXJzdCBrZXlzIHBhcnQgaW50byB0d28gcGFydHMgb24gdGhlIFsgYW5kIGFkZCB0aGVtIGJhY2sgb250b1xyXG4gICAgICAgICAgICAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBrZXlzIGFycmF5LlxyXG4gICAgICAgICAgICBrZXlzID0ga2V5cy5zaGlmdCgpLnNwbGl0KCdbJykuY29uY2F0KGtleXMpO1xyXG5cclxuICAgICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEJhc2ljICdmb28nIHN0eWxlIGtleS5cclxuICAgICAgICAgICAga2V5c19sYXN0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lPXZhbHVlIHBhaXIsIG9yIGp1c3QgYSBuYW1lP1xyXG4gICAgICAgIGlmIChwYXJhbS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgdmFsID0gZGVjb2RlKHBhcmFtWzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvZXJjZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgIGlmIChjb2VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbCAmJiAhaXNOYU4odmFsKSA/ICt2YWwgICAgICAgICAgICAgIC8vIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICA6IHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgICAgICAgICAvLyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgOiBjb2VyY2VfdHlwZXNbdmFsXSAhPT0gdW5kZWZpbmVkID8gY29lcmNlX3R5cGVzW3ZhbF0gLy8gdHJ1ZSwgZmFsc2UsIG51bGxcclxuICAgICAgICAgICAgICAgICAgOiB2YWw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChrZXlzX2xhc3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXgga2V5LCBidWlsZCBkZWVwIG9iamVjdCBzdHJ1Y3R1cmUgYmFzZWQgb24gYSBmZXcgcnVsZXM6XHJcbiAgICAgICAgICAgICAgICAvLyAqIFRoZSAnY3VyJyBwb2ludGVyIHN0YXJ0cyBhdCB0aGUgb2JqZWN0IHRvcC1sZXZlbC5cclxuICAgICAgICAgICAgICAgIC8vICogW10gPSBhcnJheSBwdXNoIChuIGlzIHNldCB0byBhcnJheSBsZW5ndGgpLCBbbl0gPSBhcnJheSBpZiBuIGlzIFxyXG4gICAgICAgICAgICAgICAgLy8gICBudW1lcmljLCBvdGhlcndpc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgLy8gKiBJZiBhdCB0aGUgbGFzdCBrZXlzIHBhcnQsIHNldCB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAvLyAqIEZvciBlYWNoIGtleXMgcGFydCwgaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgdW5kZWZpbmVkIGNyZWF0ZSBhblxyXG4gICAgICAgICAgICAgICAgLy8gICBvYmplY3Qgb3IgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIG5leHQga2V5cyBwYXJ0LlxyXG4gICAgICAgICAgICAgICAgLy8gKiBNb3ZlIHRoZSAnY3VyJyBwb2ludGVyIHRvIHRoZSBuZXh0IGxldmVsLlxyXG4gICAgICAgICAgICAgICAgLy8gKiBSaW5zZSAmIHJlcGVhdC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDw9IGtleXNfbGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXSA9PT0gJycgPyBjdXIubGVuZ3RoIDoga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXJba2V5XSA9IGkgPCBrZXlzX2xhc3RcclxuICAgICAgICAgICAgICAgICAgICAgID8gY3VyW2tleV0gfHwgKGtleXNbaSArIDFdICYmIGlzTmFOKGtleXNbaSArIDFdKSA/IHt9IDogW10pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUga2V5LCBldmVuIHNpbXBsZXIgcnVsZXMsIHNpbmNlIG9ubHkgc2NhbGFycyBhbmQgc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgLy8gYXJyYXlzIGFyZSBhbGxvd2VkLlxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsIGlzIGFscmVhZHkgYW4gYXJyYXksIHNvIHB1c2ggb24gdGhlIG5leHQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbCBpc24ndCBhbiBhcnJheSwgYnV0IHNpbmNlIGEgc2Vjb25kIHZhbHVlIGhhcyBiZWVuIHNwZWNpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHZhbCBpbnRvIGFuIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gW29ialtrZXldLCB2YWxdO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsIGlzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHZhbHVlIHdhcyBkZWZpbmVkLCBzbyBzZXQgc29tZXRoaW5nIG1lYW5pbmdmdWwuXHJcbiAgICAgICAgICAgIG9ialtrZXldID0gY29lcmNlXHJcbiAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbn07XG5cblxuLy8gVXRpbGl0aWVzL2VtYmVkZGVkQ29udGV4dC5qc1xuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICBULlV0aWxzLmVtYmVkU3RhdGUgPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRleHQsIG5vZGUpIHtcclxuICAgICAgICBlbWJlZFByb3BlcnR5KG1vZGVsLCAnY29udGV4dCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGVtYmVkUHJvcGVydHkobW9kZWwsICdub2RlJywgbm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFQuVXRpbHMuY29udGV4dEZvciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Q29udGV4dChrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcclxuICAgIH07XHJcblxyXG4gICAgVC5VdGlscy5leHRyYWN0Q29udGV4dCA9IGZ1bmN0aW9uIChrb0JpbmRpbmdDb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGtvQmluZGluZ0NvbnRleHQgJiYgZW1iZWRkZWRQcm9wZXJ0eShrb0JpbmRpbmdDb250ZXh0LiRyb290LCAnY29udGV4dCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBULlV0aWxzLmV4dHJhY3ROb2RlID0gZnVuY3Rpb24gKGtvQmluZGluZ0NvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4ga29CaW5kaW5nQ29udGV4dCAmJiBlbWJlZGRlZFByb3BlcnR5KGtvQmluZGluZ0NvbnRleHQuJHJvb3QsICdub2RlJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGVtYmVkUHJvcGVydHkodGFyZ2V0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpXHJcbiAgICAgICAgICAgIHRocm93IFwiQ2FuJ3QgZW1iZWQgcHJvcGVydHkgaW4gZmFsc3kgdmFsdWVcIjtcclxuICAgICAgICB0YXJnZXRbJ19fJyArIGtleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbWJlZGRlZFByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXRbJ19fJyArIGtleV07XHJcbiAgICB9XHJcbn0pKCk7XHJcblxuXG5cbi8vIFV0aWxpdGllcy9ldmVudHMuanNcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFQuVXRpbHMuZWxlbWVudERlc3Ryb3llZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY29uc3RydWN0b3IgPT09IGpRdWVyeSlcclxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XHJcblxyXG4gICAgICAgIHZhciBwcm9taXNlID0gJC5EZWZlcnJlZCgpO1xyXG5cclxuICAgICAgICAvLyBSZXNvbHZlIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIHVzaW5nIGpRdWVyeS4gVGhpcyBpcyBhIGZhbGxiYWNrIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBET01Ob2RlUmVtb3ZlZCBhbmQgYWxzbyBleGVjdXRlcyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICQoZWxlbWVudCkub24oJ2Rlc3Ryb3llZCcsIHJlc29sdmUpO1xyXG5cclxuICAgICAgICAvLyBSZXNvbHZlIHVzaW5nIHRoZSBET01Ob2RlUmVtb3ZlZCBldmVudC4gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHRoaXMuXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oXCJET01Ob2RlUmVtb3ZlZFwiLCBtYXRjaEVsZW1lbnQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRjaEVsZW1lbnQoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudClcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoKSB7XHJcbiAgICAgICAgICAgICQoZWxlbWVudCkub2ZmKCdkZXN0cm95ZWQnLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdET01Ob2RlUmVtb3ZlZCcsIG1hdGNoRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHRoaXMgdXNlZCB0byB1c2UgRE9NIGZ1bmN0aW9ucyB0byByYWlzZSBldmVudHMsIGJ1dCBJRTggZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBldmVudHNcclxuICAgIC8vIHdlJ2xsIHVzZSBqUXVlcnksIGJ1dCBleHBvc2UgdGhlIG9yaWdpbmFsRXZlbnQgZm9yIERPTSBldmVudHMgYW5kIHRoZSBqUXVlcnkgZXZlbnRcclxuICAgIC8vIGZvciBjdXN0b20gZXZlbnRzIChvcmlnaW5hbEV2ZW50IGlzIG51bGwgZm9yIGN1c3RvbSBldmVudHMpLlxyXG4gICAgVC5VdGlscy5yYWlzZURvY3VtZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXZlbnREYXRhKSB7XHJcbiAgICAgICAgdmFyIGUgPSAkLkV2ZW50KG5hbWUpO1xyXG4gICAgICAgIGUuZXZlbnREYXRhID0gZXZlbnREYXRhO1xyXG4gICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBoYW5kbGVycyA9IHt9O1xyXG5cclxuICAgIC8vIGlmIGEgaGFuZGxlciBpcyB1c2VkIGZvciBtb3JlIHRoYW4gb25lIGV2ZW50LCBhIGxlYWsgd2lsbCBvY2N1clxyXG4gICAgVC5VdGlscy5oYW5kbGVEb2N1bWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKGRvY3VtZW50KS5vbihuYW1lLCBpbnRlcm5hbEhhbmRsZXIpO1xyXG4gICAgICAgIGhhbmRsZXJzW2hhbmRsZXJdID0gaW50ZXJuYWxIYW5kbGVyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsSGFuZGxlcihlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoZS5vcmlnaW5hbEV2ZW50IHx8IGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVC5VdGlscy5kZXRhY2hEb2N1bWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKGRvY3VtZW50KS5vZmYobmFtZSwgaGFuZGxlcnNbaGFuZGxlcl0pO1xyXG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1toYW5kbGVyXTtcclxuICAgIH07XHJcbn0pKCk7XG5cblxuLy8gVXRpbGl0aWVzL2V4Y2VwdGlvbnMuanNcblxuVC5VdGlscy50cnlDYXRjaCA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGhhbmRsZUV4Y2VwdGlvbnMsIG1lc3NhZ2UpIHtcclxuICAgIGlmIChoYW5kbGVFeGNlcHRpb25zKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IobWVzc2FnZSwgZXgpO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xyXG59O1xuXG5cbi8vIFV0aWxpdGllcy9pZEdlbmVyYXRvci5qc1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgVC5VdGlscy5pZEdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCsrO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnZW5lcmF0b3IgPSBULlV0aWxzLmlkR2VuZXJhdG9yKCk7XHJcbiAgICBULlV0aWxzLmdldFVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IubmV4dCgpO1xyXG4gICAgfTtcclxufSkoKTtcblxuXG4vLyBVdGlsaXRpZXMvaW5kZXhPZi5qc1xuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuLCBrLCB0ID0gT2JqZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxyXG4gICAgICAgICAgICAgICAgbiA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPSAwICYmIG4gIT0gSW5maW5pdHkgJiYgbiAhPSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4gPj0gbGVuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKSA7IGsgPCBsZW47IGsrKykge1xyXG4gICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbn1cblxuXG4vLyBVdGlsaXRpZXMvanF1ZXJ5LmNvbXBsZXRlLmpzXG5cbihmdW5jdGlvbiAoJCkge1xyXG4gICAgJC5jb21wbGV0ZSA9IGZ1bmN0aW9uIChkZWZlcnJlZHMpIHtcclxuICAgICAgICB2YXIgd3JhcHBlcnMgPSBbXTtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgdmFyIHJlc29sdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShkZWZlcnJlZHMpKVxyXG4gICAgICAgICAgICAkLmVhY2goZGVmZXJyZWRzLCB3cmFwRGVmZXJyZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgd3JhcERlZmVycmVkKDAsIGRlZmVycmVkcyk7XHJcblxyXG4gICAgICAgICQud2hlbi5hcHBseSgkLCB3cmFwcGVycykuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSA/XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCkgOlxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JhcERlZmVycmVkKGluZGV4LCBvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICB3cmFwcGVycy5wdXNoKCQuRGVmZXJyZWQoZnVuY3Rpb24gKHRoaXNEZWZlcnJlZCkge1xyXG4gICAgICAgICAgICAgICAgJC53aGVuKG9yaWdpbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoalF1ZXJ5KTtcblxuXG4vLyBVdGlsaXRpZXMvanF1ZXJ5LmRlc3Ryb3llZC5qc1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG9sZENsZWFuID0gJC5jbGVhbkRhdGE7XHJcblxyXG4gICAgLy8ga25vY2tvdXQgYWxzbyBjYWxscyBjbGVhbkRhdGEgZnJvbSBpdCdzIGNsZWFuTm9kZSBtZXRob2QgLSBhdm9pZCBhbnkgbG9vcHNcclxuICAgIC8vdmFyIGNsZWFuaW5nID0ge307XHJcblxyXG4gICAgJC5jbGVhbkRhdGEgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbGVtZW50c1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKCFjbGVhbmluZ1tlbGVtZW50XSkge1xyXG4gICAgICAgICAgICAgICAgLy9jbGVhbmluZ1tlbGVtZW50XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZGVzdHJveWVkXCIpO1xyXG4gICAgICAgICAgICAgICAgLy9kZWxldGUgY2xlYW5pbmdbZWxlbWVudF07XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRDbGVhbihlbGVtZW50cyk7XHJcbiAgICB9O1xyXG59KSgpO1xuXG5cbi8vIFV0aWxpdGllcy9rbm9ja291dC5qc1xuXG5ULlV0aWxzLmNsZWFuRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAvLyBwcmV2ZW50IGtub2Nrb3V0IGZyb20gY2FsbGluZyBjbGVhbkRhdGEgXHJcbiAgICAvLyAtIGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gdWx0aW1hdGVseSByZXN1bHQgZnJvbSBjbGVhbkRhdGEgYmVpbmcgY2FsbGVkIGJ5IGpRdWVyeSwgc28gYSBsb29wIHdpbGwgb2NjdXJcclxuICAgIHZhciBmdW5jID0gJC5jbGVhbkRhdGE7XHJcbiAgICAkLmNsZWFuRGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIGtvLmNsZWFuTm9kZShlbGVtZW50KTtcclxuICAgICQuY2xlYW5EYXRhID0gZnVuYztcclxufTtcblxuXG4vLyBVdGlsaXRpZXMvb2JqZWN0cy5qc1xuXG5ULlV0aWxzLmFyZ3VtZW50cyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICB2YXIgYnlDb25zdHJ1Y3RvciA9IHt9O1xyXG4gICAgJC5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChpbmRleCwgYXJnKSB7XHJcbiAgICAgICAgYnlDb25zdHJ1Y3RvclthcmcuY29uc3RydWN0b3JdID0gYXJnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBieUNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ5Q29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JqZWN0OiBieUNvbnN0cnVjdG9yW09iamVjdF0sXHJcbiAgICAgICAgc3RyaW5nOiBieUNvbnN0cnVjdG9yW1N0cmluZ10sXHJcbiAgICAgICAgZnVuYzogYnlDb25zdHJ1Y3RvcltGdW5jdGlvbl0sXHJcbiAgICAgICAgYXJyYXk6IGJ5Q29uc3RydWN0b3JbQXJyYXldLFxyXG4gICAgICAgIG51bWJlcjogYnlDb25zdHJ1Y3RvcltOdW1iZXJdXHJcbiAgICB9O1xyXG59O1xyXG5cclxuVC5VdGlscy5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XHJcbiAgICB2YXIgaW5kZXggPSAkLmluQXJyYXkoaXRlbSwgYXJyYXkpO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxufTtcclxuXHJcblQuVXRpbHMuaW5oZXJpdE9wdGlvbnMgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdGlvbnMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgdG9bb3B0aW9uc1tpXV0gPSBmcm9tW29wdGlvbnNbaV1dO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59O1xyXG5cclxuVC5VdGlscy5jbG9uZURhdGEgPSBmdW5jdGlvbiAoZnJvbSwgZXhjZXB0KSB7XHJcbiAgICBpZiAoIWZyb20pIHJldHVybjtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZyb20pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBmcm9tW3Byb3BlcnR5XTtcclxuICAgICAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiZcclxuICAgICAgICAgICAgKCFleGNlcHQgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcmd1bWVudHMsIHByb3BlcnR5KSA9PT0gLTEpICYmXHJcbiAgICAgICAgICAgICghdmFsdWUgfHwgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbiB8fCBrby5pc09ic2VydmFibGUodmFsdWUpKSkpXHJcblxyXG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVC5VdGlscy5ub3JtYWxpc2VCaW5kaW5ncyA9IGZ1bmN0aW9uICh2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yKSB7XHJcbiAgICB2YXIgZGF0YSA9IGFsbEJpbmRpbmdzQWNjZXNzb3IoKTtcclxuICAgIGRhdGEudmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XHJcbiAgICBpZiAoIWtvLmlzT2JzZXJ2YWJsZShkYXRhLnZhbHVlKSAmJiAkLmlzRnVuY3Rpb24oZGF0YS52YWx1ZSkpXHJcbiAgICAgICAgZGF0YS52YWx1ZSA9IGRhdGEudmFsdWUoKTtcclxuICAgIHJldHVybiBkYXRhO1xyXG59O1xyXG5cclxuXG5cblxuLy8gVXRpbGl0aWVzL3BhbmVzLmpzXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdXRpbHMgPSBULlV0aWxzO1xyXG5cclxuICAgIHV0aWxzLmdldFBhbmVPcHRpb25zID0gZnVuY3Rpb24odmFsdWUsIG90aGVyT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdmFsdWUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IHsgcGF0aDogdmFsdWUgfSA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb3RoZXJPcHRpb25zLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgdXRpbHMuYmluZFBhbmUgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB1dGlscy5jb250ZXh0Rm9yKGVsZW1lbnQpIHx8IFQuY29udGV4dCgpO1xyXG4gICAgICAgIHZhciBwYW5lID0gbmV3IFQuVHlwZXMuUGFuZSgkLmV4dGVuZCh7IGVsZW1lbnQ6ICQoZWxlbWVudClbMF0gfSwgcGFuZU9wdGlvbnMpKTtcclxuICAgICAgICBub2RlLnNldFBhbmUocGFuZSk7XHJcblxyXG4gICAgICAgIGNvbnRleHQucmVuZGVyT3BlcmF0aW9uLmFkZChwYW5lKTtcclxuXHJcbiAgICAgICAgdmFyIHBpcGVsaW5lID0gbmV3IFQuVHlwZXMuUGlwZWxpbmUoVC5FdmVudHMsIGNvbnRleHQpO1xyXG4gICAgICAgIHBpcGVsaW5lLmV4ZWN1dGUoY29udGV4dC5vcHRpb25zLmV2ZW50cywgcGFuZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwYW5lO1xyXG4gICAgfTtcclxuXHJcbiAgICB1dGlscy5pbnNlcnRQYW5lQWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdGFyZ2V0LCBwYW5lT3B0aW9ucywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCgnPGRpdi8+JykuaW5zZXJ0QWZ0ZXIodGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gdXRpbHMuYmluZFBhbmUobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxufSkoKTtcclxuXG5cblxuLy8gVXRpbGl0aWVzL1BhdGguanNcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgVC5QYXRoID0gUGF0aDtcclxuXHJcbiAgICBmdW5jdGlvbiBQYXRoKHBhdGgpIHtcclxuICAgICAgICBwYXRoID0gcGF0aCA/IG5vcm1hbGlzZShwYXRoLnRvU3RyaW5nKCkpIDogJyc7XHJcbiAgICAgICAgdmFyIGZpbGVuYW1lSW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDE7XHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbkluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZihcIi5cIik7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdpdGhvdXRGaWxlbmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChwYXRoLnN1YnN0cmluZygwLCBmaWxlbmFtZUluZGV4KSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHBhdGguc3Vic3RyaW5nKGZpbGVuYW1lSW5kZXgpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25JbmRleCA9PT0gLTEgPyAnJyA6IHBhdGguc3Vic3RyaW5nKGV4dGVuc2lvbkluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHdpdGhvdXRFeHRlbnNpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgoZXh0ZW5zaW9uSW5kZXggPT09IC0xID8gcGF0aCA6IHBhdGguc3Vic3RyaW5nKDAsIGV4dGVuc2lvbkluZGV4KSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbWJpbmU6IGZ1bmN0aW9uIChhZGRpdGlvbmFsUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgoKHBhdGggPyBwYXRoICsgJy8nIDogJycpICsgYWRkaXRpb25hbFBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmluZGV4T2YoJzovLycpID4gLTE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1ha2VBYnNvbHV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aCgnLycgKyBwYXRoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFrZVJlbGF0aXZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc01hcmt1cElkZW50aWZpZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbigpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwvL2csICctJykucmVwbGFjZSgvXFwuL2csICcnKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0RXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHRoaXMud2l0aG91dEV4dGVuc2lvbigpICsgJy4nICsgZXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShpbnB1dCkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IHJlbW92ZURvdWJsZVNsYXNoZXMoaW5wdXQpO1xyXG4gICAgICAgICAgICBpbnB1dCA9IHJlbW92ZVBhcmVudFBhdGhzKGlucHV0KTtcclxuICAgICAgICAgICAgaW5wdXQgPSByZW1vdmVDdXJyZW50UGF0aHMoaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRG91YmxlU2xhc2hlcyhpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgcHJlZml4RW5kID0gaW5wdXQuaW5kZXhPZignOi8vJykgPiAtMSA/IGlucHV0LmluZGV4T2YoJzovLycpICsgMyA6IDA7XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4RW5kKTtcclxuICAgICAgICAgICAgdmFyIGlucHV0UGF0aCA9IGlucHV0LnN1YnN0cmluZyhwcmVmaXhFbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgaW5wdXRQYXRoLnJlcGxhY2UoL1xcL3syLH0vZywgJy8nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBhcmVudFBhdGhzKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9bXlxcL1xcLl0rXFwvXFwuXFwuXFwvLztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5tYXRjaChyZWdleCkpXHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UocmVnZXgsICcnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUN1cnJlbnRQYXRocyhpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVnZXggPSAvXFwuXFwvL2c7XHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBsZWFkaW5nIHBhcmVudCBwYXRocyAtIHRoZSByZXN0IHdpbGwgaGF2ZSBiZWVuIHN0cmlwcGVkXHJcbiAgICAgICAgICAgIC8vIEkgY2FuJ3QgZmlndXJlIG91dCBhIHJlZ2V4IHRoYXQgd29uJ3Qgc3RyaXAgdGhlIC4vIG91dCBvZiAuLi9cclxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBpbnB1dC5sYXN0SW5kZXhPZignLi4vJyk7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IC0xID8gMCA6IHN0YXJ0SW5kZXggKyAzO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXgpICsgaW5wdXQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLnJlcGxhY2UocmVnZXgsICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cblxuXG4vLyBVdGlsaXRpZXMvcXVlcnlzdHJpbmcucGFyc2UuanNcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFRoaXMgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIG1vZHVsZXMgZnJvbSB0aGUgWVVJIExpYnJhcnkgLSBcclxuICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9hcGkvZmlsZXMvcXVlcnlzdHJpbmdfanNfcXVlcnlzdHJpbmctcGFyc2UuanMuaHRtbFxyXG4gICAgLy8gRWl0aGVyIGl0IHNob3VsZCBiZSByZXdyaXR0ZW4gb3IgYXR0cmlidXRpb24gYW5kIGxpY2Vuc2luZyBiZSBhdmFpbGFibGUgaGVyZSBhbmQgb24gdGhlIHdlYnNpdGUgbGlrZSBpbiBodHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cclxuXHJcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nID0gVC5VdGlscy5RdWVyeXN0cmluZyB8fCB7fTtcclxuXHJcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgc2VwZXJhdG9yLCBlcVN5bWJvbCkge1xyXG4gICAgICAgIHN0cmlwTGVhZEluKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIFQuVXRpbHMucmVkdWNlKFxyXG4gICAgICAgICAgICBULlV0aWxzLm1hcChcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5zcGxpdChzZXBlcmF0b3IgfHwgXCImXCIpLFxyXG4gICAgICAgICAgICAgICAgcGllY2VQYXJzZXIoZXFTeW1ib2wgfHwgXCI9XCIpXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBtZXJnZVBhcmFtc1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN0cmlwTGVhZEluKCkge1xyXG4gICAgICAgICAgICBpZihzb3VyY2UubGVuZ3RoID4gMCAmJiBzb3VyY2UuY2hhckF0KDApID09PSAnPycpXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHMpIHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHMucmVwbGFjZSgvXFwrL2csICcgJykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwaWVjZVBhcnNlcihlcSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZVBpZWNlKGtleSwgdmFsKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2xpY2VkLCBudW1WYWwsIGhlYWQsIHRhaWwsIHJldDtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXk9dmFsLCBjYWxsZWQgZnJvbSB0aGUgbWFwL3JlZHVjZVxyXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnNwbGl0KGVxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBpZWNlKFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlKGtleS5zaGlmdCgpKSxcclxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZShrZXkuam9pbihlcSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbiAgICAgICAgICAgIGlmICh2YWwuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbnVtZXJhbHMgdG8gbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtVmFsID0gK3ZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudW1WYWwudG9TdHJpbmcoMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG51bVZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNsaWNlZCA9IC8oLiopXFxbKFteXFxdXSopXFxdJC8uZXhlYyhrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIXNsaWNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gW1wiZm9vW11bYmFyXVtdW2Jhel1cIiwgXCJmb29bXVtiYXJdW11cIiwgXCJiYXpcIl1cclxuICAgICAgICAgICAgdGFpbCA9IHNsaWNlZFsyXTtcclxuICAgICAgICAgICAgaGVhZCA9IHNsaWNlZFsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFycmF5OiBrZXlbXT12YWxcclxuICAgICAgICAgICAgaWYgKCF0YWlsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGllY2UoaGVhZCwgW3ZhbF0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gb2JqZWN0OiBrZXlbc3Via2V5XT12YWxcclxuICAgICAgICAgICAgcmV0ID0ge307XHJcbiAgICAgICAgICAgIHJldFt0YWlsXSA9IHZhbDtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGllY2UoaGVhZCwgcmV0LCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoZSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVhY2ggcXVlcnkgcGllY2UgdG9nZXRoZXIgaW50byBvbmUgc2V0IG9mIHBhcmFtc1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VQYXJhbXMocGFyYW1zLCBhZGRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgdW5jb250ZXN0ZWQsIHRoZW4ganVzdCByZXR1cm4gdGhlIGFkZGl0aW9uLlxyXG4gICAgICAgICAgICAoIXBhcmFtcykgPyBhZGRpdGlvblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gY29uY2F0IGl0LlxyXG4gICAgICAgICAgICA6ICgkLmlzQXJyYXkocGFyYW1zKSkgPyBwYXJhbXMuY29uY2F0KGFkZGl0aW9uKVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGFuIGFycmF5LCBhbmQgZWl0aGVyIGFyZSBub3Qgb2JqZWN0cywgYXJyYXlpZnkgaXQuXHJcbiAgICAgICAgICAgIDogKCEkLmlzUGxhaW5PYmplY3QocGFyYW1zKSB8fCAhJC5pc1BsYWluT2JqZWN0KGFkZGl0aW9uKSkgPyBbcGFyYW1zXS5jb25jYXQoYWRkaXRpb24pXHJcbiAgICAgICAgICAgIC8vIGVsc2UgbWVyZ2UgdGhlbSBhcyBvYmplY3RzLCB3aGljaCBpcyBhIGxpdHRsZSBtb3JlIGNvbXBsZXhcclxuICAgICAgICAgICAgOiBtZXJnZU9iamVjdHMocGFyYW1zLCBhZGRpdGlvbilcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIHR3byAqb2JqZWN0cyogdG9nZXRoZXIuIElmIHRoaXMgaXMgY2FsbGVkLCB3ZSd2ZSBhbHJlYWR5IHJ1bGVkXHJcbiAgICAvLyBvdXQgdGhlIHNpbXBsZSBjYXNlcywgYW5kIG5lZWQgdG8gZG8gdGhlIGZvci1pbiBidXNpbmVzcy5cclxuICAgIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhwYXJhbXMsIGFkZGl0aW9uKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhZGRpdGlvbilcclxuICAgICAgICAgICAgaWYgKGkgJiYgYWRkaXRpb24uaGFzT3duUHJvcGVydHkoaSkpXHJcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBtZXJnZVBhcmFtcyhwYXJhbXNbaV0sIGFkZGl0aW9uW2ldKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH1cclxufSkoKTtcclxuXG5cblxuLy8gVXRpbGl0aWVzL3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeS5qc1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVGhpcyBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgbW9kdWxlcyBmcm9tIHRoZSBZVUkgTGlicmFyeSAtIFxyXG4gICAgLy8gaHR0cDovL3l1aWxpYnJhcnkuY29tL3l1aS9kb2NzL2FwaS9maWxlcy9xdWVyeXN0cmluZ19qc19xdWVyeXN0cmluZy1zdHJpbmdpZnkuanMuaHRtbFxyXG4gICAgLy8gRWl0aGVyIGl0IHNob3VsZCBiZSByZXdyaXR0ZW4gb3IgYXR0cmlidXRpb24gYW5kIGxpY2Vuc2luZyBiZSBhdmFpbGFibGUgaGVyZSBhbmQgb24gdGhlIHdlYnNpdGUgbGlrZSBpbiBodHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cclxuXHJcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nID0gVC5VdGlscy5RdWVyeXN0cmluZyB8fCB7fTtcclxuXHJcbiAgICB2YXIgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xyXG5cclxuICAgIFQuVXRpbHMuUXVlcnlzdHJpbmcuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkoc291cmNlLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHNvdXJjZSwgb3B0aW9ucywgbmFtZSwgc3RhY2spIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xyXG4gICAgICAgIHZhciBiZWdpbiwgZW5kLCBpLCBsLCBuLCBzO1xyXG4gICAgICAgIHZhciBzZXAgPSBvcHRpb25zLnNlcGVyYXRvciB8fCBcIiZcIjtcclxuICAgICAgICB2YXIgZXEgPSBvcHRpb25zLmVxU3ltYm9sIHx8IFwiPVwiO1xyXG4gICAgICAgIHZhciBhcnJheUtleSA9IG9wdGlvbnMuYXJyYXlLZXkgIT09IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lID8gZXNjYXBlKG5hbWUpICsgZXEgOiAnJztcclxuXHJcbiAgICAgICAgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQm9vbGVhbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc291cmNlKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSArc291cmNlO1xyXG5cclxuICAgICAgICBpZiAoIWlzTmFOKHNvdXJjZSkgfHwgc291cmNlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGUobmFtZSkgKyBlcSArIGVzY2FwZShzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoJC5pc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgcyA9IFtdO1xyXG4gICAgICAgICAgICBuYW1lID0gYXJyYXlLZXkgPyBuYW1lICsgJ1tdJyA6IG5hbWU7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goc3RyaW5naWZ5KHNvdXJjZVtpXSwgb3B0aW9ucywgbmFtZSwgc3RhY2spKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHMuam9pbihzZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBub3cgd2Uga25vdyBpdCdzIGFuIG9iamVjdC5cclxuICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljYWwgcmVmZXJlbmNlcyBpbiBuZXN0ZWQgb2JqZWN0c1xyXG4gICAgICAgIGZvciAoaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxyXG4gICAgICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHNvdXJjZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQuVXRpbHMuUXVlcnlzdHJpbmcuc3RyaW5naWZ5OiBjeWNsaWNhbCByZWZlcmVuY2VcIik7XHJcblxyXG4gICAgICAgIHN0YWNrLnB1c2goc291cmNlKTtcclxuICAgICAgICBzID0gW107XHJcbiAgICAgICAgYmVnaW4gPSBuYW1lID8gbmFtZSArICdbJyA6ICcnO1xyXG4gICAgICAgIGVuZCA9IG5hbWUgPyAnXScgOiAnJztcclxuICAgICAgICBmb3IgKGkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBiZWdpbiArIGkgKyBlbmQ7XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goc3RyaW5naWZ5KHNvdXJjZVtpXSwgb3B0aW9ucywgbiwgc3RhY2spKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcyA9IHMuam9pbihzZXApO1xyXG4gICAgICAgIGlmICghcyAmJiBuYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gbmFtZSArIFwiPVwiO1xyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH07XHJcbn0pKCk7XHJcblxuXG5cbi8vIFR5cGVzL0Zsb3cuanNcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFQuVHlwZXMuRmxvdyA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uU291cmNlLCBkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUgPSBuYXZpZ2F0aW9uTm9kZSgpO1xyXG4gICAgICAgIHRoaXMucHVic3ViID0gdGhpcy5ub2RlLnBhbmUucHVic3ViLm93bmVyO1xyXG4gICAgICAgIHRoaXMuc2FnYXMgPSBbXTtcclxuXHJcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24oc2VsZiwgZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdGhpcy5zYWdhID0gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHRoaXMucHVic3ViLCBkZWZpbml0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgc2VsZi5zYWdhLnN0YXJ0KGRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgc2VsZi5zYWdhLmVuZChkYXRhKTtcclxuICAgICAgICAgICAgVC5VdGlscy5lYWNoKHNlbGYuc2FnYXMsIGZ1bmN0aW9uKHNhZ2EpIHtcclxuICAgICAgICAgICAgICAgIHNhZ2EuZW5kKGRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbmF2aWdhdGlvbk5vZGUoKSB7XHJcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uU291cmNlLmNvbnN0cnVjdG9yID09PSBULlR5cGVzLk5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvblNvdXJjZS5maW5kTmF2aWdhdGlvbigpLm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uU291cmNlLmNvbnN0cnVjdG9yID09PSBULlR5cGVzLlBhbmUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvblNvdXJjZS5ub2RlLmZpbmROYXZpZ2F0aW9uKCkubm9kZTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmF2aWdhdGlvblNvdXJjZSBtdXN0IGJlIGVpdGhlciBULlR5cGVzLlBhbmUgb3IgVC5UeXBlcy5Ob2RlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydENoaWxkID0gZnVuY3Rpb24oZGVmaW5pdGlvbiwgZGF0YSkge1xyXG4gICAgICAgIGRlZmluaXRpb24gPSBjcmVhdGVEZWZpbml0aW9uKHRoaXMsIGRlZmluaXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2FnYS5zdGFydENoaWxkKGRlZmluaXRpb24sIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPck9wdGlvbnMsIGRhdGEpIHtcclxuICAgICAgICB0aGlzLm5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIGtlZXBzIGEgc2VwYXJhdGUgY29sbGVjdGlvbiBvZiBzYWdhcyBib3VuZCB0byB0aGlzIGZsb3cncyBsaWZldGltZVxyXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSB0byBtYWtlIHRoZW0gY2hpbGRyZW4gb2YgdGhlIHVuZGVybHlpbmcgc2FnYSwgYnV0XHJcbiAgICAvLyB0aGVuIHRoZXkgd291bGQgZW5kIGFueSB0aW1lIGEgbWVzc2FnZSB3YXMgZXhlY3V0ZWQuXHJcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLnN0YXJ0U2FnYSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIHNhZ2EgPSB0aGlzLnB1YnN1Yi5zdGFydFNhZ2EoZGVmaW5pdGlvbiwgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5zYWdhcy5wdXNoKHNhZ2EpO1xyXG4gICAgICAgIHJldHVybiBzYWdhO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBmbG93IGhlbHBlcnNcclxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5lbmRzQXQgPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xyXG4gICAgICAgIHZhciBmbG93ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmbG93Lm5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XHJcbiAgICAgICAgICAgIGZsb3cuZW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZsb3csIGRhdGEpIHtcclxuICAgICAgICB2YXIgdGhpc0Zsb3cgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpc0Zsb3cuc3RhcnRDaGlsZChmbG93LCBkYXRhKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gVGhpcyBpcyByZXVzZWQgYnkgTm9kZSBhbmQgUGFuZVxyXG4gICAgVC5UeXBlcy5GbG93LnN0YXJ0RmxvdyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBULlR5cGVzLkZsb3codGhpcywgZGVmaW5pdGlvbikuc3RhcnQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKGZsb3csIGRlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pXHJcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuZXcgZGVmaW5pdGlvbihmbG93KTtcclxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcclxuICAgIH1cclxufSkoKTtcblxuXG4vLyBUeXBlcy9IaXN0b3J5LmpzXG5cblQuVHlwZXMuSGlzdG9yeSA9IGZ1bmN0aW9uIChoaXN0b3J5KSB7XHJcbiAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcclxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgd2luZG93LnRpdGxlKTtcclxuXHJcbiAgICB2YXIgcG9wQWN0aW9ucyA9IHtcclxuICAgICAgICByYWlzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBULlV0aWxzLnJhaXNlRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIHsgY291bnQ6IChlLnN0YXRlIC0gY3VycmVudFN0YXRlKSB9KTtcclxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZS5zdGF0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVN0YWNrOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGUuc3RhdGU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnJhaXNlRXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBjdXJyZW50QWN0aW9uID0gcG9wQWN0aW9ucy5yYWlzZUV2ZW50O1xyXG5cclxuICAgIC8vIHRoaXMgbGVhdmVzIElFNyAmIDggaGlnaCBhbmQgZHJ5LiBXZSdsbCBwcm9iYWJseSByZXF1aXJlIGEgcG9seWZpbGwgYW5kIGNyZWF0ZSBhIGdlbmVyaWMgZXZlbnQgc3Vic2NyaXB0aW9uIG1ldGhvZFxyXG4gICAgaWYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZXhlY3V0ZUN1cnJlbnRBY3Rpb24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVDdXJyZW50QWN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoZS5zdGF0ZSAhPT0gbnVsbCkgY3VycmVudEFjdGlvbihlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKHVybE9wdGlvbnMpIHtcclxuICAgICAgICB1cmxPcHRpb25zID0gdXJsT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSgrK2N1cnJlbnRTdGF0ZSwgdXJsT3B0aW9ucy50aXRsZSwgdXJsT3B0aW9ucy51cmwpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdvID0gZnVuY3Rpb24oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIGhpc3RvcnkuZ28oZnJhbWVDb3VudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnVwZGF0ZVN0YWNrO1xyXG4gICAgICAgIGhpc3RvcnkuZ28oZnJhbWVDb3VudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBleGVjdXRlQ3VycmVudEFjdGlvbik7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSlcclxuICAgIFQuaGlzdG9yeSA9IG5ldyBULlR5cGVzLkhpc3Rvcnkod2luZG93Lmhpc3RvcnkpO1xyXG5lbHNlXHJcbiAgICBULmhpc3RvcnkgPSBuZXcgVC5UeXBlcy5IaXN0b3J5KHtcclxuICAgICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICBnbzogZnVuY3Rpb24gKCkgeyB9XHJcbiAgICB9KTtcblxuXG4vLyBUeXBlcy9Mb2FkZXIuanNcblxuVC5UeXBlcy5Mb2FkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgcmVzb3VyY2VzID0ge307XHJcblxyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbih1cmwsIHJlc291cmNlUGF0aCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChyZXNvdXJjZXNbdXJsXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzW3VybF07XHJcblxyXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBULlBhdGgodXJsKS5leHRlbnNpb24oKS50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gVC5Mb2FkSGFuZGxlcnNbZXh0ZW5zaW9uXTtcclxuXHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXNvdXJjZXNbdXJsXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICQud2hlbihyZXN1bHQpLmFsd2F5cyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJlc291cmNlc1t1cmxdID0gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVC5sb2dnZXIud2FybihcIlJlc291cmNlIG9mIHR5cGUgXCIgKyBleHRlbnNpb24gKyBcIiBidXQgbm8gaGFuZGxlciByZWdpc3RlcmVkLlwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbn07XHJcblxuXG5cbi8vIFR5cGVzL05hdmlnYXRpb24uanNcblxuVC5UeXBlcy5OYXZpZ2F0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcclxuICAgIG5vcm1hbGlzZU9wdGlvbnMoKTtcclxuICAgIHNldEluaXRpYWxQYW5lU3RhdGUoKTtcclxuXHJcbiAgICB2YXIgc3RhY2sgPSBbaW5pdGlhbFN0YWNrSXRlbSgpXTtcclxuICAgIHZhciBjdXJyZW50RnJhbWUgPSAwO1xyXG5cclxuICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XHJcblxyXG4gICAgdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYW5lT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmJyb3dzZXIpXHJcbiAgICAgICAgICAgIFQuaGlzdG9yeS5uYXZpZ2F0ZShvcHRpb25zLmJyb3dzZXIgJiYgb3B0aW9ucy5icm93c2VyLnVybERhdGFGcm9tKHBhbmVPcHRpb25zKSk7XHJcblxyXG4gICAgICAgIHRyaW1TdGFjaygpO1xyXG4gICAgICAgIHN0YWNrLnB1c2gocGFuZU9wdGlvbnMpO1xyXG4gICAgICAgIGN1cnJlbnRGcmFtZSsrO1xyXG5cclxuICAgICAgICBuYXZpZ2F0ZVRvKHBhbmVPcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pc0F0U3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdvID0gZnVuY3Rpb24oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIGdvKGZyYW1lQ291bnQpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmJyb3dzZXIpIFQuaGlzdG9yeS51cGRhdGUoZnJhbWVDb3VudCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBpZihvcHRpb25zLmJyb3dzZXIpIFQuVXRpbHMuaGFuZGxlRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIG9uQnJvd3NlckdvKTtcclxuICAgIGZ1bmN0aW9uIG9uQnJvd3NlckdvKGUpIHtcclxuICAgICAgICBnbyhlLmV2ZW50RGF0YS5jb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ28oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIHZhciBuZXdGcmFtZSA9IGN1cnJlbnRGcmFtZSArIGZyYW1lQ291bnQ7XHJcbiAgICAgICAgaWYgKG5ld0ZyYW1lIDwgMCkgbmV3RnJhbWUgPSAwO1xyXG4gICAgICAgIGlmIChuZXdGcmFtZSA+PSBzdGFjay5sZW5ndGgpIG5ld0ZyYW1lID0gc3RhY2subGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgaWYgKG5ld0ZyYW1lICE9IGN1cnJlbnRGcmFtZSlcclxuICAgICAgICAgICAgbmF2aWdhdGVUbyhzdGFja1tuZXdGcmFtZV0sIGZyYW1lQ291bnQgPCAwKTtcclxuXHJcbiAgICAgICAgY3VycmVudEZyYW1lID0gbmV3RnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVUbyhwYW5lT3B0aW9ucywgcmV2ZXJzZSkge1xyXG4gICAgICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50KCduYXZpZ2F0aW5nJywgeyBub2RlOiBub2RlLCBvcHRpb25zOiBwYW5lT3B0aW9ucywgYnJvd3NlckRhdGE6IG9wdGlvbnMuYnJvd3NlckRhdGEgfSk7XHJcbiAgICAgICAgbm9kZS50cmFuc2l0aW9uVG8ocGFuZU9wdGlvbnMsIG9wdGlvbnMudHJhbnNpdGlvbiwgcmV2ZXJzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJpbVN0YWNrKCkge1xyXG4gICAgICAgIHN0YWNrLnNwbGljZShjdXJyZW50RnJhbWUgKyAxLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFQuVXRpbHMuZGV0YWNoRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIG9uQnJvd3NlckdvKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMoKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT09IFN0cmluZylcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHsgdHJhbnNpdGlvbjogb3B0aW9ucyB9O1xyXG4gICAgICAgIGlmIChvcHRpb25zLmJyb3dzZXIgPT09IHRydWUpXHJcbiAgICAgICAgICAgIG9wdGlvbnMuYnJvd3NlciA9IFQub3B0aW9ucy5kZWZhdWx0VXJsUHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNldEluaXRpYWxQYW5lU3RhdGUoKSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goL1xcIy4qLyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5KSBxdWVyeSA9IHF1ZXJ5WzBdLnN1YnN0cmluZygxKTtcclxuICAgICAgICB2YXIgdXJsU3RhdGUgPSBvcHRpb25zLmJyb3dzZXIgJiYgb3B0aW9ucy5icm93c2VyLnBhbmVPcHRpb25zRnJvbShxdWVyeSk7XHJcbiAgICAgICAgaWYgKHVybFN0YXRlKSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFuZS5wYXRoID0gdXJsU3RhdGUucGF0aDtcclxuICAgICAgICAgICAgbm9kZS5wYW5lLmRhdGEgPSB1cmxTdGF0ZS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaW5pdGlhbFN0YWNrSXRlbSgpIHtcclxuICAgICAgICByZXR1cm4geyBwYXRoOiBub2RlLnBhbmUucGF0aCwgZGF0YTogbm9kZS5wYW5lLmRhdGEgfTtcclxuICAgIH1cclxufTtcblxuXG4vLyBUeXBlcy9Ob2RlLmpzXG5cblQuVHlwZXMuTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHBhbmUpIHtcclxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdGhpcy5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiB0aGlzO1xyXG4gICAgdGhpcy5pZCA9IFQuVXRpbHMuZ2V0VW5pcXVlSWQoKTtcclxuXHJcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcclxuICAgIGlmIChwYW5lKSB0aGlzLnNldFBhbmUocGFuZSk7XHJcbn07XHJcblxyXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPclBhbmUsIGRhdGEpIHtcclxuICAgIHZhciBwYW5lT3B0aW9ucyA9IFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGF0aE9yUGFuZSwgeyBkYXRhOiBkYXRhIH0pO1xyXG4gICAgaWYgKCFULlBhdGgocGFuZU9wdGlvbnMucGF0aCkuaXNBYnNvbHV0ZSgpKVxyXG4gICAgICAgIC8vIHRoaXMgaXMgZHVwbGljYXRlZCBpbiBQYW5lLmluaGVyaXRQYXRoRnJvbSAtIHRoZSBjb25jZXB0IChyZWxhdGl2ZSBwYXRocyBpbmhlcml0IGV4aXN0aW5nIHBhdGhzKSBuZWVkcyB0byBiZSBjbGVhcmVyXHJcbiAgICAgICAgcGFuZU9wdGlvbnMucGF0aCA9IFQuUGF0aCh0aGlzLm5vZGVGb3JQYXRoKCkucGFuZS5wYXRoKS53aXRob3V0RmlsZW5hbWUoKS5jb21iaW5lKHBhbmVPcHRpb25zLnBhdGgpLnRvU3RyaW5nKCk7XHJcbiAgICBcclxuICAgIHRoaXMuZmluZE5hdmlnYXRpb24oKS5uYXZpZ2F0ZShwYW5lT3B0aW9ucyk7XHJcbn07XHJcblxyXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZmluZE5hdmlnYXRpb24oKS5nbygtMSk7XHJcbn07XHJcblxyXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLmZpbmROYXZpZ2F0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5kZWZhdWx0TmF2aWdhdGlvbilcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TmF2aWdhdGlvbjtcclxuXHJcbiAgICBlbHNlIGlmICh0aGlzLm5hdmlnYXRpb24pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbjtcclxuICAgICAgICBcclxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgVC5UeXBlcy5OYXZpZ2F0aW9uKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROYXZpZ2F0aW9uKCk7XHJcbn07XHJcblxyXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uKHBhbmVPcHRpb25zLCB0cmFuc2l0aW9uLCByZXZlcnNlKSB7XHJcbiAgICBULnRyYW5zaXRpb24odGhpcywgdHJhbnNpdGlvbiwgcmV2ZXJzZSkudG8ocGFuZU9wdGlvbnMpO1xyXG59O1xyXG5cclxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5zZXRQYW5lID0gZnVuY3Rpb24gKHBhbmUpIHtcclxuICAgIGlmICh0aGlzLnBhbmUpXHJcbiAgICAgICAgdGhpcy5wYW5lLm5vZGUgPSBudWxsO1xyXG5cclxuICAgIHBhbmUubm9kZSA9IHRoaXM7XHJcbiAgICB0aGlzLnBhbmUgPSBwYW5lO1xyXG4gICAgdGhpcy5za2lwUGF0aCA9IHBhbmUuc2tpcFBhdGg7XHJcblxyXG4gICAgaWYgKHBhbmUuaGFuZGxlc05hdmlnYXRpb24pIHtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgVC5UeXBlcy5OYXZpZ2F0aW9uKHRoaXMsIHBhbmUuaGFuZGxlc05hdmlnYXRpb24pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHRoaXMgc2V0cyB0aGlzIHBhbmUgYXMgdGhlIFwiZGVmYXVsdFwiLCBhY2Nlc3NpYmxlIGZyb20gcGFuZXMgb3V0c2lkZSB0aGUgdHJlZS4gRmlyc3QgaW4gYmVzdCBkcmVzc2VkLlxyXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiB8fCB0aGlzLm5hdmlnYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcGFuZS5pbmhlcml0UGF0aEZyb20odGhpcy5wYXJlbnQpO1xyXG59O1xyXG5cclxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5ub2RlRm9yUGF0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2tpcFBhdGggJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5ub2RlRm9yUGF0aCgpIDogdGhpcztcclxufTtcclxuXHJcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9PT0gdGhpcy5uYXZpZ2F0aW9uKVxyXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMucGFyZW50KVxyXG4gICAgICAgIFQuVXRpbHMucmVtb3ZlSXRlbSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcyk7XHJcblxyXG4gICAgaWYgKHRoaXMucGFuZSAmJiB0aGlzLnBhbmUuZGlzcG9zZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhbmUubm9kZTtcclxuICAgICAgICB0aGlzLnBhbmUuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5zdGFydEZsb3cgPSBULlR5cGVzLkZsb3cuc3RhcnRGbG93O1xyXG5cblxuXG4vLyBUeXBlcy9PcGVyYXRpb24uanNcblxuVC5UeXBlcy5PcGVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgaW5jb21wbGV0ZSA9IFtdO1xyXG5cclxuICAgIHRoaXMucHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcclxuXHJcbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgaW5jb21wbGV0ZS5wdXNoKGlkKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIFQuVXRpbHMucmVtb3ZlSXRlbShpbmNvbXBsZXRlLCBpZCk7XHJcbiAgICAgICAgaWYgKGluY29tcGxldGUubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICBzZWxmLnByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfTtcclxuICAgIFxyXG59O1xuXG5cbi8vIFR5cGVzL1BhbmUuanNcblxuVC5UeXBlcy5QYW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIFQuVXRpbHMuaW5oZXJpdE9wdGlvbnMob3B0aW9ucywgdGhpcywgWydwYXRoJywgJ2RhdGEnLCAnZWxlbWVudCcsICd0cmFuc2l0aW9uJywgJ3JldmVyc2VUcmFuc2l0aW9uSW4nLCAnaGFuZGxlc05hdmlnYXRpb24nLCAncHVic3ViJywgJ2lkJywgJ3NraXBQYXRoJ10pO1xyXG5cclxuICAgIC8vIGV2ZW50cyB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBob29raW5nIGluIHRvIC0gdGhpcyBjb3VsZCBiZSBkb25lIGNvbXBsZXRlbHkgZ2VuZXJpY2FsbHkgYnkgdGhlIHBpcGVsaW5lXHJcbiAgICB0aGlzLmlzID0ge1xyXG4gICAgICAgIHJlbmRlcmVkOiAkLkRlZmVycmVkKCksXHJcbiAgICAgICAgZGlzcG9zZWQ6ICQuRGVmZXJyZWQoKVxyXG4gICAgfTsgICAgXHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPclBhbmUsIGRhdGEpIHtcclxuICAgIHRoaXMubm9kZSAmJiB0aGlzLm5vZGUubmF2aWdhdGUocGF0aE9yUGFuZSwgZGF0YSk7XHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubm9kZSAmJiB0aGlzLm5vZGUubmF2aWdhdGVCYWNrKCk7XHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICQodGhpcy5lbGVtZW50KS5yZW1vdmUoKTtcclxufTtcclxuXHJcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuZGlzcG9zZSlcclxuICAgICAgICB0aGlzLm1vZGVsLmRpc3Bvc2UoKTtcclxuXHJcbiAgICBpZiAodGhpcy5ub2RlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZS5wYW5lO1xyXG4gICAgICAgIHRoaXMubm9kZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZWxlbWVudClcclxuICAgICAgICBULlV0aWxzLmNsZWFuRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xyXG59O1xyXG5cclxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5pbmhlcml0UGF0aEZyb20gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgbm9kZSA9IG5vZGUgJiYgbm9kZS5ub2RlRm9yUGF0aCgpO1xyXG4gICAgdmFyIHBhbmUgPSBub2RlICYmIG5vZGUucGFuZTsgICAgXHJcbiAgICB2YXIgcGF0aCA9IFQuUGF0aCh0aGlzLnBhdGgpO1xyXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZSgpIHx8ICFwYW5lKVxyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgubWFrZUFic29sdXRlKCkudG9TdHJpbmcoKTtcclxuICAgIGVsc2VcclxuICAgICAgICB0aGlzLnBhdGggPSBULlBhdGgocGFuZS5wYXRoKS53aXRob3V0RmlsZW5hbWUoKS5jb21iaW5lKHBhdGgpLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuICQodGhpcy5lbGVtZW50KS5maW5kKHNlbGVjdG9yKTtcclxufTtcclxuXHJcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuc3RhcnRSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAkKHRoaXMuZWxlbWVudCkuYWRkQ2xhc3MoJ19fcmVuZGVyaW5nJyk7XHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmVuZFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICQodGhpcy5lbGVtZW50KS5yZW1vdmVDbGFzcygnX19yZW5kZXJpbmcnKTtcclxufTtcclxuXHJcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJ7IHBhdGg6ICdcIiArIHRoaXMucGF0aCArIFwiJyB9XCI7XHJcbn07XHJcblxyXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnN0YXJ0U2FnYSA9IGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcclxuICAgIHZhciBzYWdhID0gVC5jb250ZXh0KCkuc2FnYXNbcGF0aF07XHJcbiAgICB0aGlzLnB1YnN1Yi5zdGFydFNhZ2EuYXBwbHkodGhpcy5wdWJzdWIsIFtzYWdhLmNvbnN0cnVjdG9yXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xyXG59O1xyXG5cclxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5zdGFydEZsb3cgPSBULlR5cGVzLkZsb3cuc3RhcnRGbG93O1xyXG5cblxuXG4vLyBUeXBlcy9QaXBlbGluZS5qc1xuXG5ULlR5cGVzLlBpcGVsaW5lID0gZnVuY3Rpb24gKGV2ZW50cywgY29udGV4dCkge1xyXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24gKGV2ZW50c1RvRXhlY3V0ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IC0xO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gJC5EZWZlcnJlZCgpO1xyXG4gICAgICAgIGV4ZWN1dGVOZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZU5leHRFdmVudCgpIHtcclxuICAgICAgICAgICAgY3VycmVudEV2ZW50Kys7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RXZlbnQgPj0gZXZlbnRzVG9FeGVjdXRlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudHNUb0V4ZWN1dGVbY3VycmVudEV2ZW50XTtcclxuICAgICAgICAgICAgdmFyIHRoaXNFdmVudCA9IGV2ZW50c1tldmVudE5hbWVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIFQubG9nZ2VyLndhcm4oXCJObyBldmVudCBkZWZpbmVkIGZvciBcIiArIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlTmV4dEV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICQud2hlbih0aGlzRXZlbnQodGFyZ2V0LCBjb250ZXh0KSlcclxuICAgICAgICAgICAgICAgIC5kb25lKGV4ZWN1dGVOZXh0RXZlbnQpXHJcbiAgICAgICAgICAgICAgICAuZmFpbChoYW5kbGVGYWlsdXJlKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUZhaWx1cmUoKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldERlc2NyaXB0aW9uID0gdGFyZ2V0ID8gdGFyZ2V0LnRvU3RyaW5nKCkgOiBcImVtcHR5IHRhcmdldFwiO1xyXG4gICAgICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgJ1wiICsgZXZlbnROYW1lICsgXCInIGV2ZW50IGZvciBcIiArIHRhcmdldERlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59O1xuXG5cbi8vIFR5cGVzL1Jlc291cmNlcy5qc1xuXG5ULlR5cGVzLlJlc291cmNlcyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuXHJcblQuVHlwZXMuUmVzb3VyY2VzLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChyZXNvdXJjZVBhdGgsIGNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzW3Jlc291cmNlUGF0aF0gPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxyXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge31cclxuICAgIH07XHJcbiAgICBULmxvZ2dlci5kZWJ1ZyhcIk1vZGVsIGxvYWRlZCBmb3IgXCIgKyByZXNvdXJjZVBhdGgpO1xyXG59O1xuXG5cbi8vIFR5cGVzL1RlbXBsYXRlcy5qc1xuXG5ULlR5cGVzLlRlbXBsYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB0aGlzLnN0b3JlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBwYXRoKSB7XHJcbiAgICAgICAgdmFyIGlkID0gVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZW1iZWRUZW1wbGF0ZSh0ZW1wbGF0ZSwgJ3RlbXBsYXRlLScgKyBpZCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBlbWJlZFRlbXBsYXRlKHRlbXBsYXRlLCBpZCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnX190cmliZSc7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC90ZW1wbGF0ZScpO1xyXG4gICAgICAgIGVsZW1lbnQuaWQgPSBpZDtcclxuICAgICAgICBlbGVtZW50LnRleHQgPSB0ZW1wbGF0ZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gJCgnaGVhZCBzY3JpcHQjdGVtcGxhdGUtJyArIFQuUGF0aChwYXRoKS5hc01hcmt1cElkZW50aWZpZXIoKSkubGVuZ3RoID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXRoKSB7XHJcbiAgICAgICAgdmFyIGlkID0gVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpO1xyXG4gICAgICAgIC8vIGNhbid0IHVzZSBodG1sKCkgdG8gYXBwZW5kIC0gdGhpcyB1c2VzIHRoZSBlbGVtZW50IGlubmVySFRNTCBwcm9wZXJ0eSBhbmQgSUU3IGFuZCA4IHdpbGwgc3RyaXAgY29tbWVudHMgKGkuZS4gY29udGFpbmVybGVzcyBjb250cm9sIGZsb3cgYmluZGluZ3MpXHJcbiAgICAgICAgJCh0YXJnZXQpLmVtcHR5KCkuYXBwZW5kKCQoJ2hlYWQgc2NyaXB0I3RlbXBsYXRlLScgKyBpZCkuaHRtbCgpKTtcclxuICAgIH07XHJcbn07XG5cblxuLy8gRXZlbnRzL2FjdGl2ZS5qc1xuXG5ULkV2ZW50cy5hY3RpdmUgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIFQuVXRpbHMuZWxlbWVudERlc3Ryb3llZChwYW5lLmVsZW1lbnQpO1xyXG59O1xuXG5cbi8vIEV2ZW50cy9jcmVhdGVNb2RlbC5qc1xuXG5ULkV2ZW50cy5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnRleHQubW9kZWxzW3BhbmUucGF0aF07XHJcbiAgICB2YXIgbW9kZWwgPSBkZWZpbml0aW9uICYmIGRlZmluaXRpb24uY29uc3RydWN0b3IgP1xyXG4gICAgICAgIG5ldyBkZWZpbml0aW9uLmNvbnN0cnVjdG9yKHBhbmUpIDpcclxuICAgICAgICB7IHBhbmU6IHBhbmUsIGRhdGE6IHBhbmUuZGF0YSB9O1xyXG5cclxuICAgIFQuVXRpbHMuZW1iZWRTdGF0ZShtb2RlbCwgY29udGV4dCwgcGFuZS5ub2RlKTtcclxuXHJcbiAgICBwYW5lLm1vZGVsID0gbW9kZWw7XHJcbn07XG5cblxuLy8gRXZlbnRzL2NyZWF0ZVB1YlN1Yi5qc1xuXG5ULkV2ZW50cy5jcmVhdGVQdWJTdWIgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgaWYgKGNvbnRleHQucHVic3ViKVxyXG4gICAgICAgIHBhbmUucHVic3ViID0gY29udGV4dC5wdWJzdWIuY3JlYXRlTGlmZXRpbWUgP1xyXG4gICAgICAgICAgICBjb250ZXh0LnB1YnN1Yi5jcmVhdGVMaWZldGltZSgpIDpcclxuICAgICAgICAgICAgY29udGV4dC5wdWJzdWI7XHJcbn07XHJcblxuXG5cbi8vIEV2ZW50cy9kaXNwb3NlLmpzXG5cblQuRXZlbnRzLmRpc3Bvc2UgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgcGFuZS5wdWJzdWIgJiYgcGFuZS5wdWJzdWIuZW5kICYmIHBhbmUucHVic3ViLmVuZCgpO1xyXG4gICAgcGFuZS5kaXNwb3NlKCk7XHJcbiAgICBwYW5lLmlzLmRpc3Bvc2VkLnJlc29sdmUoKTtcclxufTtcclxuXG5cblxuLy8gRXZlbnRzL2luaXRpYWxpc2VNb2RlbC5qc1xuXG5ULkV2ZW50cy5pbml0aWFsaXNlTW9kZWwgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgaWYgKHBhbmUubW9kZWwuaW5pdGlhbGlzZSlcclxuICAgICAgICByZXR1cm4gcGFuZS5tb2RlbC5pbml0aWFsaXNlKCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcblxuXG4vLyBFdmVudHMvbG9hZFJlc291cmNlcy5qc1xuXG5ULkV2ZW50cy5sb2FkUmVzb3VyY2VzID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcclxuICAgIHZhciBzdHJhdGVneSA9IFQuTG9hZFN0cmF0ZWdpZXNbY29udGV4dC5vcHRpb25zLmxvYWRTdHJhdGVneV07XHJcbiAgICBcclxuICAgIGlmICghc3RyYXRlZ3kpXHJcbiAgICAgICAgdGhyb3cgXCJVbmtub3duIHJlc291cmNlIGxvYWQgc3RyYXRlZ3lcIjtcclxuXHJcbiAgICByZXR1cm4gc3RyYXRlZ3kocGFuZSwgY29udGV4dCk7XHJcbn07XG5cblxuLy8gRXZlbnRzL3JlbmRlckNvbXBsZXRlLmpzXG5cblQuRXZlbnRzLnJlbmRlckNvbXBsZXRlID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcclxuICAgICQud2hlbihcclxuICAgICAgICBULnRyYW5zaXRpb24ocGFuZSwgcGFuZS50cmFuc2l0aW9uLCBwYW5lLnJldmVyc2VUcmFuc2l0aW9uSW4pWydpbiddKCkpXHJcbiAgICAgLmRvbmUoZXhlY3V0ZVJlbmRlckNvbXBsZXRlKTtcclxuICAgIFxyXG4gICAgcGFuZS5lbmRSZW5kZXIoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBleGVjdXRlUmVuZGVyQ29tcGxldGUoKSB7XHJcbiAgICAgICAgaWYgKHBhbmUubW9kZWwucmVuZGVyQ29tcGxldGUpXHJcbiAgICAgICAgICAgIHBhbmUubW9kZWwucmVuZGVyQ29tcGxldGUoKTtcclxuICAgICAgICBwYW5lLmlzLnJlbmRlcmVkLnJlc29sdmUoKTtcclxuICAgICAgICBULlV0aWxzLnJhaXNlRG9jdW1lbnRFdmVudCgncmVuZGVyQ29tcGxldGUnLCBwYW5lKTtcclxuICAgICAgICBjb250ZXh0LnJlbmRlck9wZXJhdGlvbiA9IG5ldyBULlR5cGVzLk9wZXJhdGlvbigpO1xyXG4gICAgfVxyXG59O1xuXG5cbi8vIEV2ZW50cy9yZW5kZXJQYW5lLmpzXG5cblQuRXZlbnRzLnJlbmRlclBhbmUgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlbmRlck9wZXJhdGlvbiA9IGNvbnRleHQucmVuZGVyT3BlcmF0aW9uO1xyXG5cclxuICAgIHBhbmUuc3RhcnRSZW5kZXIoKTtcclxuICAgIGNvbnRleHQudGVtcGxhdGVzLnJlbmRlcihwYW5lLmVsZW1lbnQsIHBhbmUucGF0aCk7XHJcbiAgICBULlV0aWxzLnRyeUNhdGNoKGFwcGx5QmluZGluZ3MsIG51bGwsIGNvbnRleHQub3B0aW9ucy5oYW5kbGVFeGNlcHRpb25zLCAnQW4gZXJyb3Igb2NjdXJyZWQgYXBwbHlpbmcgdGhlIGJpbmRpbmdzIGZvciAnICsgcGFuZS50b1N0cmluZygpKTtcclxuXHJcbiAgICBpZiAocGFuZS5tb2RlbC5wYW5lUmVuZGVyZWQpXHJcbiAgICAgICAgcGFuZS5tb2RlbC5wYW5lUmVuZGVyZWQoKTtcclxuXHJcbiAgICByZW5kZXJPcGVyYXRpb24uY29tcGxldGUocGFuZSk7XHJcbiAgICByZXR1cm4gcmVuZGVyT3BlcmF0aW9uLnByb21pc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlCaW5kaW5ncygpIHtcclxuICAgICAgICBrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyhwYW5lLm1vZGVsLCBwYW5lLmVsZW1lbnQpO1xyXG4gICAgfVxyXG59O1xuXG5cbi8vIExvYWRIYW5kbGVycy9zY3JpcHRzLmpzXG5cblQuTG9hZEhhbmRsZXJzLmpzID0gZnVuY3Rpb24gKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxyXG4gICAgICAgIGFzeW5jOiAhY29udGV4dC5vcHRpb25zLnN5bmNocm9ub3VzLFxyXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcclxuICAgICAgICBzdWNjZXNzOiBleGVjdXRlU2NyaXB0XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBleGVjdXRlU2NyaXB0KHNjcmlwdCkge1xyXG4gICAgICAgIFQuc2NyaXB0RW52aXJvbm1lbnQgPSB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICByZXNvdXJjZVBhdGg6IHJlc291cmNlUGF0aCxcclxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFQuVXRpbHMudHJ5Q2F0Y2goJC5nbG9iYWxFdmFsLCBbYXBwZW5kU291cmNlVXJsKHNjcmlwdCldLCBjb250ZXh0Lm9wdGlvbnMuaGFuZGxlRXhjZXB0aW9ucyxcclxuICAgICAgICAgICAgJ0FuIGVycm9yIG9jY3VycmVkIGV4ZWN1dGluZyBzY3JpcHQgbG9hZGVkIGZyb20gJyArIHVybCArIChyZXNvdXJjZVBhdGggPyAnIGZvciByZXNvdXJjZSAnICsgcmVzb3VyY2VQYXRoIDogJycpKTtcclxuXHJcbiAgICAgICAgZGVsZXRlIFQuc2NyaXB0RW52aXJvbm1lbnQ7XHJcblxyXG4gICAgICAgIFQubG9nZ2VyLmRlYnVnKCdMb2FkZWQgc2NyaXB0IGZyb20gJyArIHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwZW5kU291cmNlVXJsKHNjcmlwdCkge1xyXG4gICAgICAgIHJldHVybiBzY3JpcHQgKyAnXFxuLy9AIHNvdXJjZVVSTD10cmliZTovL0FwcGxpY2F0aW9uLycgKyB1cmwucmVwbGFjZSgvIC9nLCBcIl9cIik7XHJcbiAgICB9ICAgIFxyXG59O1xuXG5cbi8vIExvYWRIYW5kbGVycy9zdHlsZXNoZWV0cy5qc1xuXG5ULkxvYWRIYW5kbGVycy5jc3MgPSBmdW5jdGlvbiAodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcclxuICAgIHZhciBzdXBwb3J0c1RleHROb2RlcyA9IHRydWU7XHJcbiAgICBcclxuICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIGRhdGFUeXBlOiAndGV4dCcsXHJcbiAgICAgICAgYXN5bmM6ICFjb250ZXh0Lm9wdGlvbnMuc3luY2hyb25vdXMsXHJcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgIHN1Y2Nlc3M6IHJlbmRlclN0eWxlc2hlZXRcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlclN0eWxlc2hlZXQoc3R5bGVzaGVldCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fdHJpYmVTdHlsZXMnKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xyXG4gICAgICAgICAgICBlbGVtZW50LmlkID0gJ19fdHJpYmVTdHlsZXMnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoc3VwcG9ydHNUZXh0Tm9kZXMpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlc2hlZXQpKTtcclxuICAgICAgICAgICAgfSBjYXRjaChleCkge1xyXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNUZXh0Tm9kZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXN1cHBvcnRzVGV4dE5vZGVzKVxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBzdHlsZVNoZWV0LmNzc1RleHQgaXMgcmVxdWlyZWQgZm9yIElFOCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyBJRTggYWxzbyBoYXMgYSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIDxzdHlsZS8+IGVsZW1lbnRzLCBzbyBhcHBlbmQgaXQgdG8gdGhlIHNhbWUgbm9kZVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gc3R5bGVzaGVldDtcclxuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGFwcGVuZCBzdHlsZXNoZWV0IGZvciAnICsgcmVzb3VyY2VQYXRoICsgJyB0byBkb2N1bWVudC4nKTtcclxuICAgIH1cclxufTtcblxuXG4vLyBMb2FkSGFuZGxlcnMvdGVtcGxhdGVzLmpzXG5cblQuTG9hZEhhbmRsZXJzLmh0bSA9IGZ1bmN0aW9uICh1cmwsIHJlc291cmNlUGF0aCwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcclxuICAgICAgICBhc3luYzogIWNvbnRleHQub3B0aW9ucy5zeW5jaHJvbm91cyxcclxuICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgc3VjY2Vzczogc3RvcmVUZW1wbGF0ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RvcmVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xyXG4gICAgICAgIGNvbnRleHQudGVtcGxhdGVzLnN0b3JlKHRlbXBsYXRlLCByZXNvdXJjZVBhdGgpO1xyXG4gICAgfVxyXG59O1xyXG5ULkxvYWRIYW5kbGVycy5odG1sID0gVC5Mb2FkSGFuZGxlcnMuaHRtO1xyXG5cblxuXG4vLyBMb2FkU3RyYXRlZ2llcy9hZGhvYy5qc1xuXG5ULkxvYWRTdHJhdGVnaWVzLmFkaG9jID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcclxuICAgIGlmIChjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdO1xyXG5cclxuICAgIHZhciBwYXRoID0gVC5QYXRoKGNvbnRleHQub3B0aW9ucy5iYXNlUGF0aCkuY29tYmluZShULlBhdGgocGFuZS5wYXRoKS5tYWtlUmVsYXRpdmUoKSk7XHJcblxyXG4gICAgaWYgKGNvbnRleHQudGVtcGxhdGVzLmxvYWRlZChwYW5lLnBhdGgpIHx8IGNvbnRleHQubW9kZWxzW3BhbmUucGF0aF0pXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIGRlZmVycmVkID0gJC5jb21wbGV0ZShbXHJcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdqcycpLnRvU3RyaW5nKCksIHBhbmUucGF0aCwgY29udGV4dCksXHJcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdodG0nKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpLFxyXG4gICAgICAgIGNvbnRleHQubG9hZGVyLmdldChwYXRoLnNldEV4dGVuc2lvbignY3NzJykudG9TdHJpbmcoKSwgcGFuZS5wYXRoLCBjb250ZXh0KVxyXG4gICAgXSk7XHJcblxyXG4gICAgY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdID0gZGVmZXJyZWQ7XHJcblxyXG4gICAgJC53aGVuKGRlZmVycmVkKVxyXG4gICAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBULmxvZ2dlci5lcnJvcihcIlVuYWJsZSB0byBsb2FkIHJlc291cmNlcyBmb3IgJ1wiICsgcGFuZS5wYXRoICsgXCInLlwiKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBkZWZlcnJlZDtcclxufTtcblxuXG4vLyBMb2FkU3RyYXRlZ2llcy9wcmVsb2FkZWQuanNcblxuVC5Mb2FkU3RyYXRlZ2llcy5wcmVsb2FkZWQgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xyXG4gICAgaWYgKCFjb250ZXh0Lm1vZGVsc1twYW5lLnBhdGhdICYmICFjb250ZXh0LnRlbXBsYXRlcy5sb2FkZWQocGFuZS5wYXRoKSkge1xyXG4gICAgICAgIFQubG9nZ2VyLmVycm9yKFwiTm8gcmVzb3VyY2VzIGxvYWRlZCBmb3IgJ1wiICsgcGFuZS5wYXRoICsgXCInLlwiKTtcclxuICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlamVjdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XG5cblxuLy8gVHJhbnNpdGlvbnMvdHJhbnNpdGlvbi5qc1xuXG5ULnRyYW5zaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCB0cmFuc2l0aW9uLCByZXZlcnNlKSB7XHJcbiAgICB2YXIgbm9kZTtcclxuICAgIHZhciBwYW5lO1xyXG4gICAgdmFyIGVsZW1lbnQ7XHJcbiAgICBzZXRTdGF0ZSgpO1xyXG4gICAgXHJcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCAocGFuZSAmJiBwYW5lLnRyYW5zaXRpb24pIHx8IChub2RlICYmIG5vZGUudHJhbnNpdGlvbik7XHJcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBULlRyYW5zaXRpb25zW3RyYW5zaXRpb25dO1xyXG4gICAgaWYgKHJldmVyc2UgJiYgaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ucmV2ZXJzZSlcclxuICAgICAgICBpbXBsZW1lbnRhdGlvbiA9IFQuVHJhbnNpdGlvbnNbaW1wbGVtZW50YXRpb24ucmV2ZXJzZV07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnaW4nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICQoZWxlbWVudCkuc2hvdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb25bJ2luJ10oZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBvdXQ6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbk1vZGUoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ub3V0KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAkLndoZW4ocHJvbWlzZSkuZG9uZShyZW1vdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmhpZGUoKS5hdHRyKCdzdHlsZScsICcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRvOiBmdW5jdGlvbiAocGFuZU9wdGlvbnMsIHJlbW92ZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IFQuY29udGV4dCgpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSlcclxuICAgICAgICAgICAgICAgIFQuVXRpbHMuaW5zZXJ0UGFuZUFmdGVyKG5vZGUsIGVsZW1lbnQsIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGFuZU9wdGlvbnMsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgcmV2ZXJzZVRyYW5zaXRpb25JbjogcmV2ZXJzZSB9KSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIFQuaW5zZXJ0Tm9kZUFmdGVyKGVsZW1lbnQsIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGFuZU9wdGlvbnMsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgcmV2ZXJzZVRyYW5zaXRpb25JbjogcmV2ZXJzZSB9KSwgbnVsbCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMub3V0KHJlbW92ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnJlbmRlck9wZXJhdGlvbi5wcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNldFRyYW5zaXRpb25Nb2RlKCkge1xyXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKFQudHJhbnNpdGlvbi5tb2RlID09PSAnZml4ZWQnKVxyXG4gICAgICAgICAgICAkZWxlbWVudC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJGVsZW1lbnQud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6ICRlbGVtZW50Lm9mZnNldCgpLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB0b3A6ICRlbGVtZW50Lm9mZnNldCgpLnRvcFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICRlbGVtZW50LmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAkZWxlbWVudC53aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogJGVsZW1lbnQucG9zaXRpb24oKS5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiAkZWxlbWVudC5wb3NpdGlvbigpLnRvcFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRhcmdldCkgdGhyb3cgXCJObyB0YXJnZXQgcGFzc2VkIHRvIFQudHJhbnNpdGlvblwiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0YXJnZXQuY29uc3RydWN0b3IgPT09IFQuVHlwZXMuTm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICBwYW5lID0gbm9kZS5wYW5lO1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gcGFuZS5lbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNvbnN0cnVjdG9yID09PSBULlR5cGVzLlBhbmUpIHtcclxuICAgICAgICAgICAgcGFuZSA9IHRhcmdldDtcclxuICAgICAgICAgICAgbm9kZSA9IHBhbmUubm9kZTtcclxuICAgICAgICAgICAgZWxlbWVudCA9IHBhbmUuZWxlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcbn07XG5cblxuLy8gVHJhbnNpdGlvbnMvQ3NzL2Nzcy5qc1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRzVHJhbnNpdGlvbnMoKTtcclxuICAgIFxyXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignZmFkZScpO1xyXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVMZWZ0JywgJ3NsaWRlUmlnaHQnKTtcclxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlUmlnaHQnLCAnc2xpZGVMZWZ0Jyk7XHJcbiAgICBjcmVhdGVDc3NUcmFuc2l0aW9uKCdzbGlkZVVwJywgJ3NsaWRlRG93bicpO1xyXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVEb3duJywgJ3NsaWRlVXAnKTtcclxuXHJcbiAgICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50cyA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25lbmQgbXNUcmFuc2l0aW9uRW5kJztcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDc3NUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHJldmVyc2UpIHtcclxuICAgICAgICBULlRyYW5zaXRpb25zW3RyYW5zaXRpb25dID0ge1xyXG4gICAgICAgICAgICAnaW4nOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYmluZCh0cmFuc2l0aW9uRW5kRXZlbnRzLCB0cmFuc2l0aW9uRW5kZWQoZWxlbWVudCwgcHJvbWlzZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdwcmVwYXJlIGluICcgKyB0cmFuc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBvdXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRlZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKCdwcmVwYXJlIG91dCAnICsgdHJhbnNpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAub24odHJhbnNpdGlvbkVuZEV2ZW50cywgdHJhbnNpdGlvbkVuZGVkKGVsZW1lbnQsIHByb21pc2UsIHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJldmVyc2U6IHJldmVyc2UgfHwgdHJhbnNpdGlvblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXIoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoJ3RyaWdnZXInKTtcclxuICAgICAgICAgICAgfSwgMzApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZGVkKGVsZW1lbnQsIHByb21pc2UsIGhpZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS51bmJpbmQodHJhbnNpdGlvbkVuZEV2ZW50cylcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModHJhbnNpdGlvbiArICcgaW4gb3V0IHByZXBhcmUgdHJpZ2dlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpZGUpICQoZWxlbWVudCkuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25zKCkge1xyXG4gICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gYi5zdHlsZTtcclxuICAgICAgICB2YXIgcHJvcGVydHkgPSAndHJhbnNpdGlvbic7XHJcbiAgICAgICAgdmFyIHZlbmRvcnMgPSBbJ01veicsICdXZWJraXQnLCAnS2h0bWwnLCAnTycsICdtcyddO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BlcnR5XSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICAgICAgICAvLyBUZXN0cyBmb3IgdmVuZG9yIHNwZWNpZmljIHByb3BcclxuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmVuZG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVt2ZW5kb3JzW2ldICsgcHJvcGVydHldID09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSkoKTtcclxuXG5cblxuLy8gVHJhbnNpdGlvbnMvQ3NzL3N0eWxlLmNzcy5qc1xuXG5cbi8vXG53aW5kb3cuX19hcHBlbmRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX190cmliZVN0eWxlcycpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnX190cmliZSc7XG4gICAgICAgIGVsZW1lbnQuaWQgPSAnX190cmliZVN0eWxlcyc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYoZWxlbWVudC5zdHlsZVNoZWV0KVxuICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCArPSBjb250ZW50O1xuICAgIGVsc2VcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XG59Oy8vXG53aW5kb3cuX19hcHBlbmRTdHlsZSgnLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAyNTBtcyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAyNTBtcyBlYXNlLWluLW91dH0uZmFkZS5pbi5wcmVwYXJle29wYWNpdHk6MH0uZmFkZS5pbi50cmlnZ2Vye29wYWNpdHk6MX0uZmFkZS5vdXQucHJlcGFyZXtvcGFjaXR5OjF9LmZhZGUub3V0LnRyaWdnZXJ7b3BhY2l0eTowfS5zbGlkZVJpZ2h0LmluLnByZXBhcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpfS5zbGlkZVJpZ2h0LmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0uc2xpZGVSaWdodC5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpfS5zbGlkZUxlZnQuaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpfS5zbGlkZUxlZnQuaW4udHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfS5zbGlkZUxlZnQub3V0LnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpfS5zbGlkZURvd24uaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwJSl9LnNsaWRlRG93bi5pbi50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9LnNsaWRlRG93bi5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpfS5zbGlkZVVwLmluLnByZXBhcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKX0uc2xpZGVVcC5pbi50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9LnNsaWRlVXAub3V0LnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwMCUpfScpO1xuXG5cbi8vIEFwaS9hcGkuanNcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFQucmVnaXN0ZXJNb2RlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhZGRSZXNvdXJjZSgnbW9kZWxzJywgVC5VdGlscy5hcmd1bWVudHMoYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFQucmVnaXN0ZXJTYWdhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFkZFJlc291cmNlKCdzYWdhcycsIFQuVXRpbHMuYXJndW1lbnRzKGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWRkUmVzb3VyY2UoY29udGV4dFByb3BlcnR5LCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGVudmlyb25tZW50ID0gVC5zY3JpcHRFbnZpcm9ubWVudCB8fCB7fTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGVudmlyb25tZW50LmNvbnRleHQgfHwgVC5jb250ZXh0KCk7XHJcblxyXG4gICAgICAgIHZhciBwYXRoID0gYXJncy5zdHJpbmcgfHwgZW52aXJvbm1lbnQucmVzb3VyY2VQYXRoO1xyXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZ3MuZnVuYztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub2JqZWN0O1xyXG5cclxuICAgICAgICBjb250ZXh0W2NvbnRleHRQcm9wZXJ0eV0ucmVnaXN0ZXIocGF0aCwgY29uc3RydWN0b3IsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIFQucnVuID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIFQub3B0aW9ucyA9ICQuZXh0ZW5kKFQub3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgVC5vcHRpb25zLnB1YnN1YiA9IFQub3B0aW9ucy5wdWJzdWIgfHwgbmV3IFRyaWJlLlB1YlN1Yih7IHN5bmM6IFQub3B0aW9ucy5zeW5jaHJvbm91cywgaGFuZGxlRXhjZXB0aW9uczogVC5vcHRpb25zLmhhbmRsZUV4Y2VwdGlvbnMgfSk7XHJcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncygpO1xyXG4gICAgfTtcclxufSkoKTsgXG5cblxuLy8gQXBpL2NvbnRleHQuanNcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdGF0aWNTdGF0ZTtcclxuXHJcbiAgICBULmNvbnRleHQgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgc3RhdGljU3RhdGUgPSBzdGF0aWNTdGF0ZSB8fCB7XHJcbiAgICAgICAgICAgIG1vZGVsczogbmV3IFQuVHlwZXMuUmVzb3VyY2VzKCksXHJcbiAgICAgICAgICAgIHNhZ2FzOiBuZXcgVC5UeXBlcy5SZXNvdXJjZXMoKSxcclxuICAgICAgICAgICAgbG9hZGVyOiBuZXcgVC5UeXBlcy5Mb2FkZXIoKSxcclxuICAgICAgICAgICAgb3B0aW9uczogVC5vcHRpb25zLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IG5ldyBULlR5cGVzLlRlbXBsYXRlcygpLFxyXG4gICAgICAgICAgICBsb2FkZWRQYW5lczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBwZXJDb250ZXh0U3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHJlbmRlck9wZXJhdGlvbjogbmV3IFQuVHlwZXMuT3BlcmF0aW9uKCksXHJcbiAgICAgICAgICAgIHB1YnN1YjogVC5vcHRpb25zLnB1YnN1YlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBzdGF0aWNTdGF0ZSwgcGVyQ29udGV4dFN0YXRlLCBzb3VyY2UpO1xyXG4gICAgfTtcclxufSkoKTtcclxuXG5cblxuLy8gQXBpL2RlZmF1bHRVcmxQcm92aWRlci5qc1xuXG5ULm9wdGlvbnMuZGVmYXVsdFVybFByb3ZpZGVyID0ge1xyXG4gICAgdXJsRGF0YUZyb206IGZ1bmN0aW9uKHBhbmVPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVPcHRpb25zICYmIHsgdXJsOiAnIycgKyAkLnBhcmFtKHBhbmVPcHRpb25zKSB9O1xyXG4gICAgfSxcclxuICAgIHBhbmVPcHRpb25zRnJvbTogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVybCAmJiBULlV0aWxzLmRlcGFyYW0odXJsLnN1YnN0cigxKSk7XHJcbiAgICB9XHJcbn07XG5cblxuLy8gQXBpL25vZGVzLmpzXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdXRpbHMgPSBULlV0aWxzO1xyXG5cclxuICAgIFQuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCkge1xyXG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlIHx8IFQubm9kZUZvcihlbGVtZW50KTtcclxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB1dGlscy5jb250ZXh0Rm9yKGVsZW1lbnQpIHx8IFQuY29udGV4dCgpO1xyXG5cclxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBULlR5cGVzLk5vZGUocGFyZW50Tm9kZSk7XHJcbiAgICAgICAgdXRpbHMuYmluZFBhbmUobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgVC5hcHBlbmROb2RlID0gZnVuY3Rpb24gKHRhcmdldCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoJzxkaXYvPicpLmFwcGVuZFRvKHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIFQuY3JlYXRlTm9kZShlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFQuaW5zZXJ0Tm9kZUFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoJzxkaXYvPicpLmluc2VydEFmdGVyKHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIFQuY3JlYXRlTm9kZShlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSB8fCBULm5vZGVGb3IodGFyZ2V0KSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFQubm9kZUZvciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Tm9kZShrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxuXG5cbi8vIEJpbmRpbmdIYW5kbGVycy9mb3JlYWNoUHJvcGVydHkuanNcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAga28uYmluZGluZ0hhbmRsZXJzLmZvcmVhY2hQcm9wZXJ0eSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmZvcmVhY2guaW5pdChlbGVtZW50LCBtYWtlQWNjZXNzb3IobWFwVG9BcnJheSh2YWx1ZUFjY2Vzc29yKCkpKSwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaC51cGRhdGUoZWxlbWVudCwgbWFrZUFjY2Vzc29yKG1hcFRvQXJyYXkodmFsdWVBY2Nlc3NvcigpKSksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG1ha2VBY2Nlc3Nvcihzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXBUb0FycmF5KHNvdXJjZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdCwgZXh0ZW5kIGl0IG9udG8gYSBuZXcgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgkLmV4dGVuZCh7ICRrZXk6IHByb3BlcnR5IH0sIHNvdXJjZVtwcm9wZXJ0eV0pKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59KSgpO1xyXG5cblxuXG4vLyBCaW5kaW5nSGFuZGxlcnMvbmF2aWdhdGUuanNcblxua28uYmluZGluZ0hhbmRsZXJzLm5hdmlnYXRlID0ge1xyXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IFQubm9kZUZvcihlbGVtZW50KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSBULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0ga28uYmluZGluZ0hhbmRsZXJzLnZhbGlkYXRlZENsaWNrIHx8IGtvLmJpbmRpbmdIYW5kbGVycy5jbGljaztcclxuICAgICAgICBoYW5kbGVyLmluaXQoZWxlbWVudCwgbmF2aWdhdGUsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5hdmlnYXRlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5uYXZpZ2F0ZShkYXRhLnZhbHVlLCBULlV0aWxzLmNsb25lRGF0YShkYXRhLmRhdGEpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cblxuLy8gQmluZGluZ0hhbmRsZXJzL25hdmlnYXRlQmFjay5qc1xuXG5rby5iaW5kaW5nSGFuZGxlcnMubmF2aWdhdGVCYWNrID0ge1xyXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IFQubm9kZUZvcihlbGVtZW50KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrLmluaXQoZWxlbWVudCwgbmF2aWdhdGVCYWNrLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBuYXZpZ2F0ZUJhY2soKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5hdmlnYXRlQmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxuXG4vLyBCaW5kaW5nSGFuZGxlcnMvcGFuZS5qc1xuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMucGFuZSA9IHsgaW5pdDogdXBkYXRlQmluZGluZyB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJpbmRpbmcoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xyXG4gICAgICAgIFQuY3JlYXRlTm9kZShlbGVtZW50LCBjb25zdHJ1Y3RQYW5lT3B0aW9ucygpLCBULlV0aWxzLmV4dHJhY3ROb2RlKGJpbmRpbmdDb250ZXh0KSwgVC5VdGlscy5leHRyYWN0Q29udGV4dChiaW5kaW5nQ29udGV4dCkpO1xyXG5cclxuICAgICAgICByZXR1cm4geyBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZSB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RQYW5lT3B0aW9ucygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpLCBhbGxCaW5kaW5nc0FjY2Vzc29yKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSkoKTtcclxuXG5cblxuLy8gQmluZGluZ0hhbmRsZXJzL3B1Ymxpc2guanNcblxua28uYmluZGluZ0hhbmRsZXJzLnB1Ymxpc2ggPSB7XHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xyXG4gICAgICAgIHZhciBwdWJzdWIgPSBULm5vZGVGb3IoZWxlbWVudCkucGFuZS5wdWJzdWI7XHJcbiAgICAgICAgaWYgKCFwdWJzdWIpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSBULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0ga28uYmluZGluZ0hhbmRsZXJzLnZhbGlkYXRlZENsaWNrIHx8IGtvLmJpbmRpbmdIYW5kbGVycy5jbGljaztcclxuICAgICAgICBoYW5kbGVyLmluaXQoZWxlbWVudCwgcHVibGlzaEFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwdWJsaXNoQWNjZXNzb3IoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwdWJzdWIucHVibGlzaChkYXRhLnZhbHVlLCBULlV0aWxzLmNsb25lRGF0YShkYXRhLmRhdGEpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG4iLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvaHViJyB9O1xudmFyIHB1YnN1YiA9IHJlcXVpcmUoJ3RyaWJlLnB1YnN1YicpLFxyXG4gICAgc29ja2V0O1xyXG5cclxudmFyIGh1YiA9IG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNvY2tldCA9IGlvLmNvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKGVudmVsb3BlKSB7XHJcbiAgICAgICAgICAgIGVudmVsb3BlLm9yaWdpbiA9ICdzZXJ2ZXInO1xyXG4gICAgICAgICAgICBwdWJzdWIucHVibGlzaChlbnZlbG9wZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHB1Ymxpc2g6IGZ1bmN0aW9uKGVudmVsb3BlKSB7XHJcbiAgICAgICAgaWYgKCFzb2NrZXQpIGh1Yi5jb25uZWN0KCk7XHJcblxyXG4gICAgICAgIGlmKGVudmVsb3BlLm9yaWdpbiAhPT0gJ3NlcnZlcicpXHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KCdtZXNzYWdlJywgZW52ZWxvcGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNzYWdlIGFja25vd2xlZGdlZCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgam9pbjogZnVuY3Rpb24oY2hhbm5lbCkge1xyXG4gICAgICAgIGlmICghc29ja2V0KSBodWIuY29ubmVjdCgpO1xyXG4gICAgICAgIHNvY2tldC5lbWl0KCdqb2luJywgY2hhbm5lbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0U2FnYTogZnVuY3Rpb24ocGF0aCwgaWQsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIXNvY2tldCkgaHViLmNvbm5lY3QoKTtcclxuICAgICAgICBzb2NrZXQuZW1pdCgnc3RhcnRTYWdhJywgeyBwYXRoOiBwYXRoLCBpZDogaWQsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9XHJcbn07IiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL2luZGV4JyB9O1xuLy8gY29tcG9zaXRlIGhhcyBhIGxvZ2dlciBwYWNrYWdlZCwgYnV0IHVzZSB0aGUgbm9kZSB2ZXJzaW9uIGFzIGl0IHdpbGwgbGlrZWx5IGdldCB1cGRhdGVkXHJcblQubG9nZ2VyID0gcmVxdWlyZSgndHJpYmUvbG9nZ2VyJyk7XHJcbnJlcXVpcmUoJy4vUHVic3ViLmV4dGVuc2lvbnMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgLy8gY2xpZW50XHJcbiAgICBodWI6IHJlcXVpcmUoJ3RyaWJlL2NsaWVudC9odWInKSxcclxuICAgIHNlcnZpY2VzOiByZXF1aXJlKCd0cmliZS9jbGllbnQvc2VydmljZXMnKSxcclxuXHJcbiAgICAvL2NvbW1vblxyXG4gICAgcHVic3ViOiByZXF1aXJlKCd0cmliZS5wdWJzdWInKSxcclxuICAgIHJlZ2lzdGVyOiByZXF1aXJlKCd0cmliZS9jbGllbnQvcmVnaXN0ZXInKVxyXG59OyIsIlQuc2NyaXB0RW52aXJvbm1lbnQgPSB7IHJlc291cmNlUGF0aDogJy9wdWJzdWIuZGVidWcnIH07XG5cbndpbmRvdy5ldmFsKFwiXFxuaWYgKHR5cGVvZiAoVHJpYmUpID09PSAndW5kZWZpbmVkJylcXG4gICAgVHJpYmUgPSB7fTtcXG5cXG5UcmliZS5QdWJTdWIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG5cXG4gICAgdGhpcy5vd25lciA9IHRoaXM7XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgIHRoaXMuc3luYyA9IG9wdGlvbignc3luYycpO1xcbiAgICAgXFxuICAgIHZhciBzdWJzY3JpYmVycyA9IG5ldyBUcmliZS5QdWJTdWIuU3Vic2NyaWJlckxpc3QoKTtcXG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzO1xcblxcbiAgICBmdW5jdGlvbiBwdWJsaXNoKGVudmVsb3BlKSB7XFxuICAgICAgICB2YXIgbWVzc2FnZVN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZ2V0KGVudmVsb3BlLnRvcGljKTtcXG4gICAgICAgIHZhciBzeW5jID0gZW52ZWxvcGUuc3luYyA9PT0gdHJ1ZSB8fCBzZWxmLnN5bmMgPT09IHRydWU7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1lc3NhZ2VTdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAoc3luYylcXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVN1YnNjcmliZXIobWVzc2FnZVN1YnNjcmliZXJzW2ldLmhhbmRsZXIpO1xcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTdWJzY3JpYmVyKHN1YnNjcmliZXIuaGFuZGxlcik7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSkobWVzc2FnZVN1YnNjcmliZXJzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlU3Vic2NyaWJlcihmdW5jKSB7XFxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbkhhbmRsZXIgPSBvcHRpb24oJ2V4Y2VwdGlvbkhhbmRsZXInKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZihvcHRpb24oJ2hhbmRsZUV4Y2VwdGlvbnMnKSAgJiYgZXhjZXB0aW9uSGFuZGxlcilcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoZW52ZWxvcGUuZGF0YSwgZW52ZWxvcGUpO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUsIGVudmVsb3BlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZnVuYyhlbnZlbG9wZS5kYXRhLCBlbnZlbG9wZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2goY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucHVibGlzaFN5bmMgPSBmdW5jdGlvbiAodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XFxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpO1xcbiAgICAgICAgZW52ZWxvcGUuc3luYyA9IHRydWU7XFxuICAgICAgICByZXR1cm4gcHVibGlzaChlbnZlbG9wZSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiB0b3BpY09yRW52ZWxvcGUgJiYgdG9waWNPckVudmVsb3BlLnRvcGljXFxuICAgICAgICAgICAgPyB0b3BpY09yRW52ZWxvcGVcXG4gICAgICAgICAgICA6IHsgdG9waWM6IHRvcGljT3JFbnZlbG9wZSwgZGF0YTogZGF0YSB9O1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRvcGljLCBmdW5jKSB7XFxuICAgICAgICBpZiAodHlwZW9mICh0b3BpYykgPT09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5hZGQodG9waWMsIGZ1bmMpO1xcbiAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNBcnJheSh0b3BpYykpXFxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh0b3BpYywgZnVuY3Rpb24odG9waWNOYW1lKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5hZGQodG9waWNOYW1lLCBmdW5jKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKHRvcGljLCBmdW5jdGlvbiAoaW5kaXZpZHVhbEZ1bmMsIHRvcGljTmFtZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljTmFtZSwgaW5kaXZpZHVhbEZ1bmMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRva2Vucykge1xcbiAgICAgICAgaWYgKFRyaWJlLlB1YlN1Yi51dGlscy5pc0FycmF5KHRva2VucykpIHtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN1YnNjcmliZXJzLnJlbW92ZSh0b2tlbnNbaV0pKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5yZW1vdmUodG9rZW5zKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jcmVhdGVMaWZldGltZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuTGlmZXRpbWUoc2VsZiwgc2VsZik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxJZCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuQ2hhbm5lbChzZWxmLCBjaGFubmVsSWQpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gb3B0aW9uKG5hbWUpIHtcXG4gICAgICAgIHJldHVybiAoc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSA/IHNlbGYub3B0aW9uc1tuYW1lXSA6IFRyaWJlLlB1YlN1Yi5vcHRpb25zW25hbWVdO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvUHViU3ViLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVHJpYmUuUHViU3ViLkNoYW5uZWwgPSBmdW5jdGlvbiAocHVic3ViLCBjaGFubmVsSWQpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICBwdWJzdWIgPSBwdWJzdWIuY3JlYXRlTGlmZXRpbWUoKTtcXG5cXG4gICAgdGhpcy5pZCA9IGNoYW5uZWxJZDtcXG4gICAgdGhpcy5vd25lciA9IHB1YnN1Yi5vd25lcjtcXG5cXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5wdWJsaXNoKGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnB1Ymxpc2hTeW5jID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5wdWJsaXNoU3luYyhjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbih0b3BpYywgZnVuYykge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGZpbHRlck1lc3NhZ2VzKGZ1bmMpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIuc3Vic2NyaWJlT25jZSh0b3BpYywgZmlsdGVyTWVzc2FnZXMoZnVuYykpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICByZXR1cm4gcHVic3ViLnVuc3Vic2NyaWJlKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIuZW5kKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5MaWZldGltZShzZWxmLCBzZWxmLm93bmVyKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XFxuICAgICAgICB2YXIgZW52ZWxvcGUgPSB0b3BpY09yRW52ZWxvcGUgJiYgdG9waWNPckVudmVsb3BlLnRvcGljXFxuICAgICAgICAgID8gdG9waWNPckVudmVsb3BlXFxuICAgICAgICAgIDogeyB0b3BpYzogdG9waWNPckVudmVsb3BlLCBkYXRhOiBkYXRhIH07XFxuICAgICAgICBlbnZlbG9wZS5jaGFubmVsSWQgPSBjaGFubmVsSWQ7XFxuICAgICAgICByZXR1cm4gZW52ZWxvcGU7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIGZpbHRlck1lc3NhZ2VzKGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBlbnZlbG9wZSkge1xcbiAgICAgICAgICAgIGlmIChlbnZlbG9wZS5jaGFubmVsSWQgPT09IGNoYW5uZWxJZClcXG4gICAgICAgICAgICAgICAgZnVuYyhkYXRhLCBlbnZlbG9wZSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvQ2hhbm5lbC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5MaWZldGltZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG93bmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHRva2VucyA9IFtdO1xcblxcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XFxuXFxuICAgIHRoaXMucHVibGlzaCA9IGZ1bmN0aW9uKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdWJsaXNoKHRvcGljT3JFbnZlbG9wZSwgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucHVibGlzaFN5bmMgPSBmdW5jdGlvbih0b3BpYywgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdWJsaXNoU3luYyh0b3BpYywgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9IHBhcmVudC5zdWJzY3JpYmUodG9waWMsIGZ1bmMpO1xcbiAgICAgICAgcmV0dXJuIHJlY29yZFRva2VuKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9IHBhcmVudC5zdWJzY3JpYmVPbmNlKHRvcGljLCBmdW5jKTtcXG4gICAgICAgIHJldHVybiByZWNvcmRUb2tlbih0b2tlbik7XFxuICAgIH07XFxuICAgIFxcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9rZW4pIHtcXG4gICAgICAgIC8vIHdlIHNob3VsZCByZWFsbHkgcmVtb3ZlIHRoZSB0b2tlbihzKSBmcm9tIG91ciB0b2tlbiBsaXN0LCBidXQgaXQgaGFzIHRyaXZpYWwgaW1wYWN0IGlmIHdlIGRvbid0XFxuICAgICAgICByZXR1cm4gcGFyZW50LnVuc3Vic2NyaWJlKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbElkKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5DaGFubmVsKHNlbGYsIGNoYW5uZWxJZCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gcGFyZW50LnVuc3Vic2NyaWJlKHRva2Vucyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkxpZmV0aW1lKHNlbGYsIHNlbGYub3duZXIpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gcmVjb3JkVG9rZW4odG9rZW4pIHtcXG4gICAgICAgIGlmIChUcmliZS5QdWJTdWIudXRpbHMuaXNBcnJheSh0b2tlbikpXFxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh0b2tlbik7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xcbiAgICAgICAgcmV0dXJuIHRva2VuO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvTGlmZXRpbWUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIub3B0aW9ucyA9IHtcXG4gICAgc3luYzogZmFsc2UsXFxuICAgIGhhbmRsZUV4Y2VwdGlvbnM6IHRydWUsXFxuICAgIGV4Y2VwdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGUsIGVudmVsb3BlKSB7XFxuICAgICAgICB0eXBlb2YoY29uc29sZSkgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUubG9nKFxcXCJFeGNlcHRpb24gb2NjdXJyZWQgaW4gc3Vic2NyaWJlciB0byAnXFxcIiArIGVudmVsb3BlLnRvcGljICsgXFxcIic6IFxcXCIgKyBlLm1lc3NhZ2UpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvb3B0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5TYWdhID0gZnVuY3Rpb24gKHB1YnN1YiwgZGVmaW5pdGlvbikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG5cXG4gICAgcHVic3ViID0gcHVic3ViLmNyZWF0ZUxpZmV0aW1lKCk7XFxuICAgIHRoaXMucHVic3ViID0gcHVic3ViO1xcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XFxuXFxuICAgIGNvbmZpZ3VyZVNhZ2EoKTtcXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVzIHx8IHt9O1xcblxcbiAgICAvLyB0aGlzIGlzIG5vdCBpZTw5IGNvbXBhdGlibGUgYW5kIGluY2x1ZGVzIG9uc3RhcnQgLyBvbmVuZFxcbiAgICB0aGlzLnRvcGljcyA9IE9iamVjdC5rZXlzKGhhbmRsZXJzKTtcXG5cXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChzdGFydERhdGEpIHtcXG4gICAgICAgIHV0aWxzLmVhY2goaGFuZGxlcnMsIHNlbGYuYWRkSGFuZGxlciwgc2VsZik7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25zdGFydCkgaGFuZGxlcnMub25zdGFydChzdGFydERhdGEsIHNlbGYpO1xcbiAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3RhcnRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgb25zdGFydERhdGEpIHtcXG4gICAgICAgIHNlbGYuY2hpbGRyZW4ucHVzaChuZXcgVHJpYmUuUHViU3ViLlNhZ2EocHVic3ViLCBjaGlsZClcXG4gICAgICAgICAgICAuc3RhcnQob25zdGFydERhdGEpKTtcXG4gICAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmpvaW4gPSBmdW5jdGlvbiAoZGF0YSwgb25qb2luRGF0YSkge1xcbiAgICAgICAgdXRpbHMuZWFjaChoYW5kbGVycywgc2VsZi5hZGRIYW5kbGVyLCBzZWxmKTtcXG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25qb2luKSBoYW5kbGVycy5vbmpvaW4ob25qb2luRGF0YSwgc2VsZik7XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbiAob25lbmREYXRhKSB7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25lbmQpIGhhbmRsZXJzLm9uZW5kKG9uZW5kRGF0YSwgc2VsZik7XFxuICAgICAgICBwdWJzdWIuZW5kKCk7XFxuICAgICAgICBzZWxmLmVuZENoaWxkcmVuKG9uZW5kRGF0YSk7XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgIFRyaWJlLlB1YlN1Yi51dGlscy5lYWNoKHNlbGYuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XFxuICAgICAgICAgICAgIGNoaWxkLmVuZChkYXRhKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjb25maWd1cmVTYWdhKCkge1xcbiAgICAgICAgaWYgKGRlZmluaXRpb24pXFxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uKHNlbGYpO1xcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgVHJpYmUuUHViU3ViLnV0aWxzLmNvcHlQcm9wZXJ0aWVzKGRlZmluaXRpb24sIHNlbGYsIFsnaGFuZGxlcycsICdlbmRzQ2hpbGRyZW5FeHBsaWNpdGx5J10pO1xcbiAgICB9XFxufTtcXG5cXG5UcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2EgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHRoaXMsIGRlZmluaXRpb24pLnN0YXJ0KGRhdGEpO1xcbn07XFxuXFxuVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2E7XFxuVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2E7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL1NhZ2EuY29yZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5TYWdhLnByb3RvdHlwZS5hZGRIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIHRvcGljKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgaWYgKHRvcGljICE9PSAnb25zdGFydCcgJiYgdG9waWMgIT09ICdvbmVuZCcgJiYgdG9waWMgIT09ICdvbmpvaW4nKVxcbiAgICAgICAgaWYgKCFoYW5kbGVyKVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgZW5kSGFuZGxlcigpKTtcXG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgbWVzc2FnZUhhbmRsZXJGb3IoaGFuZGxlcikpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgY2hpbGRIYW5kbGVyRm9yKGhhbmRsZXIpKTtcXG5cXG4gICAgZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJGb3IoaGFuZGxlcikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlRGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBpZiAoIXNlbGYuZW5kc0NoaWxkcmVuRXhwbGljaXRseSlcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDaGlsZHJlbihtZXNzYWdlRGF0YSk7XFxuICAgICAgICAgICAgaGFuZGxlcihtZXNzYWdlRGF0YSwgZW52ZWxvcGUsIHNlbGYpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjaGlsZEhhbmRsZXJGb3IoY2hpbGRIYW5kbGVycykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlRGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBzZWxmLnN0YXJ0Q2hpbGQoeyBoYW5kbGVzOiBjaGlsZEhhbmRsZXJzIH0sIG1lc3NhZ2VEYXRhKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZW5kSGFuZGxlcigpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEpIHtcXG4gICAgICAgICAgICBzZWxmLmVuZChtZXNzYWdlRGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxufTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvU2FnYS5oYW5kbGVycy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuc3Vic2NyaWJlT25jZSA9IGZ1bmN0aW9uICh0b3BpYywgaGFuZGxlcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG4gICAgdmFyIGxpZmV0aW1lID0gdGhpcy5jcmVhdGVMaWZldGltZSgpO1xcblxcbiAgICBpZiAodHlwZW9mICh0b3BpYykgPT09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgICAgcmV0dXJuIGxpZmV0aW1lLnN1YnNjcmliZSh0b3BpYywgd3JhcEhhbmRsZXIoaGFuZGxlcikpO1xcbiAgICBlbHNlIGlmICh1dGlscy5pc0FycmF5KHRvcGljKSlcXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUod3JhcFRvcGljQXJyYXkoKSk7XFxuICAgIGVsc2VcXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUod3JhcFRvcGljT2JqZWN0KCkpO1xcblxcbiAgICBmdW5jdGlvbiB3cmFwVG9waWNBcnJheSgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcXG4gICAgICAgIHV0aWxzLmVhY2godG9waWMsIGZ1bmN0aW9uKHRvcGljTmFtZSkge1xcbiAgICAgICAgICAgIHJlc3VsdFt0b3BpY05hbWVdID0gd3JhcEhhbmRsZXIoaGFuZGxlcik7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIHdyYXBUb3BpY09iamVjdCgpIHtcXG4gICAgICAgIHJldHVybiB1dGlscy5tYXAodG9waWMsIGZ1bmN0aW9uIChmdW5jLCB0b3BpY05hbWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gbGlmZXRpbWUuc3Vic2NyaWJlKHRvcGljTmFtZSwgd3JhcEhhbmRsZXIoZnVuYykpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gd3JhcEhhbmRsZXIoZnVuYykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIGxpZmV0aW1lLmVuZCgpO1xcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9zdWJzY3JpYmVPbmNlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVHJpYmUuUHViU3ViLlN1YnNjcmliZXJMaXN0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBzdWJzY3JpYmVycyA9IHt9O1xcbiAgICB2YXIgbGFzdFVpZCA9IC0xO1xcblxcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIChwdWJsaXNoZWRUb3BpYykge1xcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XFxuICAgICAgICBmb3IgKHZhciByZWdpc3RlcmVkVG9waWMgaW4gc3Vic2NyaWJlcnMpXFxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KHJlZ2lzdGVyZWRUb3BpYykgJiYgdG9waWNNYXRjaGVzKHB1Ymxpc2hlZFRvcGljLCByZWdpc3RlcmVkVG9waWMpKVxcbiAgICAgICAgICAgICAgICBtYXRjaGluZyA9IG1hdGNoaW5nLmNvbmNhdChzdWJzY3JpYmVyc1tyZWdpc3RlcmVkVG9waWNdKTtcXG4gICAgICAgIHJldHVybiBtYXRjaGluZztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiAodG9waWMsIGhhbmRsZXIpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9ICgrK2xhc3RVaWQpLnRvU3RyaW5nKCk7XFxuICAgICAgICBpZiAoIXN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KHRvcGljKSlcXG4gICAgICAgICAgICBzdWJzY3JpYmVyc1t0b3BpY10gPSBbXTtcXG4gICAgICAgIHN1YnNjcmliZXJzW3RvcGljXS5wdXNoKHsgdG9waWM6IHRvcGljLCBoYW5kbGVyOiBoYW5kbGVyLCB0b2tlbjogdG9rZW4gfSk7XFxuICAgICAgICByZXR1cm4gdG9rZW47XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24odG9rZW4pIHtcXG4gICAgICAgIGZvciAodmFyIG0gaW4gc3Vic2NyaWJlcnMpXFxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KG0pKVxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnNjcmliZXJzW21dLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1ttXVtpXS50b2tlbiA9PT0gdG9rZW4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1ttXS5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiB0b3BpY01hdGNoZXMocHVibGlzaGVkLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICBpZiAoc3Vic2NyaWJlciA9PT0gJyonKVxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgXFxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFxcXCJeXFxcIiArIHN1YnNjcmliZXJcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC4vZywgXFxcIlxcXFxcXFxcLlxcXCIpXFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwqL2csIFxcXCJbXlxcXFwuXSpcXFwiKSArIFxcXCIkXFxcIjtcXG4gICAgICAgIHJldHVybiBwdWJsaXNoZWQubWF0Y2goZXhwcmVzc2lvbik7XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9TdWJzY3JpYmVyTGlzdC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi51dGlscyA9IHt9O1xcbihmdW5jdGlvbih1dGlscykge1xcbiAgICB1dGlscy5pc0FycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XFxuICAgIH07XFxuXFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSB0YWtlbiBmcm9tIHRoZSB1bmRlcnNjb3JlIGxpYnJhcnksIGR1cGxpY2F0ZWQgdG8gYXZvaWQgZGVwZW5kZW5jeS4gTGljZW5zZSBhdCBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy5cXG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcXG4gICAgdmFyIG5hdGl2ZU1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XFxuICAgIHZhciBicmVha2VyID0ge307XFxuXFxuICAgIHV0aWxzLmVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XFxuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcXG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB1dGlscy5tYXAgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xcbiAgICAgICAgdXRpbHMuZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcXG4gICAgICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLmNvcHlQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcXG4gICAgICAgICAgICBpZihzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59KShUcmliZS5QdWJTdWIudXRpbHMpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi91dGlscy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpXFxuICAgIG1vZHVsZS5leHBvcnRzID0gbmV3IFRyaWJlLlB1YlN1YigpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9leHBvcnRzLmpzXCIpO1xuIiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL3JlZ2lzdGVyJyB9O1xubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzYWdhOiBULnJlZ2lzdGVyU2FnYSxcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgcmVnaXN0ZXIgYSBzdGF0aWMgaGFuZGxlciBvbiB0aGUgY2xpZW50ICh5ZXQpIVwiKTtcclxuICAgIH0sXHJcbiAgICBzZXJ2aWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IHJlZ2lzdGVyIGEgc2VydmljZSBvbiB0aGUgY2xpZW50IVwiKTtcclxuICAgIH1cclxufTsiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvc2VydmljZXMnIH07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGludm9rZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5nZXQoJ1NlcnZpY2VzJywgeyBuYW1lOiBuYW1lLCBhcmdzOiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSB9KVxyXG4gICAgICAgICAgICAgICAgLmZhaWwoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07IiwidmFyIGxldmVsID0gNDtcclxudmFyIGxldmVscyA9IHtcclxuICAgIGRlYnVnOiA0LFxyXG4gICAgaW5mbzogMyxcclxuICAgIHdhcm46IDIsXHJcbiAgICBlcnJvcjogMSxcclxuICAgIG5vbmU6IDBcclxufTtcclxuXHJcbnZhciBhcGkgPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNldExldmVsOiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcclxuICAgICAgICBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XHJcbiAgICAgICAgaWYgKGxldmVsID09PSB1bmRlZmluZWQpIGxldmVsID0gNDtcclxuICAgIH0sXHJcbiAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobGV2ZWwgPj0gNClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coKCdERUJVRzogJyArIG1lc3NhZ2UpKTtcclxuICAgIH0sXHJcbiAgICBpbmZvOiBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChsZXZlbCA+PSAzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKCdJTkZPOiAnICsgbWVzc2FnZSkpO1xyXG4gICAgfSxcclxuICAgIHdhcm46IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID49IDIpXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigoJ1dBUk46ICcgKyBtZXNzYWdlKSk7XHJcbiAgICB9LFxyXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvcikge1xyXG4gICAgICAgIGlmIChsZXZlbCA+PSAxKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCgnRVJST1I6ICcgKyBtZXNzYWdlICsgJ1xcbicpLCBhcGkuZXJyb3JEZXRhaWxzKGVycm9yKSk7XHJcbiAgICB9LFxyXG4gICAgZXJyb3JEZXRhaWxzOiBmdW5jdGlvbiAoZXgpIHtcclxuICAgICAgICBpZiAoIWV4KSByZXR1cm4gJyc7XHJcbiAgICAgICAgcmV0dXJuIChleC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSA/IGV4IDpcclxuICAgICAgICAgICAgKGV4LnN0YWNrIHx8ICcnKSArIChleC5pbm5lciA/ICdcXG5cXG4nICsgdGhpcy5lcnJvckRldGFpbHMoZXguaW5uZXIpIDogJ1xcbicpO1xyXG4gICAgfSxcclxuICAgIGxvZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuIiwiXG4vLyBQdWJTdWIuanNcblxuaWYgKHR5cGVvZiAoVHJpYmUpID09PSAndW5kZWZpbmVkJylcclxuICAgIFRyaWJlID0ge307XHJcblxyXG5UcmliZS5QdWJTdWIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHV0aWxzID0gVHJpYmUuUHViU3ViLnV0aWxzO1xyXG5cclxuICAgIHRoaXMub3duZXIgPSB0aGlzO1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMuc3luYyA9IG9wdGlvbignc3luYycpO1xyXG4gICAgIFxyXG4gICAgdmFyIHN1YnNjcmliZXJzID0gbmV3IFRyaWJlLlB1YlN1Yi5TdWJzY3JpYmVyTGlzdCgpO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzO1xyXG5cclxuICAgIGZ1bmN0aW9uIHB1Ymxpc2goZW52ZWxvcGUpIHtcclxuICAgICAgICB2YXIgbWVzc2FnZVN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZ2V0KGVudmVsb3BlLnRvcGljKTtcclxuICAgICAgICB2YXIgc3luYyA9IGVudmVsb3BlLnN5bmMgPT09IHRydWUgfHwgc2VsZi5zeW5jID09PSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1lc3NhZ2VTdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHN5bmMpXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlU3Vic2NyaWJlcihtZXNzYWdlU3Vic2NyaWJlcnNbaV0uaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTdWJzY3JpYmVyKHN1YnNjcmliZXIuaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KShtZXNzYWdlU3Vic2NyaWJlcnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlU3Vic2NyaWJlcihmdW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyID0gb3B0aW9uKCdleGNlcHRpb25IYW5kbGVyJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihvcHRpb24oJ2hhbmRsZUV4Y2VwdGlvbnMnKSAgJiYgZXhjZXB0aW9uSGFuZGxlcilcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyhlbnZlbG9wZS5kYXRhLCBlbnZlbG9wZSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlLCBlbnZlbG9wZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGZ1bmMoZW52ZWxvcGUuZGF0YSwgZW52ZWxvcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2goY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucHVibGlzaFN5bmMgPSBmdW5jdGlvbiAodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGVudmVsb3BlID0gY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKTtcclxuICAgICAgICBlbnZlbG9wZS5zeW5jID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gcHVibGlzaChlbnZlbG9wZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdG9waWNPckVudmVsb3BlICYmIHRvcGljT3JFbnZlbG9wZS50b3BpY1xyXG4gICAgICAgICAgICA/IHRvcGljT3JFbnZlbG9wZVxyXG4gICAgICAgICAgICA6IHsgdG9waWM6IHRvcGljT3JFbnZlbG9wZSwgZGF0YTogZGF0YSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRvcGljLCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodG9waWMpID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljLCBmdW5jKTtcclxuICAgICAgICBlbHNlIGlmICh1dGlscy5pc0FycmF5KHRvcGljKSlcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh0b3BpYywgZnVuY3Rpb24odG9waWNOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljTmFtZSwgZnVuYyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh0b3BpYywgZnVuY3Rpb24gKGluZGl2aWR1YWxGdW5jLCB0b3BpY05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5hZGQodG9waWNOYW1lLCBpbmRpdmlkdWFsRnVuYyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgICAgIGlmIChUcmliZS5QdWJTdWIudXRpbHMuaXNBcnJheSh0b2tlbnMpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzdWJzY3JpYmVycy5yZW1vdmUodG9rZW5zW2ldKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXJzLnJlbW92ZSh0b2tlbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZUxpZmV0aW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuTGlmZXRpbWUoc2VsZiwgc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxJZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkNoYW5uZWwoc2VsZiwgY2hhbm5lbElkKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG9wdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIChzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpID8gc2VsZi5vcHRpb25zW25hbWVdIDogVHJpYmUuUHViU3ViLm9wdGlvbnNbbmFtZV07XHJcbiAgICB9XHJcbn07XG5cblxuLy8gQ2hhbm5lbC5qc1xuXG5UcmliZS5QdWJTdWIuQ2hhbm5lbCA9IGZ1bmN0aW9uIChwdWJzdWIsIGNoYW5uZWxJZCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgcHVic3ViID0gcHVic3ViLmNyZWF0ZUxpZmV0aW1lKCk7XHJcblxyXG4gICAgdGhpcy5pZCA9IGNoYW5uZWxJZDtcclxuICAgIHRoaXMub3duZXIgPSBwdWJzdWIub3duZXI7XHJcblxyXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBwdWJzdWIucHVibGlzaChjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wdWJsaXNoU3luYyA9IGZ1bmN0aW9uICh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gcHVic3ViLnB1Ymxpc2hTeW5jKGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRvcGljLCBmdW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGZpbHRlck1lc3NhZ2VzKGZ1bmMpKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gcHVic3ViLnN1YnNjcmliZU9uY2UodG9waWMsIGZpbHRlck1lc3NhZ2VzKGZ1bmMpKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgIHJldHVybiBwdWJzdWIudW5zdWJzY3JpYmUodG9rZW4pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBwdWJzdWIuZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuTGlmZXRpbWUoc2VsZiwgc2VsZi5vd25lcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IHRvcGljT3JFbnZlbG9wZSAmJiB0b3BpY09yRW52ZWxvcGUudG9waWNcclxuICAgICAgICAgID8gdG9waWNPckVudmVsb3BlXHJcbiAgICAgICAgICA6IHsgdG9waWM6IHRvcGljT3JFbnZlbG9wZSwgZGF0YTogZGF0YSB9O1xyXG4gICAgICAgIGVudmVsb3BlLmNoYW5uZWxJZCA9IGNoYW5uZWxJZDtcclxuICAgICAgICByZXR1cm4gZW52ZWxvcGU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGZpbHRlck1lc3NhZ2VzKGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZW52ZWxvcGUpIHtcclxuICAgICAgICAgICAgaWYgKGVudmVsb3BlLmNoYW5uZWxJZCA9PT0gY2hhbm5lbElkKVxyXG4gICAgICAgICAgICAgICAgZnVuYyhkYXRhLCBlbnZlbG9wZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuXG4vLyBMaWZldGltZS5qc1xuXG5UcmliZS5QdWJTdWIuTGlmZXRpbWUgPSBmdW5jdGlvbiAocGFyZW50LCBvd25lcikge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHRva2VucyA9IFtdO1xyXG5cclxuICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuXHJcbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbih0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LnB1Ymxpc2godG9waWNPckVudmVsb3BlLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wdWJsaXNoU3luYyA9IGZ1bmN0aW9uKHRvcGljLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdWJsaXNoU3luYyh0b3BpYywgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcclxuICAgICAgICB2YXIgdG9rZW4gPSBwYXJlbnQuc3Vic2NyaWJlKHRvcGljLCBmdW5jKTtcclxuICAgICAgICByZXR1cm4gcmVjb3JkVG9rZW4odG9rZW4pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1YnNjcmliZU9uY2UgPSBmdW5jdGlvbih0b3BpYywgZnVuYykge1xyXG4gICAgICAgIHZhciB0b2tlbiA9IHBhcmVudC5zdWJzY3JpYmVPbmNlKHRvcGljLCBmdW5jKTtcclxuICAgICAgICByZXR1cm4gcmVjb3JkVG9rZW4odG9rZW4pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHJlYWxseSByZW1vdmUgdGhlIHRva2VuKHMpIGZyb20gb3VyIHRva2VuIGxpc3QsIGJ1dCBpdCBoYXMgdHJpdmlhbCBpbXBhY3QgaWYgd2UgZG9uJ3RcclxuICAgICAgICByZXR1cm4gcGFyZW50LnVuc3Vic2NyaWJlKHRva2VuKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbElkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuQ2hhbm5lbChzZWxmLCBjaGFubmVsSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQudW5zdWJzY3JpYmUodG9rZW5zKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jcmVhdGVMaWZldGltZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkxpZmV0aW1lKHNlbGYsIHNlbGYub3duZXIpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcmVjb3JkVG9rZW4odG9rZW4pIHtcclxuICAgICAgICBpZiAoVHJpYmUuUHViU3ViLnV0aWxzLmlzQXJyYXkodG9rZW4pKVxyXG4gICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KHRva2VuKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcbn07XG5cblxuLy8gb3B0aW9ucy5qc1xuXG5UcmliZS5QdWJTdWIub3B0aW9ucyA9IHtcclxuICAgIHN5bmM6IGZhbHNlLFxyXG4gICAgaGFuZGxlRXhjZXB0aW9uczogdHJ1ZSxcclxuICAgIGV4Y2VwdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGUsIGVudmVsb3BlKSB7XHJcbiAgICAgICAgdHlwZW9mKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmxvZyhcIkV4Y2VwdGlvbiBvY2N1cnJlZCBpbiBzdWJzY3JpYmVyIHRvICdcIiArIGVudmVsb3BlLnRvcGljICsgXCInOiBcIiArIGUubWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XG5cblxuLy8gU2FnYS5jb3JlLmpzXG5cblRyaWJlLlB1YlN1Yi5TYWdhID0gZnVuY3Rpb24gKHB1YnN1YiwgZGVmaW5pdGlvbikge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHV0aWxzID0gVHJpYmUuUHViU3ViLnV0aWxzO1xyXG5cclxuICAgIHB1YnN1YiA9IHB1YnN1Yi5jcmVhdGVMaWZldGltZSgpO1xyXG4gICAgdGhpcy5wdWJzdWIgPSBwdWJzdWI7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgY29uZmlndXJlU2FnYSgpO1xyXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVzIHx8IHt9O1xyXG5cclxuICAgIC8vIHRoaXMgaXMgbm90IGllPDkgY29tcGF0aWJsZSBhbmQgaW5jbHVkZXMgb25zdGFydCAvIG9uZW5kXHJcbiAgICB0aGlzLnRvcGljcyA9IE9iamVjdC5rZXlzKGhhbmRsZXJzKTtcclxuXHJcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0RGF0YSkge1xyXG4gICAgICAgIHV0aWxzLmVhY2goaGFuZGxlcnMsIHNlbGYuYWRkSGFuZGxlciwgc2VsZik7XHJcbiAgICAgICAgaWYgKGhhbmRsZXJzLm9uc3RhcnQpIGhhbmRsZXJzLm9uc3RhcnQoc3RhcnREYXRhLCBzZWxmKTtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdGFydENoaWxkID0gZnVuY3Rpb24gKGNoaWxkLCBvbnN0YXJ0RGF0YSkge1xyXG4gICAgICAgIHNlbGYuY2hpbGRyZW4ucHVzaChuZXcgVHJpYmUuUHViU3ViLlNhZ2EocHVic3ViLCBjaGlsZClcclxuICAgICAgICAgICAgLnN0YXJ0KG9uc3RhcnREYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuam9pbiA9IGZ1bmN0aW9uIChkYXRhLCBvbmpvaW5EYXRhKSB7XHJcbiAgICAgICAgdXRpbHMuZWFjaChoYW5kbGVycywgc2VsZi5hZGRIYW5kbGVyLCBzZWxmKTtcclxuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIGlmIChoYW5kbGVycy5vbmpvaW4pIGhhbmRsZXJzLm9uam9pbihvbmpvaW5EYXRhLCBzZWxmKTtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbiAob25lbmREYXRhKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXJzLm9uZW5kKSBoYW5kbGVycy5vbmVuZChvbmVuZERhdGEsIHNlbGYpO1xyXG4gICAgICAgIHB1YnN1Yi5lbmQoKTtcclxuICAgICAgICBzZWxmLmVuZENoaWxkcmVuKG9uZW5kRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZW5kQ2hpbGRyZW4gPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgVHJpYmUuUHViU3ViLnV0aWxzLmVhY2goc2VsZi5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgIGNoaWxkLmVuZChkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY29uZmlndXJlU2FnYSgpIHtcclxuICAgICAgICBpZiAoZGVmaW5pdGlvbilcclxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbihzZWxmKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgVHJpYmUuUHViU3ViLnV0aWxzLmNvcHlQcm9wZXJ0aWVzKGRlZmluaXRpb24sIHNlbGYsIFsnaGFuZGxlcycsICdlbmRzQ2hpbGRyZW5FeHBsaWNpdGx5J10pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJpYmUuUHViU3ViLlNhZ2Euc3RhcnRTYWdhID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLlNhZ2EodGhpcywgZGVmaW5pdGlvbikuc3RhcnQoZGF0YSk7XHJcbn07XHJcblxyXG5UcmliZS5QdWJTdWIucHJvdG90eXBlLnN0YXJ0U2FnYSA9IFRyaWJlLlB1YlN1Yi5TYWdhLnN0YXJ0U2FnYTtcclxuVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2E7XG5cblxuLy8gU2FnYS5oYW5kbGVycy5qc1xuXG5UcmliZS5QdWJTdWIuU2FnYS5wcm90b3R5cGUuYWRkSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCB0b3BpYykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGlmICh0b3BpYyAhPT0gJ29uc3RhcnQnICYmIHRvcGljICE9PSAnb25lbmQnICYmIHRvcGljICE9PSAnb25qb2luJylcclxuICAgICAgICBpZiAoIWhhbmRsZXIpXHJcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgZW5kSGFuZGxlcigpKTtcclxuICAgICAgICBlbHNlIGlmIChoYW5kbGVyLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcclxuICAgICAgICAgICAgdGhpcy5wdWJzdWIuc3Vic2NyaWJlKHRvcGljLCBtZXNzYWdlSGFuZGxlckZvcihoYW5kbGVyKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGNoaWxkSGFuZGxlckZvcihoYW5kbGVyKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJGb3IoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEsIGVudmVsb3BlKSB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5lbmRzQ2hpbGRyZW5FeHBsaWNpdGx5KVxyXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDaGlsZHJlbihtZXNzYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZURhdGEsIGVudmVsb3BlLCBzZWxmKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoaWxkSGFuZGxlckZvcihjaGlsZEhhbmRsZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlRGF0YSwgZW52ZWxvcGUpIHtcclxuICAgICAgICAgICAgc2VsZi5zdGFydENoaWxkKHsgaGFuZGxlczogY2hpbGRIYW5kbGVycyB9LCBtZXNzYWdlRGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmRIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEpIHtcclxuICAgICAgICAgICAgc2VsZi5lbmQobWVzc2FnZURhdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8vIHN1YnNjcmliZU9uY2UuanNcblxuVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24gKHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgdXRpbHMgPSBUcmliZS5QdWJTdWIudXRpbHM7XHJcbiAgICB2YXIgbGlmZXRpbWUgPSB0aGlzLmNyZWF0ZUxpZmV0aW1lKCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiAodG9waWMpID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUodG9waWMsIHdyYXBIYW5kbGVyKGhhbmRsZXIpKTtcclxuICAgIGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkodG9waWMpKVxyXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUod3JhcFRvcGljQXJyYXkoKSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGxpZmV0aW1lLnN1YnNjcmliZSh3cmFwVG9waWNPYmplY3QoKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gd3JhcFRvcGljQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHV0aWxzLmVhY2godG9waWMsIGZ1bmN0aW9uKHRvcGljTmFtZSkge1xyXG4gICAgICAgICAgICByZXN1bHRbdG9waWNOYW1lXSA9IHdyYXBIYW5kbGVyKGhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHdyYXBUb3BpY09iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMubWFwKHRvcGljLCBmdW5jdGlvbiAoZnVuYywgdG9waWNOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUodG9waWNOYW1lLCB3cmFwSGFuZGxlcihmdW5jKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd3JhcEhhbmRsZXIoZnVuYykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgbGlmZXRpbWUuZW5kKCk7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5cbi8vIFN1YnNjcmliZXJMaXN0LmpzXG5cblRyaWJlLlB1YlN1Yi5TdWJzY3JpYmVyTGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHN1YnNjcmliZXJzID0ge307XHJcbiAgICB2YXIgbGFzdFVpZCA9IC0xO1xyXG5cclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKHB1Ymxpc2hlZFRvcGljKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgcmVnaXN0ZXJlZFRvcGljIGluIHN1YnNjcmliZXJzKVxyXG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkocmVnaXN0ZXJlZFRvcGljKSAmJiB0b3BpY01hdGNoZXMocHVibGlzaGVkVG9waWMsIHJlZ2lzdGVyZWRUb3BpYykpXHJcbiAgICAgICAgICAgICAgICBtYXRjaGluZyA9IG1hdGNoaW5nLmNvbmNhdChzdWJzY3JpYmVyc1tyZWdpc3RlcmVkVG9waWNdKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHRva2VuID0gKCsrbGFzdFVpZCkudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoIXN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KHRvcGljKSlcclxuICAgICAgICAgICAgc3Vic2NyaWJlcnNbdG9waWNdID0gW107XHJcbiAgICAgICAgc3Vic2NyaWJlcnNbdG9waWNdLnB1c2goeyB0b3BpYzogdG9waWMsIGhhbmRsZXI6IGhhbmRsZXIsIHRva2VuOiB0b2tlbiB9KTtcclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICBmb3IgKHZhciBtIGluIHN1YnNjcmliZXJzKVxyXG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkobSkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnNjcmliZXJzW21dLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnNbbV1baV0udG9rZW4gPT09IHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzW21dLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB0b3BpY01hdGNoZXMocHVibGlzaGVkLCBzdWJzY3JpYmVyKSB7XHJcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgPT09ICcqJylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBcIl5cIiArIHN1YnNjcmliZXJcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgXCJbXlxcLl0qXCIpICsgXCIkXCI7XHJcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2hlZC5tYXRjaChleHByZXNzaW9uKTtcclxuICAgIH1cclxufTtcblxuXG4vLyB1dGlscy5qc1xuXG5UcmliZS5QdWJTdWIudXRpbHMgPSB7fTtcclxuKGZ1bmN0aW9uKHV0aWxzKSB7XHJcbiAgICB1dGlscy5pc0FycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgdGFrZW4gZnJvbSB0aGUgdW5kZXJzY29yZSBsaWJyYXJ5LCBkdXBsaWNhdGVkIHRvIGF2b2lkIGRlcGVuZGVuY3kuIExpY2Vuc2UgYXQgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcuXHJcbiAgICB2YXIgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xyXG4gICAgdmFyIG5hdGl2ZU1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XHJcbiAgICB2YXIgYnJlYWtlciA9IHt9O1xyXG5cclxuICAgIHV0aWxzLmVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XHJcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHV0aWxzLm1hcCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICAgICAgdXRpbHMuZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHV0aWxzLmNvcHlQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICBpZihzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoVHJpYmUuUHViU3ViLnV0aWxzKTtcclxuXG5cblxuLy8gZXhwb3J0cy5qc1xuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgVHJpYmUuUHViU3ViKCk7XG4iLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvcGFuZScgfTtcbi8vcGFuZSIsIlQuc2NyaXB0RW52aXJvbm1lbnQgPSB7IHJlc291cmNlUGF0aDogJy9yZXNvdXJjZScgfTtcbi8vcmVzb3VyY2UiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvc2NyaXB0JyB9O1xuLy9zY3JpcHQiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhY3RNZXRhZGF0YShzb3VyY2UpKTtcclxuICAgIH0sXHJcbiAgICBleHRyYWN0TWV0YWRhdGE6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gc291cmNlLFxyXG4gICAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgIHJlbW92ZU9ic2VydmFibGVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZU9ic2VydmFibGVzKCkge1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5vYnNlcnZhYmxlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBrby5pc09ic2VydmFibGUodGFyZ2V0W3Byb3BlcnR5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gdGFyZ2V0W3Byb3BlcnR5XSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLm9ic2VydmFibGVzLnB1c2gocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHNvdXJjZS50YXJnZXQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWV0YWRhdGEoc291cmNlLnRhcmdldCwgc291cmNlLm1ldGFkYXRhKTtcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfSxcclxuICAgIGFwcGx5TWV0YWRhdGE6IGZ1bmN0aW9uICh0YXJnZXQsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhKVxyXG4gICAgICAgICAgICByZXN0b3JlT2JzZXJ2YWJsZXMoKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXN0b3JlT2JzZXJ2YWJsZXMoKSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IG1ldGFkYXRhLm9ic2VydmFibGVzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9ic2VydmFibGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIHJlc3RvcmVQcm9wZXJ0eShvYnNlcnZhYmxlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXN0b3JlUHJvcGVydHkocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGNyZWF0ZU9ic2VydmFibGUodGFyZ2V0W3Byb3BlcnR5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgP1xyXG4gICAgICAgICAgICAgICAga28ub2JzZXJ2YWJsZUFycmF5KHZhbHVlKSA6XHJcbiAgICAgICAgICAgICAgICBrby5vYnNlcnZhYmxlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbiJdfQ==
