require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

window.eval("\nif (typeof (T) == 'undefined') T = {};\nT.Types = T.Types || {};\n\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/setup.js");


window.eval("\n(function () {\n    Tribe.PubSub.prototype.startSaga = function (id, path, data) {\n        if (path.charAt(0) !== '/')\n            path = '/' + path;\n\n        var saga = new Tribe.PubSub.Saga(this, sagaDefinition(path));\n\n        if (id) {\n            saga.id = id;\n            attachToHub(saga);\n            T.hub.startSaga(path, id, data);\n        }\n\n        return saga.start(data);\n    };\n\n    Tribe.PubSub.prototype.joinSaga = function (id, path, data) {\n        var deferred = $.Deferred();\n        var self = this;\n        $.when($.get('Data/' + id + '/' + id))\n            .done(function (data) {\n                var saga = new Tribe.PubSub.Saga(self, sagaDefinition(data.path));\n                saga.id = id;\n                saga.join(T.serializer.deserialize(data.data));\n                attachToHub(saga);\n                deferred.resolve(saga);\n            })\n            .fail(function (reason) {\n                if (reason.status === 404 && path) {\n                    var saga = self.startSaga(id, path, data);\n                    deferred.resolve(saga);\n                }\n                else deferred.reject(reason);\n\n            });\n        return deferred;\n    };\n\n    function sagaDefinition(path) {\n        return T.context().sagas[path].constructor;\n    }\n\n    // need to also be able to detach\n    function attachToHub(saga) {\n        T.hub.join(saga.id);\n        saga.pubsub.subscribe(saga.topics, function (message, envelope) {\n            envelope.sagaId = saga.id;\n            T.hub.publish(envelope);\n        });\n    }\n\n    Tribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.prototype.startSaga;\n    Tribe.PubSub.Lifetime.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;\n    Tribe.PubSub.Channel.prototype.startSaga = Tribe.PubSub.prototype.startSaga;\n    Tribe.PubSub.Channel.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;\n\n    Tribe.PubSub.Channel.prototype.connect = function (topics) {\n        var self = this;\n\n        T.hub.join(this.id);\n        this.subscribe(topics || '*', function(data, envelope) {\n            T.hub.publish(envelope);\n        });\n\n        var end = this.end;\n        this.end = function() {\n            T.hub.leave(self.channelId);\n            end();\n        };\n\n        return this;\n    };\n})();\n\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/PubSub.extensions.js");


window.eval("\nT.services = function (name) {\n    return {\n        invoke: function () {\n            return $.get('Services', { name: name, args: Array.prototype.splice.call(arguments, 0) })\n                .fail(function (response) {\n                    T.logger.error(response.responseText);\n                });\n        }\n    };\n};\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/services.js");


window.eval("\nT.Types.Hub = function (io, pubsub, options) {\n    var socket = io.connect(options.socketUrl);\n\n    socket.on('message', function (envelope) {\n        envelope.origin = 'server';\n        pubsub.publish(envelope);\n    });\n\n    this.publish = function(envelope) {\n        if (!socket)\n            throw 'Hub must be connected before calling publish';\n        if(envelope.origin !== 'server')\n            socket.emit('message', envelope, function () {\n                console.log('message acknowledged');\n            });\n    };\n\n    this.join = function(channel) {\n        socket.emit('join', channel);\n    };\n\n    this.startSaga = function(path, id, data) {\n        socket.emit('startSaga', { path: path, id: id, data: data });\n    };\n};\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/types/Hub.js");

},{}],2:[function(require,module,exports){
/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */


window.eval("\n(function () {\n    var level = 4;\n    var levels = {\n        debug: 4,\n        info: 3,\n        warn: 2,\n        error: 1,\n        none: 0\n    };\n\n    var api = {\n        setLevel: function (newLevel) {\n            level = levels[newLevel];\n            if (level === undefined) level = 4;\n        },\n        debug: function (message) {\n            if (level >= 4)\n                console.log(('DEBUG: ' + message));\n        },\n        info: function (message) {\n            if (level >= 3)\n                console.info(('INFO: ' + message));\n        },\n        warn: function (message) {\n            if (level >= 2)\n                console.warn(('WARN: ' + message));\n        },\n        error: function (message, error) {\n            if (level >= 1)\n                console.error(('ERROR: ' + message + '\\n'), api.errorDetails(error));\n        },\n        errorDetails: function (ex) {\n            if (!ex) return '';\n            return (ex.constructor === String) ? ex :\n                (ex.stack || '') + (ex.inner ? '\\n\\n' + this.errorDetails(ex.inner) : '\\n');\n        }\n    };\n    api.log = api.debug;\n    \n    if (typeof (exports) !== 'undefined' && typeof (module) !== 'undefined')\n        module.exports = api;\n    else {\n        if (typeof (T) === 'undefined')\n            T = {};\n        T.logger = api;\n    }\n})();\n\n\n//@ sourceURL=http://Tribe.Common/Source/logger.js");


window.eval("\n(function () {\n    // man... this cross-platform stuff sucks...\n    var ko;\n    if (typeof (window) !== 'undefined')\n        ko = window.ko;\n    if (typeof (require) !== 'undefined')\n        ko = require('knockout');\n\n    var api = {\n        serialize: function (source) {\n            return JSON.stringify(this.extractMetadata(source));\n        },\n        extractMetadata: function (source) {\n            var target = source,\n                metadata = {};\n            removeObservables();\n            return {\n                target: target,\n                metadata: metadata\n            };\n\n            function removeObservables() {\n                metadata.observables = [];\n                for (var property in target)\n                    if (target.hasOwnProperty(property) && ko.isObservable(target[property])) {\n                        target[property] = target[property]();\n                        metadata.observables.push(property);\n                    }\n\n            }\n        },\n        deserialize: function (source) {\n            source = JSON.parse(source);\n            if (source.target)\n                return this.applyMetadata(source.target, source.metadata);\n            return source;\n        },\n        applyMetadata: function (target, metadata) {\n            if (metadata)\n                restoreObservables();\n            return target;\n\n            function restoreObservables() {\n                var observables = metadata.observables;\n                for (var i = 0, l = observables.length; i < l; i++)\n                    restoreProperty(observables[i]);\n            }\n\n            function restoreProperty(property) {\n                target[property] = createObservable(target[property]);\n            }\n\n            function createObservable(value) {\n                return value.constructor === Array ?\n                    ko.observableArray(value) :\n                    ko.observable(value);\n            }\n        }\n    };\n\n    if (typeof (exports) !== 'undefined' && typeof (module) !== 'undefined')\n        module.exports = api;\n    else {\n        if (typeof (T) === 'undefined')\n            T = {};\n        T.serializer = api;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Common/Source/serializer.js");


window.eval("\nif (typeof (Tribe) === 'undefined')\n    Tribe = {};\n\nTribe.PubSub = function (options) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    this.owner = this;\n    this.options = options || {};\n    this.sync = option('sync');\n     \n    var subscribers = new Tribe.PubSub.SubscriberList();\n    this.subscribers = subscribers;\n\n    function publish(envelope) {\n        var messageSubscribers = subscribers.get(envelope.topic);\n        var sync = envelope.sync === true || self.sync === true;\n\n        for (var i = 0, l = messageSubscribers.length; i < l; i++) {\n            if (sync)\n                executeSubscriber(messageSubscribers[i].handler);\n            else {\n                (function (subscriber) {\n                    setTimeout(function () {\n                        executeSubscriber(subscriber.handler);\n                    });\n                })(messageSubscribers[i]);\n            }\n        }\n\n        function executeSubscriber(func) {\n            var exceptionHandler = option('exceptionHandler');\n            \n            if(option('handleExceptions')  && exceptionHandler)\n                try {\n                    func(envelope.data, envelope);\n                } catch (e) {\n                    exceptionHandler(e, envelope);\n                }\n            else\n                func(envelope.data, envelope);\n        }\n    }\n\n    this.publish = function (topicOrEnvelope, data) {\n        return publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        var envelope = createEnvelope(topicOrEnvelope, data);\n        envelope.sync = true;\n        return publish(envelope);\n    };\n    \n    function createEnvelope(topicOrEnvelope, data) {\n        return topicOrEnvelope && topicOrEnvelope.topic\n            ? topicOrEnvelope\n            : { topic: topicOrEnvelope, data: data };\n    }\n\n    this.subscribe = function (topic, func) {\n        if (typeof (topic) === \"string\")\n            return subscribers.add(topic, func);\n        else if (utils.isArray(topic))\n            return utils.map(topic, function(topicName) {\n                return subscribers.add(topicName, func);\n            });\n        else\n            return utils.map(topic, function (individualFunc, topicName) {\n                return subscribers.add(topicName, individualFunc);\n            });\n    };\n\n    this.unsubscribe = function (tokens) {\n        if (Tribe.PubSub.utils.isArray(tokens)) {\n            var results = [];\n            for (var i = 0, l = tokens.length; i < l; i++)\n                results.push(subscribers.remove(tokens[i]));\n            return results;\n        }\n\n        return subscribers.remove(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n    \n    function option(name) {\n        return (self.options.hasOwnProperty(name)) ? self.options[name] : Tribe.PubSub.options[name];\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/PubSub.js");


window.eval("\nTribe.PubSub.Channel = function (pubsub, channelId) {\n    var self = this;\n    pubsub = pubsub.createLifetime();\n\n    this.id = channelId;\n    this.owner = pubsub.owner;\n\n    this.publish = function (topicOrEnvelope, data) {\n        return pubsub.publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        return pubsub.publishSync(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.subscribe = function(topic, func) {\n        return pubsub.subscribe(topic, filterMessages(func));\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        return pubsub.subscribeOnce(topic, filterMessages(func));\n    };\n    \n    this.unsubscribe = function(token) {\n        return pubsub.unsubscribe(token);\n    };\n\n    this.end = function() {\n        return pubsub.end();\n    };\n\n    this.createLifetime = function () {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n\n    function createEnvelope(topicOrEnvelope, data) {\n        var envelope = topicOrEnvelope && topicOrEnvelope.topic\n          ? topicOrEnvelope\n          : { topic: topicOrEnvelope, data: data };\n        envelope.channelId = channelId;\n        return envelope;\n    }\n    \n    function filterMessages(func) {\n        return function(data, envelope) {\n            if (envelope.channelId === channelId)\n                func(data, envelope);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Channel.js");


window.eval("\nTribe.PubSub.Lifetime = function (parent, owner) {\n    var self = this;\n    var tokens = [];\n\n    this.owner = owner;\n\n    this.publish = function(topicOrEnvelope, data) {\n        return parent.publish(topicOrEnvelope, data);\n    };\n\n    this.publishSync = function(topic, data) {\n        return parent.publishSync(topic, data);\n    };\n\n    this.subscribe = function(topic, func) {\n        var token = parent.subscribe(topic, func);\n        return recordToken(token);\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        var token = parent.subscribeOnce(topic, func);\n        return recordToken(token);\n    };\n    \n    this.unsubscribe = function(token) {\n        // we should really remove the token(s) from our token list, but it has trivial impact if we don't\n        return parent.unsubscribe(token);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n\n    this.end = function() {\n        return parent.unsubscribe(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n    \n    function recordToken(token) {\n        if (Tribe.PubSub.utils.isArray(token))\n            tokens = tokens.concat(token);\n        else\n            tokens.push(token);\n        return token;\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Lifetime.js");


window.eval("\nTribe.PubSub.options = {\n    sync: false,\n    handleExceptions: true,\n    exceptionHandler: function(e, envelope) {\n        typeof(console) !== 'undefined' && console.log(\"Exception occurred in subscriber to '\" + envelope.topic + \"': \" + e.message);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/options.js");


window.eval("\nTribe.PubSub.Saga = function (pubsub, definition) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    pubsub = pubsub.createLifetime();\n    this.pubsub = pubsub;\n    this.children = [];\n\n    configureSaga();\n    var handlers = this.handles || {};\n\n    // this is not ie<9 compatible and includes onstart / onend\n    this.topics = Object.keys(handlers);\n\n    this.start = function (startData) {\n        utils.each(handlers, self.addHandler, self);\n        if (handlers.onstart) handlers.onstart(startData, self);\n        return self;\n    };\n\n    this.startChild = function (child, onstartData) {\n        self.children.push(new Tribe.PubSub.Saga(pubsub, child)\n            .start(onstartData));\n        return self;\n    };\n\n    this.join = function (data, onjoinData) {\n        utils.each(handlers, self.addHandler, self);\n        self.data = data;\n        if (handlers.onjoin) handlers.onjoin(onjoinData, self);\n        return self;\n    };\n\n    this.end = function (onendData) {\n        if (handlers.onend) handlers.onend(onendData, self);\n        pubsub.end();\n        self.endChildren(onendData);\n        return self;\n    };\n\n    this.endChildren = function(data) {\n        Tribe.PubSub.utils.each(self.children, function(child) {\n             child.end(data);\n        });\n    }\n    \n    function configureSaga() {\n        if (definition)\n            if (definition.constructor === Function)\n                definition(self);\n            else\n                Tribe.PubSub.utils.copyProperties(definition, self, ['handles', 'endsChildrenExplicitly']);\n    }\n};\n\nTribe.PubSub.Saga.startSaga = function (definition, data) {\n    return new Tribe.PubSub.Saga(this, definition).start(data);\n};\n\nTribe.PubSub.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\nTribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\n//@ sourceURL=http://Tribe.PubSub/Saga.core.js");


window.eval("\nTribe.PubSub.Saga.prototype.addHandler = function (handler, topic) {\n    var self = this;\n\n    if (topic !== 'onstart' && topic !== 'onend' && topic !== 'onjoin')\n        if (!handler)\n            this.pubsub.subscribe(topic, endHandler());\n        else if (handler.constructor === Function)\n            this.pubsub.subscribe(topic, messageHandlerFor(handler));\n        else\n            this.pubsub.subscribe(topic, childHandlerFor(handler));\n\n    function messageHandlerFor(handler) {\n        return function (messageData, envelope) {\n            if (!self.endsChildrenExplicitly)\n                self.endChildren(messageData);\n            handler(messageData, envelope, self);\n        };\n    }\n\n    function childHandlerFor(childHandlers) {\n        return function (messageData, envelope) {\n            self.startChild({ handles: childHandlers }, messageData);\n        };\n    }\n\n    function endHandler() {\n        return function (messageData) {\n            self.end(messageData);\n        };\n    }\n};\n\n//@ sourceURL=http://Tribe.PubSub/Saga.handlers.js");


window.eval("\nTribe.PubSub.prototype.subscribeOnce = function (topic, handler) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n    var lifetime = this.createLifetime();\n\n    if (typeof (topic) === \"string\")\n        return lifetime.subscribe(topic, wrapHandler(handler));\n    else if (utils.isArray(topic))\n        return lifetime.subscribe(wrapTopicArray());\n    else\n        return lifetime.subscribe(wrapTopicObject());\n\n    function wrapTopicArray() {\n        var result = {};\n        utils.each(topic, function(topicName) {\n            result[topicName] = wrapHandler(handler);\n        });\n        return result;\n    }\n    \n    function wrapTopicObject() {\n        return utils.map(topic, function (func, topicName) {\n            return lifetime.subscribe(topicName, wrapHandler(func));\n        });\n    }\n\n    function wrapHandler(func) {\n        return function() {\n            lifetime.end();\n            func.apply(self, arguments);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/subscribeOnce.js");


window.eval("\nTribe.PubSub.SubscriberList = function() {\n    var subscribers = {};\n    var lastUid = -1;\n\n    this.get = function (publishedTopic) {\n        var matching = [];\n        for (var registeredTopic in subscribers)\n            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))\n                matching = matching.concat(subscribers[registeredTopic]);\n        return matching;\n    };\n\n    this.add = function (topic, handler) {\n        var token = (++lastUid).toString();\n        if (!subscribers.hasOwnProperty(topic))\n            subscribers[topic] = [];\n        subscribers[topic].push({ topic: topic, handler: handler, token: token });\n        return token;\n    };\n\n    this.remove = function(token) {\n        for (var m in subscribers)\n            if (subscribers.hasOwnProperty(m))\n                for (var i = 0, l = subscribers[m].length; i < l; i++)\n                    if (subscribers[m][i].token === token) {\n                        subscribers[m].splice(i, 1);\n                        return token;\n                    }\n\n        return false;\n    };\n\n    function topicMatches(published, subscriber) {\n        if (subscriber === '*')\n            return true;\n        \n        var expression = \"^\" + subscriber\n            .replace(/\\./g, \"\\\\.\")\n            .replace(/\\*/g, \"[^\\.]*\") + \"$\";\n        return published.match(expression);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/SubscriberList.js");


window.eval("\nTribe.PubSub.utils = {};\n(function(utils) {\n    utils.isArray = function (source) {\n        return source.constructor === Array;\n    };\n\n    // The following functions are taken from the underscore library, duplicated to avoid dependency. License at http://underscorejs.org.\n    var nativeForEach = Array.prototype.forEach;\n    var nativeMap = Array.prototype.map;\n    var breaker = {};\n\n    utils.each = function (obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker) return;\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) return;\n                }\n            }\n        }\n    };\n\n    utils.map = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        utils.each(obj, function (value, index, list) {\n            results[results.length] = iterator.call(context, value, index, list);\n        });\n        return results;\n    };\n\n    utils.copyProperties = function (source, target, properties) {\n        for (var i = 0, l = properties.length; i < l; i++) {\n            var property = properties[i];\n            if(source.hasOwnProperty(property))\n                target[property] = source[property];\n        }\n    };\n})(Tribe.PubSub.utils);\n\n//@ sourceURL=http://Tribe.PubSub/utils.js");


window.eval("\nif (typeof(module) !== 'undefined')\n    module.exports = new Tribe.PubSub();\n//@ sourceURL=http://Tribe.PubSub/exports.js");


window.eval("\n(function (global) {\n    if (typeof (jQuery) === 'undefined')\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (typeof (ko) === 'undefined')\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n    if (typeof(T) === 'undefined')\n        throw 'Tribe.Common must be loaded before knockout.composite can initialise';\n\n    global.T = T || {};\n    global.T.Events = {};\n    global.T.Factories = {};\n    global.T.LoadHandlers = {};\n    global.T.LoadStrategies = {};\n    global.T.Transitions = {};\n    global.T.Types = {};\n    global.T.Utils = {};\n    global.T.logger = T.logger;\n    global.T.pubsub = new Tribe.PubSub();\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n    });\n})(window || this);\n\n//@ sourceURL=http://Tribe.Composite/setup.js");


window.eval("\nT.defaultOptions = function() {\n    return {\n        synchronous: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']\n    };\n};\nT.options = T.defaultOptions();\n\n//@ sourceURL=http://Tribe.Composite/options.js");


window.eval("\n(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/bindingHandlers.js");


window.eval("\n(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n\n    utils.pluck = function(array, property) {\n        return utils.map(array, function(value) {\n            return value && value[property];\n        });\n    };\n\n    utils.reduce = function (array, initialValue, reduceFunction) {\n        utils.each(array, function(value, index) {\n            initialValue = reduceFunction(initialValue, value, index, array);\n        });\n        return initialValue;\n    };\n})(T.Utils);\n\n//@ sourceURL=http://Tribe.Composite/Utilities/collections.js");


window.eval("\n// this is taken from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 \"Cowboy\" Ben Alman and also released under the MIT license\n\n// Deserialize a params string into an object, optionally coercing numbers,\n// booleans, null and undefined values; this method is the counterpart to the\n// internal jQuery.param method.\nT.Utils.deparam = function (params, coerce) {\n    var decode = decodeURIComponent;\n    var obj = {},\n      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    // Iterate over all name=value pairs.\n    $.each(params.replace(/\\+/g, ' ').split('&'), function (j, v) {\n        var param = v.split('='),\n          key = decode(param[0]),\n          val,\n          cur = obj,\n          i = 0,\n\n          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n          // into its component parts.\n          keys = key.split(']['),\n          keys_last = keys.length - 1;\n\n        // If the first keys part contains [ and the last ends with ], then []\n        // are correctly balanced.\n        if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n            // Remove the trailing ] from the last keys part.\n            keys[keys_last] = keys[keys_last].replace(/\\]$/, '');\n\n            // Split first keys part into two parts on the [ and add them back onto\n            // the beginning of the keys array.\n            keys = keys.shift().split('[').concat(keys);\n\n            keys_last = keys.length - 1;\n        } else {\n            // Basic 'foo' style key.\n            keys_last = 0;\n        }\n\n        // Are we dealing with a name=value pair, or just a name?\n        if (param.length === 2) {\n            val = decode(param[1]);\n\n            // Coerce values.\n            if (coerce) {\n                val = val && !isNaN(val) ? +val              // number\n                  : val === 'undefined' ? undefined         // undefined\n                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n                  : val;                                                // string\n            }\n\n            if (keys_last) {\n                // Complex key, build deep object structure based on a few rules:\n                // * The 'cur' pointer starts at the object top-level.\n                // * [] = array push (n is set to array length), [n] = array if n is \n                //   numeric, otherwise object.\n                // * If at the last keys part, set the value.\n                // * For each keys part, if the current level is undefined create an\n                //   object or array based on the type of the next keys part.\n                // * Move the 'cur' pointer to the next level.\n                // * Rinse & repeat.\n                for (; i <= keys_last; i++) {\n                    key = keys[i] === '' ? cur.length : keys[i];\n                    cur = cur[key] = i < keys_last\n                      ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])\n                      : val;\n                }\n\n            } else {\n                // Simple key, even simpler rules, since only scalars and shallow\n                // arrays are allowed.\n\n                if ($.isArray(obj[key])) {\n                    // val is already an array, so push on the next value.\n                    obj[key].push(val);\n\n                } else if (obj[key] !== undefined) {\n                    // val isn't an array, but since a second value has been specified,\n                    // convert val into an array.\n                    obj[key] = [obj[key], val];\n\n                } else {\n                    // val is a scalar.\n                    obj[key] = val;\n                }\n            }\n\n        } else if (key) {\n            // No value was defined, so set something meaningful.\n            obj[key] = coerce\n              ? undefined\n              : '';\n        }\n    });\n\n    return obj;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/deparam.js");


window.eval("\n(function() {\n    T.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    T.Utils.contextFor = function (element) {\n        return element && T.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    T.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');\n    };\n\n    T.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/embeddedContext.js");


window.eval("\n(function () {\n    T.Utils.elementDestroyed = function (element) {\n        if (element.constructor === jQuery)\n            element = element[0];\n\n        var promise = $.Deferred();\n\n        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n        $(element).on('destroyed', resolve);\n\n        // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n        $(document).on(\"DOMNodeRemoved\", matchElement);\n\n        function matchElement(event) {\n            if (event.target === element)\n                resolve();\n        }\n\n        function resolve() {\n            $(element).off('destroyed', resolve);\n            $(document).off('DOMNodeRemoved', matchElement);\n            promise.resolve();\n        }\n\n        return promise;\n    };\n\n    // this used to use DOM functions to raise events, but IE8 doesn't support custom events\n    // we'll use jQuery, but expose the originalEvent for DOM events and the jQuery event\n    // for custom events (originalEvent is null for custom events).\n    T.Utils.raiseDocumentEvent = function (name, eventData) {\n        var e = $.Event(name);\n        e.eventData = eventData;\n        $(document).trigger(e);\n    };\n\n    var handlers = {};\n\n    // if a handler is used for more than one event, a leak will occur\n    T.Utils.handleDocumentEvent = function (name, handler) {\n        $(document).on(name, internalHandler);\n        handlers[handler] = internalHandler;\n        \n        function internalHandler(e) {\n            handler(e.originalEvent || e);\n        }\n    };\n\n    T.Utils.detachDocumentEvent = function (name, handler) {\n        $(document).off(name, handlers[handler]);\n        delete handlers[handler];\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/events.js");


window.eval("\nT.Utils.tryCatch = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(this, args || []);\n        } catch (ex) {\n            T.logger.error(message, ex);\n        }\n    else\n        func.apply(this, args || []);\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/exceptions.js");


window.eval("\n(function () {\n    T.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = T.Utils.idGenerator();\n    T.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/idGenerator.js");


window.eval("\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\n        'use strict';\n        if (this == null) {\n            throw new TypeError();\n        }\n        var n, k, t = Object(this),\n            len = t.length >>> 0;\n\n        if (len === 0) {\n            return -1;\n        }\n        n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0) ; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    };\n}\n//@ sourceURL=http://Tribe.Composite/Utilities/indexOf.js");


window.eval("\n(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.complete.js");


window.eval("\n(function ($) {\n    var oldClean = jQuery.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})(jQuery);\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.destroyed.js");


window.eval("\nT.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/knockout.js");


window.eval("\nT.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        func: byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nT.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nT.Utils.inheritOptions = function (from, to, options) {\n    for (var i = 0, l = options.length; i < l; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nT.Utils.cloneData = function (from, except) {\n    if (!from) return;\n    var result = {};\n    for (var property in from) {\n        var value = from[property];\n        if (from.hasOwnProperty(property) &&\n            (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&\n            (!value || (value.constructor !== Function || ko.isObservable(value))))\n\n            result[property] = ko.utils.unwrapObservable(value);\n    }\n    return result;\n};\n\nT.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {\n    var data = allBindingsAccessor();\n    data.value = valueAccessor();\n    if (!ko.isObservable(data.value) && $.isFunction(data.value))\n        data.value = data.value();\n    return data;\n};\n\n\n//@ sourceURL=http://Tribe.Composite/Utilities/objects.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n\n    utils.bindPane = function (node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || T.context();\n        var pane = new T.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new T.Types.Pipeline(T.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    utils.insertPaneAfter = function (node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return utils.bindPane(node, element, paneOptions, context);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/panes.js");


window.eval("\n(function() {\n    T.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path.charAt(0) === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, '');\n            },\n            setExtension: function(extension) {\n                return Path(this.withoutExtension() + '.' + extension);\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/Path.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    T.Utils.Querystring.parse = function (source, seperator, eqSymbol) {\n        stripLeadIn();\n        \n        return T.Utils.reduce(\n            T.Utils.map(\n                source.split(seperator || \"&\"),\n                pieceParser(eqSymbol || \"=\")\n            ),\n            {},\n            mergeParams\n        );\n\n        function stripLeadIn() {\n            if(source.length > 0 && source.charAt(0) === '?')\n                source = source.substring(1);\n        }\n    };\n    \n    function unescape(s) {\n        return decodeURIComponent(s.replace(/\\+/g, ' '));\n    };\n\n    function pieceParser(eq) {\n        return function parsePiece(key, val) {\n\n            var sliced, numVal, head, tail, ret;\n\n            if (arguments.length === 2) {\n                // key=val, called from the map/reduce\n                key = key.split(eq);\n                return parsePiece(\n                    unescape(key.shift()),\n                    unescape(key.join(eq)),\n                    true\n                );\n            }\n            \n            key = key.replace(/^\\s+|\\s+$/g, '');\n            if (val.constructor === String) {\n                val = val.replace(/^\\s+|\\s+$/g, '');\n                // convert numerals to numbers\n                if (!isNaN(val)) {\n                    numVal = +val;\n                    if (val === numVal.toString(10)) {\n                        val = numVal;\n                    }\n                }\n            }\n            \n            sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n            if (!sliced) {\n                ret = {};\n                if (key)\n                    ret[key] = val;\n                return ret;\n            }\n            \n            // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n            tail = sliced[2];\n            head = sliced[1];\n\n            // array: key[]=val\n            if (!tail)\n                return parsePiece(head, [val], true);\n\n            // object: key[subkey]=val\n            ret = {};\n            ret[tail] = val;\n            return parsePiece(head, ret, true);\n        };\n    }\n\n    // the reducer function that merges each query piece together into one set of params\n    function mergeParams(params, addition) {\n        return (\n            // if it's uncontested, then just return the addition.\n            (!params) ? addition\n            // if the existing value is an array, then concat it.\n            : ($.isArray(params)) ? params.concat(addition)\n            // if the existing value is not an array, and either are not objects, arrayify it.\n            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)\n            // else merge them as objects, which is a little more complex\n            : mergeObjects(params, addition)\n        );\n    }\n\n    // Merge two *objects* together. If this is called, we've already ruled\n    // out the simple cases, and need to do the for-in business.\n    function mergeObjects(params, addition) {\n        for (var i in addition)\n            if (i && addition.hasOwnProperty(i))\n                params[i] = mergeParams(params[i], addition[i]);\n\n        return params;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.parse.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    var escape = encodeURIComponent;\n\n    T.Utils.Querystring.stringify = function (source, options) {\n        return stringify(source, options);\n    };\n\n    function stringify(source, options, name, stack) {\n        options = options || {};\n        stack = stack || [];\n        var begin, end, i, l, n, s;\n        var sep = options.seperator || \"&\";\n        var eq = options.eqSymbol || \"=\";\n        var arrayKey = options.arrayKey !== false;\n\n        if (source === null || source === undefined || source.constructor === Function)\n            return name ? escape(name) + eq : '';\n\n        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')\n            source = +source;\n\n        if (!isNaN(source) || source.constructor === String)\n            return escape(name) + eq + escape(source);\n\n        if ($.isArray(source)) {\n            s = [];\n            name = arrayKey ? name + '[]' : name;\n            for (i = 0, l = source.length; i < l; i++) {\n                s.push(stringify(source[i], options, name, stack));\n            }\n\n            return s.join(sep);\n        }\n        \n        // now we know it's an object.\n        // Check for cyclical references in nested objects\n        for (i = stack.length - 1; i >= 0; --i)\n            if (stack[i] === source)\n                throw new Error(\"T.Utils.Querystring.stringify: cyclical reference\");\n\n        stack.push(source);\n        s = [];\n        begin = name ? name + '[' : '';\n        end = name ? ']' : '';\n        for (i in source) {\n            if (source.hasOwnProperty(i)) {\n                n = begin + i + end;\n                s.push(stringify(source[i], options, n, stack));\n            }\n        }\n\n        stack.pop();\n        s = s.join(sep);\n        if (!s && name)\n            return name + \"=\";\n\n        return s;\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.stringify.js");


window.eval("\n(function () {\n    T.Types.Flow = function (navigationSource, definition) {\n        var self = this;\n\n        this.node = navigationNode();\n        this.pubsub = this.node.pane.pubsub.owner;\n        this.sagas = [];\n\n        definition = createDefinition(self, definition);\n        this.saga = new Tribe.PubSub.Saga(this.pubsub, definition);\n\n        this.start = function(data) {\n            self.saga.start(data);\n            return self;\n        };\n\n        this.end = function(data) {\n            self.saga.end(data);\n            T.Utils.each(self.sagas, function(saga) {\n                saga.end(data);\n            });\n            return self;\n        };\n\n        function navigationNode() {\n            if (navigationSource.constructor === T.Types.Node)\n                return navigationSource.findNavigation().node;\n            if (navigationSource.constructor === T.Types.Pane)\n                return navigationSource.node.findNavigation().node;\n            throw new Error(\"navigationSource must be either T.Types.Pane or T.Types.Node\");\n        }\n    };\n\n    T.Types.Flow.prototype.startChild = function(definition, data) {\n        definition = createDefinition(this, definition);\n        this.saga.startChild(definition, data);\n        return this;\n    };\n\n    T.Types.Flow.prototype.navigate = function (pathOrOptions, data) {\n        this.node.navigate(pathOrOptions, data);\n    };\n    \n    // This keeps a separate collection of sagas bound to this flow's lifetime\n    // It would be nice to make them children of the underlying saga, but\n    // then they would end any time a message was executed.\n    T.Types.Flow.prototype.startSaga = function (definition, data) {\n        var saga = this.pubsub.startSaga(definition, data);\n        this.sagas.push(saga);\n        return saga;\n    };\n\n    // flow helpers\n    T.Types.Flow.prototype.to = function (pathOrOptions, data) {\n        var node = this.node;\n        return function () {\n            node.navigate(pathOrOptions, data);\n        };\n    };\n\n    T.Types.Flow.prototype.endsAt = function (pathOrOptions, data) {\n        var flow = this;\n        return function () {\n            flow.node.navigate(pathOrOptions, data);\n            flow.end();\n        };\n    };\n\n    T.Types.Flow.prototype.start = function(flow, data) {\n        var thisFlow = this;\n        return function() {\n            thisFlow.startChild(flow, data);\n        };\n    };\n\n\n    // This is reused by Node and Pane\n    T.Types.Flow.startFlow = function (definition, data) {\n        return new T.Types.Flow(this, definition).start(data);\n    };\n    \n    function createDefinition(flow, definition) {\n        if (definition.constructor === Function)\n            definition = new definition(flow);\n        return definition;\n    }\n})();\n//@ sourceURL=http://Tribe.Composite/Types/Flow.js");


window.eval("\nT.Types.History = function (history) {\n    var currentState = 0;\n    history.replaceState(currentState, window.title);\n\n    var popActions = {\n        raiseEvent: function (e) {\n            T.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });\n            currentState = e.state;\n        },\n        updateStack: function(e) {\n            currentState = e.state;\n            currentAction = popActions.raiseEvent;\n        }\n    };\n    var currentAction = popActions.raiseEvent;\n\n    // this leaves IE7 & 8 high and dry. We'll probably require a polyfill and create a generic event subscription method\n    if(window.addEventListener)\n        window.addEventListener('popstate', executeCurrentAction);\n\n    function executeCurrentAction(e) {\n        if (e.state !== null) currentAction(e);\n    }\n\n    this.navigate = function (urlOptions) {\n        urlOptions = urlOptions || {};\n        history.pushState(++currentState, urlOptions.title, urlOptions.url);\n    };\n\n    this.go = function(frameCount) {\n        history.go(frameCount);\n    };\n\n    this.update = function(frameCount) {\n        currentAction = popActions.updateStack;\n        history.go(frameCount);\n    };\n\n    this.dispose = function () {\n        window.removeEventListener('popstate', executeCurrentAction);\n    };\n};\n\nif (window.history.pushState)\n    T.history = new T.Types.History(window.history);\nelse\n    T.history = new T.Types.History({\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { }\n    });\n//@ sourceURL=http://Tribe.Composite/Types/History.js");


window.eval("\nT.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = T.Path(url).extension().toString();\n        var handler = T.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        T.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//@ sourceURL=http://Tribe.Composite/Types/Loader.js");


window.eval("\nT.Types.Navigation = function (node, options) {\n    normaliseOptions();\n    setInitialPaneState();\n\n    var stack = [initialStackItem()];\n    var currentFrame = 0;\n\n    this.node = node;\n    this.stack = stack;\n\n    this.navigate = function (paneOptions) {\n        if (options.browser)\n            T.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));\n\n        trimStack();\n        stack.push(paneOptions);\n        currentFrame++;\n\n        navigateTo(paneOptions);\n    };\n\n    this.isAtStart = function() {\n        return currentFrame === 0;\n    };\n\n    this.go = function(frameCount) {\n        go(frameCount);\n        if (options.browser) T.history.update(frameCount);\n    };\n    \n    if(options.browser) T.Utils.handleDocumentEvent('browser.go', onBrowserGo);\n    function onBrowserGo(e) {\n        go(e.eventData.count);\n    }\n\n    function go(frameCount) {\n        var newFrame = currentFrame + frameCount;\n        if (newFrame < 0) newFrame = 0;\n        if (newFrame >= stack.length) newFrame = stack.length - 1;\n\n        if (newFrame != currentFrame)\n            navigateTo(stack[newFrame], frameCount < 0);\n\n        currentFrame = newFrame;\n    }\n\n    function navigateTo(paneOptions, reverse) {\n        T.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });\n        node.transitionTo(paneOptions, options.transition, reverse);\n    }\n\n    function trimStack() {\n        stack.splice(currentFrame + 1, stack.length);\n    }\n\n    this.dispose = function() {\n        T.Utils.detachDocumentEvent('browser.go', onBrowserGo);\n    };\n    \n    function normaliseOptions() {\n        options = options || {};\n        if (options.constructor === String)\n            options = { transition: options };\n        if (options.browser === true)\n            options.browser = T.options.defaultUrlProvider;\n    }\n    \n    function setInitialPaneState() {\n        var query = window.location.href.match(/\\#.*/);\n        if (query) query = query[0].substring(1);\n        var urlState = options.browser && options.browser.paneOptionsFrom(query);\n        if (urlState) {\n            node.pane.path = urlState.path;\n            node.pane.data = urlState.data;\n        }\n    }\n    \n    function initialStackItem() {\n        return { path: node.pane.path, data: node.pane.data };\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Types/Navigation.js");


window.eval("\nT.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n    this.id = T.Utils.getUniqueId();\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nT.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = T.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!T.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = T.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();\n    \n    this.findNavigation().navigate(paneOptions);\n};\n\nT.Types.Node.prototype.navigateBack = function () {\n    this.findNavigation().go(-1);\n};\n\nT.Types.Node.prototype.findNavigation = function() {\n    if (this.defaultNavigation)\n        return this.defaultNavigation;\n\n    else if (this.navigation)\n        return this.navigation;\n        \n    if (!this.parent) {\n        this.navigation = new T.Types.Navigation(this);\n        return this.navigation;\n    }\n\n    return this.parent.findNavigation();\n};\n\nT.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    T.transition(this, transition, reverse).to(paneOptions);\n};\n\nT.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.navigation = new T.Types.Navigation(this, pane.handlesNavigation);\n        \n        // this sets this pane as the \"default\", accessible from panes outside the tree. First in best dressed.\n        this.root.defaultNavigation = this.root.defaultNavigation || this.navigation;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nT.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nT.Types.Node.prototype.dispose = function() {\n    if (this.root.defaultNavigation === this.navigation)\n        this.root.defaultNavigation = null;\n\n    if (this.parent)\n        T.Utils.removeItem(this.parent.children, this);\n\n    if (this.pane && this.pane.dispose) {\n        delete this.pane.node;\n        this.pane.dispose();\n    }\n};\n\nT.Types.Node.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Node.js");


window.eval("\nT.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        T.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//@ sourceURL=http://Tribe.Composite/Types/Operation.js");


window.eval("\nT.Types.Pane = function (options) {\n    T.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };    \n};\n\nT.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nT.Types.Pane.prototype.navigateBack = function () {\n    this.node && this.node.navigateBack();\n};\n\nT.Types.Pane.prototype.remove = function () {\n    $(this.element).remove();\n};\n\nT.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        delete this.node.pane;\n        this.node.dispose();\n    }\n\n    if (this.element)\n        T.Utils.cleanElement(this.element);\n};\n\nT.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;    \n    var path = T.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = T.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nT.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nT.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nT.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nT.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n\nT.Types.Pane.prototype.startSaga = function(path, args) {\n    var saga = T.context().sagas[path];\n    this.pubsub.startSaga.apply(this.pubsub, [saga.constructor].concat(Array.prototype.slice.call(arguments, 1)));\n};\n\nT.Types.Pane.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Pane.js");


window.eval("\nT.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var thisEvent = events[eventName];\n\n            if (!thisEvent) {\n                T.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            $.when(thisEvent(target, context))\n                .done(executeNextEvent)\n                .fail(handleFailure);\n\n            function handleFailure() {\n                promise.reject();\n                var targetDescription = target ? target.toString() : \"empty target\";\n                T.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription);\n            }\n        }\n\n        return promise;\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Pipeline.js");


window.eval("\nT.Types.Resources = function () { };\n\nT.Types.Resources.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    T.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//@ sourceURL=http://Tribe.Composite/Types/Resources.js");


window.eval("\nT.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = T.Path(path).asMarkupIdentifier().toString();\n        embedTemplate(template, 'template-' + id);\n    };\n    \n    function embedTemplate(template, id) {\n        var element = document.createElement('script');\n        element.className = '__tribe';\n        element.setAttribute('type', 'text/template');\n        element.id = id;\n        element.text = template;\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n    \n    this.loaded = function(path) {\n        return $('head script#template-' + T.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = T.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Templates.js");


window.eval("\nT.Events.active = function (pane, context) {\n    return T.Utils.elementDestroyed(pane.element);\n};\n//@ sourceURL=http://Tribe.Composite/Events/active.js");


window.eval("\nT.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path];\n    var model = definition && definition.constructor ?\n        new definition.constructor(pane) :\n        { pane: pane, data: pane.data };\n\n    T.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n};\n//@ sourceURL=http://Tribe.Composite/Events/createModel.js");


window.eval("\nT.Events.createPubSub = function (pane, context) {\n    if (context.pubsub)\n        pane.pubsub = context.pubsub.createLifetime ?\n            context.pubsub.createLifetime() :\n            context.pubsub;\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/createPubSub.js");


window.eval("\nT.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/dispose.js");


window.eval("\nT.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/Events/initialiseModel.js");


window.eval("\nT.Events.loadResources = function (pane, context) {\n    var strategy = T.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//@ sourceURL=http://Tribe.Composite/Events/loadResources.js");


window.eval("\nT.Events.renderComplete = function (pane, context) {\n    $.when(\n        T.transition(pane, pane.transition, pane.reverseTransitionIn)['in']())\n     .done(executeRenderComplete);\n    \n    pane.endRender();\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        T.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new T.Types.Operation();\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderComplete.js");


window.eval("\nT.Events.renderPane = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    T.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n\n    function applyBindings() {\n        ko.applyBindingsToDescendants(pane.model, pane.element);\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderPane.js");


window.eval("\nT.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeScript\n    });\n\n    function executeScript(script) {\n        T.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        T.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete T.scriptEnvironment;\n\n        T.logger.debug('Loaded script from ' + url);\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//@ sourceURL=tribe://Application/' + url.replace(/ /g, \"_\");\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/scripts.js");


window.eval("\nT.LoadHandlers.css = function (url, resourcePath, context) {\n    var supportsTextNodes = true;\n    \n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        var element = document.getElementById('__tribeStyles');\n        if (!element) {\n            element = document.createElement('style');\n            element.className = '__tribe';\n            element.id = '__tribeStyles';\n            document.getElementsByTagName('head')[0].appendChild(element);\n        }\n\n        if(supportsTextNodes)\n            try {\n                element.appendChild(document.createTextNode(stylesheet));\n            } catch(ex) {\n                supportsTextNodes = false;\n            }\n\n        if (!supportsTextNodes)\n            if (element.styleSheet) {\n                // using styleSheet.cssText is required for IE8 support\n                // IE8 also has a limit on the number of <style/> elements, so append it to the same node\n                element.styleSheet.cssText += stylesheet;\n            } else throw new Error('Unable to append stylesheet for ' + resourcePath + ' to document.');\n    }\n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/stylesheets.js");


window.eval("\nT.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nT.LoadHandlers.html = T.LoadHandlers.htm;\n\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/templates.js");


window.eval("\nT.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = T.Path(context.options.basePath).combine(T.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            T.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/adhoc.js");


window.eval("\nT.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        T.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/preloaded.js");


window.eval("\nT.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n    \n    transition = transition || (pane && pane.transition) || (node && node.transition);\n    var implementation = T.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = T.Transitions[implementation.reverse];\n\n    return {\n        'in': function () {\n            $(element).show();\n            return implementation && implementation['in'](element);\n        },\n        \n        out: function (remove) {\n            setTransitionMode();\n            \n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n            \n            function removeElement() {\n                if (remove === false) {\n                    $(element).hide().attr('style', '');\n                } else\n                    $(element).remove();\n            }\n        },\n        \n        to: function (paneOptions, remove) {\n            var context = T.context();\n            if (node)\n                T.Utils.insertPaneAfter(node, element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                T.insertNodeAfter(element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove);\n            return context.renderOperation.promise;\n        }\n    };\n    \n    function setTransitionMode() {\n        var $element = $(element);\n        if (T.transition.mode === 'fixed')\n            $element.css({\n                position: 'fixed',\n                width: $element.width(),\n                left: $element.offset().left,\n                top: $element.offset().top\n            });\n        else\n            $element.css({\n                position: 'absolute',\n                width: $element.width(),\n                left: $element.position().left,\n                top: $element.position().top\n            });\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to T.transition\";\n        \n        if (target.constructor === T.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === T.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/Transitions/transition.js");


window.eval("\n(function () {\n    var supported = supportsTransitions();\n    \n    createCssTransition('fade');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n\n    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';\n\n    function createCssTransition(transition, reverse) {\n        T.Transitions[transition] = {\n            'in': function (element) {\n                if (!supported) return null;\n                \n                var promise = $.Deferred();\n                $(element).bind(transitionEndEvents, transitionEnded(element, promise))\n                    .addClass('prepare in ' + transition);\n\n                trigger(element);\n                return promise;\n            },\n\n            out: function (element) {\n                if (!supported) return null;\n                var promise = $.Deferred();\n\n                $(element).addClass('prepare out ' + transition)\n                    .on(transitionEndEvents, transitionEnded(element, promise, true));\n\n                trigger(element);\n                return promise;\n            },\n            reverse: reverse || transition\n        };\n\n        function trigger(element) {\n            setTimeout(function () {\n                $(element).addClass('trigger');\n            }, 30);\n        }\n\n        function transitionEnded(element, promise, hide) {\n            return function() {\n                $(element).unbind(transitionEndEvents)\n                    .removeClass(transition + ' in out prepare trigger');\n                if (hide) $(element).hide();\n                promise.resolve();\n            };\n        }\n    }\n    \n    function supportsTransitions() {\n        var b = document.body || document.documentElement;\n        var style = b.style;\n        var property = 'transition';\n        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n        if (typeof style[property] == 'string') { return true; }\n\n        // Tests for vendor specific prop\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        for (var i = 0, l = vendors.length; i < l; i++) {\n            if (typeof style[vendors[i] + property] == 'string') { return true; }\n        }\n        \n        return false;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/css.js");


window.eval("\n\n//\nwindow.__appendStyle = function (content) {\n    var element = document.getElementById('__tribeStyles');\n    if (!element) {\n        element = document.createElement('style');\n        element.className = '__tribe';\n        element.id = '__tribeStyles';\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n\n    if(element.styleSheet)\n        element.styleSheet.cssText += content;\n    else\n        element.appendChild(document.createTextNode(content));\n};//\nwindow.__appendStyle('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}');\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/style.css.js");


window.eval("\n(function () {\n    T.registerModel = function () {\n        addResource('models', T.Utils.arguments(arguments));\n    };\n\n    T.registerSaga = function () {\n        addResource('sagas', T.Utils.arguments(arguments));\n    };\n    \n    function addResource(contextProperty, args) {\n        var environment = T.scriptEnvironment || {};\n        var context = environment.context || T.context();\n\n        var path = args.string || environment.resourcePath;\n        var constructor = args.func;\n        var options = args.object;\n\n        context[contextProperty].register(path, constructor, options);\n    }\n\n    T.run = function(options) {\n        T.options = $.extend(T.options, options);\n        T.options.pubsub = T.options.pubsub || new Tribe.PubSub({ sync: T.options.synchronous, handleExceptions: T.options.handleExceptions });\n        ko.applyBindings();\n        //if (preload) {\n        //    var promises = [];\n        //    var context = T.context();\n\n        //    if ($.isArray(preload))\n        //        for (var i = 0, l = preload.length; i < l; i++)\n        //            addPromise(preload[i]);\n        //    else if(preload.constructor === String)\n        //        addPromise(preload);\n            \n        //    function addPromise(path) {\n        //        promises.push(context.loader.get(T.Path(context.options.basePath).combine(path).toString(), null, context));\n        //    }\n\n        //    return $.when.apply(null, promises).done(function () {\n        //        ko.applyBindings(model);\n        //    });\n        //} else\n        //    ko.applyBindings(model);\n    };\n})(); \n//@ sourceURL=http://Tribe.Composite/Api/api.js");


window.eval("\n(function () {\n    var staticState;\n\n    T.context = function (source) {\n        staticState = staticState || {\n            models: new T.Types.Resources(),\n            sagas: new T.Types.Resources(),\n            loader: new T.Types.Loader(),\n            options: T.options,\n            templates: new T.Types.Templates(),\n            loadedPanes: {}\n        };\n        var perContextState = {\n            renderOperation: new T.Types.Operation(),\n            pubsub: T.options.pubsub\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/context.js");


window.eval("\nT.options.defaultUrlProvider = {\n    urlDataFrom: function(paneOptions) {\n        return paneOptions && { url: '#' + $.param(paneOptions) };\n    },\n    paneOptionsFrom: function(url) {\n        return url && T.Utils.deparam(url.substr(1));\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Api/defaultUrlProvider.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    T.createNode = function (element, paneOptions, parentNode, context) {\n        parentNode = parentNode || T.nodeFor(element);\n        context = context || utils.contextFor(element) || T.context();\n\n        var node = new T.Types.Node(parentNode);\n        utils.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    T.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return T.createNode(element, paneOptions, parentNode, context);\n    };\n\n    T.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return T.createNode(element, paneOptions, parentNode || T.nodeFor(target), context);\n    };\n\n    T.nodeFor = function (element) {\n        return element && T.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/nodes.js");


window.eval("\n(function() {\n    ko.bindingHandlers.foreachProperty = {\n        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.init(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        },\n        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.update(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        }\n    };\n    \n    function makeAccessor(source) {\n        return function() {\n            return source;\n        };\n    }\n\n    function mapToArray(source) {\n        var result = [];\n        for (var property in source)\n            if (source.hasOwnProperty(property))\n                // we don't want to modify the original object, extend it onto a new object\n                result.push($.extend({ $key: property }, source[property]));\n        return result;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/foreachProperty.js");


window.eval("\nko.bindingHandlers.navigate = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, navigate, allBindingsAccessor, viewModel);\n\n        function navigate() {\n            return function () {\n                node.navigate(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigate.js");


window.eval("\nko.bindingHandlers.navigateBack = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);\n\n        function navigateBack() {\n            return function () {\n                node.navigateBack();\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigateBack.js");


window.eval("\n(function() {\n    ko.bindingHandlers.pane = { init: updateBinding };\n\n    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        T.createNode(element, constructPaneOptions(), T.Utils.extractNode(bindingContext), T.Utils.extractContext(bindingContext));\n\n        return { controlsDescendantBindings: true };\n\n        function constructPaneOptions() {\n            return T.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/pane.js");


window.eval("\nko.bindingHandlers.publish = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var pubsub = T.nodeFor(element).pane.pubsub;\n        if (!pubsub) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, publishAccessor, allBindingsAccessor, viewModel);\n\n        function publishAccessor() {\n            return function () {\n                pubsub.publish(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/publish.js");

},{}],"2OrlGQ":[function(require,module,exports){
module.exports = {
    saga: T.registerSaga,
    handler: function () {
        throw new Error("You can't register a static handler on the client (yet)!");
    },
    service: function () {
        throw new Error("You can't register a service on the client!");
    }
};
},{}],"tribe/register":[function(require,module,exports){
module.exports=require('2OrlGQ');
},{}],5:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/pane' };
//pane
},{}],6:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/resource' };
//resource
},{}],7:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/script' };
//script
},{}]},{},[2,1,5,6,7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcUHJvamVjdHNcXFRyaWJlXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9idWlsZC9UcmliZS5Ob2RlLkNsaWVudC5kZWJ1Zy5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9idWlsZC9UcmliZS5kZWJ1Zy5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL3JlZ2lzdGVyLmNsaWVudC5qcyIsImM6L1Byb2plY3RzL1RyaWJlL05vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL3Rlc3RzL2ZpbGVzL2J1aWxkL3BhbmVzL3BhbmUuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS90ZXN0cy9maWxlcy9idWlsZC9yZXNvdXJjZXMvcmVzb3VyY2UuanMiLCJjOi9Qcm9qZWN0cy9UcmliZS9Ob2RlL25vZGVfbW9kdWxlcy90cmliZS90ZXN0cy9maWxlcy9idWlsZC9zY3JpcHRzL3NjcmlwdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG53aW5kb3cuZXZhbChcIlxcbmlmICh0eXBlb2YgKFQpID09ICd1bmRlZmluZWQnKSBUID0ge307XFxuVC5UeXBlcyA9IFQuVHlwZXMgfHwge307XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L3NldHVwLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBmdW5jdGlvbiAoaWQsIHBhdGgsIGRhdGEpIHtcXG4gICAgICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gJy8nKVxcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xcblxcbiAgICAgICAgdmFyIHNhZ2EgPSBuZXcgVHJpYmUuUHViU3ViLlNhZ2EodGhpcywgc2FnYURlZmluaXRpb24ocGF0aCkpO1xcblxcbiAgICAgICAgaWYgKGlkKSB7XFxuICAgICAgICAgICAgc2FnYS5pZCA9IGlkO1xcbiAgICAgICAgICAgIGF0dGFjaFRvSHViKHNhZ2EpO1xcbiAgICAgICAgICAgIFQuaHViLnN0YXJ0U2FnYShwYXRoLCBpZCwgZGF0YSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gc2FnYS5zdGFydChkYXRhKTtcXG4gICAgfTtcXG5cXG4gICAgVHJpYmUuUHViU3ViLnByb3RvdHlwZS5qb2luU2FnYSA9IGZ1bmN0aW9uIChpZCwgcGF0aCwgZGF0YSkge1xcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICAgICAgJC53aGVuKCQuZ2V0KCdEYXRhLycgKyBpZCArICcvJyArIGlkKSlcXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgICB2YXIgc2FnYSA9IG5ldyBUcmliZS5QdWJTdWIuU2FnYShzZWxmLCBzYWdhRGVmaW5pdGlvbihkYXRhLnBhdGgpKTtcXG4gICAgICAgICAgICAgICAgc2FnYS5pZCA9IGlkO1xcbiAgICAgICAgICAgICAgICBzYWdhLmpvaW4oVC5zZXJpYWxpemVyLmRlc2VyaWFsaXplKGRhdGEuZGF0YSkpO1xcbiAgICAgICAgICAgICAgICBhdHRhY2hUb0h1YihzYWdhKTtcXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzYWdhKTtcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChyZWFzb24pIHtcXG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5zdGF0dXMgPT09IDQwNCAmJiBwYXRoKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2FnYSA9IHNlbGYuc3RhcnRTYWdhKGlkLCBwYXRoLCBkYXRhKTtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2FnYSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcXG5cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gc2FnYURlZmluaXRpb24ocGF0aCkge1xcbiAgICAgICAgcmV0dXJuIFQuY29udGV4dCgpLnNhZ2FzW3BhdGhdLmNvbnN0cnVjdG9yO1xcbiAgICB9XFxuXFxuICAgIC8vIG5lZWQgdG8gYWxzbyBiZSBhYmxlIHRvIGRldGFjaFxcbiAgICBmdW5jdGlvbiBhdHRhY2hUb0h1YihzYWdhKSB7XFxuICAgICAgICBULmh1Yi5qb2luKHNhZ2EuaWQpO1xcbiAgICAgICAgc2FnYS5wdWJzdWIuc3Vic2NyaWJlKHNhZ2EudG9waWNzLCBmdW5jdGlvbiAobWVzc2FnZSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBlbnZlbG9wZS5zYWdhSWQgPSBzYWdhLmlkO1xcbiAgICAgICAgICAgIFQuaHViLnB1Ymxpc2goZW52ZWxvcGUpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLnN0YXJ0U2FnYTtcXG4gICAgVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5qb2luU2FnYSA9IFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuam9pblNhZ2E7XFxuICAgIFRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLnN0YXJ0U2FnYTtcXG4gICAgVHJpYmUuUHViU3ViLkNoYW5uZWwucHJvdG90eXBlLmpvaW5TYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5qb2luU2FnYTtcXG5cXG4gICAgVHJpYmUuUHViU3ViLkNoYW5uZWwucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodG9waWNzKSB7XFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgICAgICBULmh1Yi5qb2luKHRoaXMuaWQpO1xcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUodG9waWNzIHx8ICcqJywgZnVuY3Rpb24oZGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBULmh1Yi5wdWJsaXNoKGVudmVsb3BlKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xcbiAgICAgICAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICBULmh1Yi5sZWF2ZShzZWxmLmNoYW5uZWxJZCk7XFxuICAgICAgICAgICAgZW5kKCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvUHViU3ViLmV4dGVuc2lvbnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULnNlcnZpY2VzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIGludm9rZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAkLmdldCgnU2VydmljZXMnLCB7IG5hbWU6IG5hbWUsIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDApIH0pXFxuICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH07XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvc2VydmljZXMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLkh1YiA9IGZ1bmN0aW9uIChpbywgcHVic3ViLCBvcHRpb25zKSB7XFxuICAgIHZhciBzb2NrZXQgPSBpby5jb25uZWN0KG9wdGlvbnMuc29ja2V0VXJsKTtcXG5cXG4gICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKGVudmVsb3BlKSB7XFxuICAgICAgICBlbnZlbG9wZS5vcmlnaW4gPSAnc2VydmVyJztcXG4gICAgICAgIHB1YnN1Yi5wdWJsaXNoKGVudmVsb3BlKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMucHVibGlzaCA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XFxuICAgICAgICBpZiAoIXNvY2tldClcXG4gICAgICAgICAgICB0aHJvdyAnSHViIG11c3QgYmUgY29ubmVjdGVkIGJlZm9yZSBjYWxsaW5nIHB1Ymxpc2gnO1xcbiAgICAgICAgaWYoZW52ZWxvcGUub3JpZ2luICE9PSAnc2VydmVyJylcXG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIGVudmVsb3BlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNzYWdlIGFja25vd2xlZGdlZCcpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmpvaW4gPSBmdW5jdGlvbihjaGFubmVsKSB7XFxuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbicsIGNoYW5uZWwpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0YXJ0U2FnYSA9IGZ1bmN0aW9uKHBhdGgsIGlkLCBkYXRhKSB7XFxuICAgICAgICBzb2NrZXQuZW1pdCgnc3RhcnRTYWdhJywgeyBwYXRoOiBwYXRoLCBpZDogaWQsIGRhdGE6IGRhdGEgfSk7XFxuICAgIH07XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Ob2RlL25vZGVfbW9kdWxlcy90cmliZS9jbGllbnQvdHlwZXMvSHViLmpzXCIpO1xuIiwiLyohIFRoZSBUcmliZSBwbGF0Zm9ybSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBodHRwOi8vdHJpYmVqcy5jb20vIGZvciBtb3JlIGluZm9ybWF0aW9uLiAqL1xyXG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgbGV2ZWwgPSA0O1xcbiAgICB2YXIgbGV2ZWxzID0ge1xcbiAgICAgICAgZGVidWc6IDQsXFxuICAgICAgICBpbmZvOiAzLFxcbiAgICAgICAgd2FybjogMixcXG4gICAgICAgIGVycm9yOiAxLFxcbiAgICAgICAgbm9uZTogMFxcbiAgICB9O1xcblxcbiAgICB2YXIgYXBpID0ge1xcbiAgICAgICAgc2V0TGV2ZWw6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcXG4gICAgICAgICAgICBpZiAobGV2ZWwgPT09IHVuZGVmaW5lZCkgbGV2ZWwgPSA0O1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlYnVnOiBmdW5jdGlvbiAobWVzc2FnZSkge1xcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSA0KVxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygoJ0RFQlVHOiAnICsgbWVzc2FnZSkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGluZm86IGZ1bmN0aW9uIChtZXNzYWdlKSB7XFxuICAgICAgICAgICAgaWYgKGxldmVsID49IDMpXFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygoJ0lORk86ICcgKyBtZXNzYWdlKSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgd2FybjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcXG4gICAgICAgICAgICBpZiAobGV2ZWwgPj0gMilcXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCgnV0FSTjogJyArIG1lc3NhZ2UpKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yKSB7XFxuICAgICAgICAgICAgaWYgKGxldmVsID49IDEpXFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKCdFUlJPUjogJyArIG1lc3NhZ2UgKyAnXFxcXG4nKSwgYXBpLmVycm9yRGV0YWlscyhlcnJvcikpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVycm9yRGV0YWlsczogZnVuY3Rpb24gKGV4KSB7XFxuICAgICAgICAgICAgaWYgKCFleCkgcmV0dXJuICcnO1xcbiAgICAgICAgICAgIHJldHVybiAoZXguY29uc3RydWN0b3IgPT09IFN0cmluZykgPyBleCA6XFxuICAgICAgICAgICAgICAgIChleC5zdGFjayB8fCAnJykgKyAoZXguaW5uZXIgPyAnXFxcXG5cXFxcbicgKyB0aGlzLmVycm9yRGV0YWlscyhleC5pbm5lcikgOiAnXFxcXG4nKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgYXBpLmxvZyA9IGFwaS5kZWJ1ZztcXG4gICAgXFxuICAgIGlmICh0eXBlb2YgKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhcGk7XFxuICAgIGVsc2Uge1xcbiAgICAgICAgaWYgKHR5cGVvZiAoVCkgPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgICAgIFQgPSB7fTtcXG4gICAgICAgIFQubG9nZ2VyID0gYXBpO1xcbiAgICB9XFxufSkoKTtcXG5cXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21tb24vU291cmNlL2xvZ2dlci5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIC8vIG1hbi4uLiB0aGlzIGNyb3NzLXBsYXRmb3JtIHN0dWZmIHN1Y2tzLi4uXFxuICAgIHZhciBrbztcXG4gICAgaWYgKHR5cGVvZiAod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpXFxuICAgICAgICBrbyA9IHdpbmRvdy5rbztcXG4gICAgaWYgKHR5cGVvZiAocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xcblxcbiAgICB2YXIgYXBpID0ge1xcbiAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFjdE1ldGFkYXRhKHNvdXJjZSkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGV4dHJhY3RNZXRhZGF0YTogZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzb3VyY2UsXFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ge307XFxuICAgICAgICAgICAgcmVtb3ZlT2JzZXJ2YWJsZXMoKTtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXFxuICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVPYnNlcnZhYmxlcygpIHtcXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEub2JzZXJ2YWJsZXMgPSBbXTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGFyZ2V0KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYga28uaXNPYnNlcnZhYmxlKHRhcmdldFtwcm9wZXJ0eV0pKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHRhcmdldFtwcm9wZXJ0eV0oKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5vYnNlcnZhYmxlcy5wdXNoKHByb3BlcnR5KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcXG4gICAgICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XFxuICAgICAgICAgICAgaWYgKHNvdXJjZS50YXJnZXQpXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWV0YWRhdGEoc291cmNlLnRhcmdldCwgc291cmNlLm1ldGFkYXRhKTtcXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFwcGx5TWV0YWRhdGE6IGZ1bmN0aW9uICh0YXJnZXQsIG1ldGFkYXRhKSB7XFxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKVxcbiAgICAgICAgICAgICAgICByZXN0b3JlT2JzZXJ2YWJsZXMoKTtcXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3RvcmVPYnNlcnZhYmxlcygpIHtcXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGVzID0gbWV0YWRhdGEub2JzZXJ2YWJsZXM7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JzZXJ2YWJsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZVByb3BlcnR5KG9ic2VydmFibGVzW2ldKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzdG9yZVByb3BlcnR5KHByb3BlcnR5KSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBjcmVhdGVPYnNlcnZhYmxlKHRhcmdldFtwcm9wZXJ0eV0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgP1xcbiAgICAgICAgICAgICAgICAgICAga28ub2JzZXJ2YWJsZUFycmF5KHZhbHVlKSA6XFxuICAgICAgICAgICAgICAgICAgICBrby5vYnNlcnZhYmxlKHZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIGlmICh0eXBlb2YgKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhcGk7XFxuICAgIGVsc2Uge1xcbiAgICAgICAgaWYgKHR5cGVvZiAoVCkgPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgICAgIFQgPSB7fTtcXG4gICAgICAgIFQuc2VyaWFsaXplciA9IGFwaTtcXG4gICAgfVxcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tbW9uL1NvdXJjZS9zZXJpYWxpemVyLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuaWYgKHR5cGVvZiAoVHJpYmUpID09PSAndW5kZWZpbmVkJylcXG4gICAgVHJpYmUgPSB7fTtcXG5cXG5UcmliZS5QdWJTdWIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG5cXG4gICAgdGhpcy5vd25lciA9IHRoaXM7XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgIHRoaXMuc3luYyA9IG9wdGlvbignc3luYycpO1xcbiAgICAgXFxuICAgIHZhciBzdWJzY3JpYmVycyA9IG5ldyBUcmliZS5QdWJTdWIuU3Vic2NyaWJlckxpc3QoKTtcXG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzO1xcblxcbiAgICBmdW5jdGlvbiBwdWJsaXNoKGVudmVsb3BlKSB7XFxuICAgICAgICB2YXIgbWVzc2FnZVN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZ2V0KGVudmVsb3BlLnRvcGljKTtcXG4gICAgICAgIHZhciBzeW5jID0gZW52ZWxvcGUuc3luYyA9PT0gdHJ1ZSB8fCBzZWxmLnN5bmMgPT09IHRydWU7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1lc3NhZ2VTdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAoc3luYylcXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVN1YnNjcmliZXIobWVzc2FnZVN1YnNjcmliZXJzW2ldLmhhbmRsZXIpO1xcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTdWJzY3JpYmVyKHN1YnNjcmliZXIuaGFuZGxlcik7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSkobWVzc2FnZVN1YnNjcmliZXJzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlU3Vic2NyaWJlcihmdW5jKSB7XFxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbkhhbmRsZXIgPSBvcHRpb24oJ2V4Y2VwdGlvbkhhbmRsZXInKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZihvcHRpb24oJ2hhbmRsZUV4Y2VwdGlvbnMnKSAgJiYgZXhjZXB0aW9uSGFuZGxlcilcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoZW52ZWxvcGUuZGF0YSwgZW52ZWxvcGUpO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUsIGVudmVsb3BlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZnVuYyhlbnZlbG9wZS5kYXRhLCBlbnZlbG9wZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2goY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucHVibGlzaFN5bmMgPSBmdW5jdGlvbiAodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XFxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpO1xcbiAgICAgICAgZW52ZWxvcGUuc3luYyA9IHRydWU7XFxuICAgICAgICByZXR1cm4gcHVibGlzaChlbnZlbG9wZSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiB0b3BpY09yRW52ZWxvcGUgJiYgdG9waWNPckVudmVsb3BlLnRvcGljXFxuICAgICAgICAgICAgPyB0b3BpY09yRW52ZWxvcGVcXG4gICAgICAgICAgICA6IHsgdG9waWM6IHRvcGljT3JFbnZlbG9wZSwgZGF0YTogZGF0YSB9O1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRvcGljLCBmdW5jKSB7XFxuICAgICAgICBpZiAodHlwZW9mICh0b3BpYykgPT09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5hZGQodG9waWMsIGZ1bmMpO1xcbiAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNBcnJheSh0b3BpYykpXFxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh0b3BpYywgZnVuY3Rpb24odG9waWNOYW1lKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5hZGQodG9waWNOYW1lLCBmdW5jKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKHRvcGljLCBmdW5jdGlvbiAoaW5kaXZpZHVhbEZ1bmMsIHRvcGljTmFtZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljTmFtZSwgaW5kaXZpZHVhbEZ1bmMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRva2Vucykge1xcbiAgICAgICAgaWYgKFRyaWJlLlB1YlN1Yi51dGlscy5pc0FycmF5KHRva2VucykpIHtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN1YnNjcmliZXJzLnJlbW92ZSh0b2tlbnNbaV0pKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5yZW1vdmUodG9rZW5zKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jcmVhdGVMaWZldGltZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuTGlmZXRpbWUoc2VsZiwgc2VsZik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxJZCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuQ2hhbm5lbChzZWxmLCBjaGFubmVsSWQpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gb3B0aW9uKG5hbWUpIHtcXG4gICAgICAgIHJldHVybiAoc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSA/IHNlbGYub3B0aW9uc1tuYW1lXSA6IFRyaWJlLlB1YlN1Yi5vcHRpb25zW25hbWVdO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvUHViU3ViLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVHJpYmUuUHViU3ViLkNoYW5uZWwgPSBmdW5jdGlvbiAocHVic3ViLCBjaGFubmVsSWQpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICBwdWJzdWIgPSBwdWJzdWIuY3JlYXRlTGlmZXRpbWUoKTtcXG5cXG4gICAgdGhpcy5pZCA9IGNoYW5uZWxJZDtcXG4gICAgdGhpcy5vd25lciA9IHB1YnN1Yi5vd25lcjtcXG5cXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5wdWJsaXNoKGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnB1Ymxpc2hTeW5jID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5wdWJsaXNoU3luYyhjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbih0b3BpYywgZnVuYykge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGZpbHRlck1lc3NhZ2VzKGZ1bmMpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIuc3Vic2NyaWJlT25jZSh0b3BpYywgZmlsdGVyTWVzc2FnZXMoZnVuYykpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICByZXR1cm4gcHVic3ViLnVuc3Vic2NyaWJlKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIuZW5kKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5MaWZldGltZShzZWxmLCBzZWxmLm93bmVyKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XFxuICAgICAgICB2YXIgZW52ZWxvcGUgPSB0b3BpY09yRW52ZWxvcGUgJiYgdG9waWNPckVudmVsb3BlLnRvcGljXFxuICAgICAgICAgID8gdG9waWNPckVudmVsb3BlXFxuICAgICAgICAgIDogeyB0b3BpYzogdG9waWNPckVudmVsb3BlLCBkYXRhOiBkYXRhIH07XFxuICAgICAgICBlbnZlbG9wZS5jaGFubmVsSWQgPSBjaGFubmVsSWQ7XFxuICAgICAgICByZXR1cm4gZW52ZWxvcGU7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIGZpbHRlck1lc3NhZ2VzKGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBlbnZlbG9wZSkge1xcbiAgICAgICAgICAgIGlmIChlbnZlbG9wZS5jaGFubmVsSWQgPT09IGNoYW5uZWxJZClcXG4gICAgICAgICAgICAgICAgZnVuYyhkYXRhLCBlbnZlbG9wZSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvQ2hhbm5lbC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5MaWZldGltZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG93bmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHRva2VucyA9IFtdO1xcblxcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XFxuXFxuICAgIHRoaXMucHVibGlzaCA9IGZ1bmN0aW9uKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdWJsaXNoKHRvcGljT3JFbnZlbG9wZSwgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucHVibGlzaFN5bmMgPSBmdW5jdGlvbih0b3BpYywgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdWJsaXNoU3luYyh0b3BpYywgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9IHBhcmVudC5zdWJzY3JpYmUodG9waWMsIGZ1bmMpO1xcbiAgICAgICAgcmV0dXJuIHJlY29yZFRva2VuKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9IHBhcmVudC5zdWJzY3JpYmVPbmNlKHRvcGljLCBmdW5jKTtcXG4gICAgICAgIHJldHVybiByZWNvcmRUb2tlbih0b2tlbik7XFxuICAgIH07XFxuICAgIFxcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9rZW4pIHtcXG4gICAgICAgIC8vIHdlIHNob3VsZCByZWFsbHkgcmVtb3ZlIHRoZSB0b2tlbihzKSBmcm9tIG91ciB0b2tlbiBsaXN0LCBidXQgaXQgaGFzIHRyaXZpYWwgaW1wYWN0IGlmIHdlIGRvbid0XFxuICAgICAgICByZXR1cm4gcGFyZW50LnVuc3Vic2NyaWJlKHRva2VuKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbElkKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5DaGFubmVsKHNlbGYsIGNoYW5uZWxJZCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gcGFyZW50LnVuc3Vic2NyaWJlKHRva2Vucyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkxpZmV0aW1lKHNlbGYsIHNlbGYub3duZXIpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gcmVjb3JkVG9rZW4odG9rZW4pIHtcXG4gICAgICAgIGlmIChUcmliZS5QdWJTdWIudXRpbHMuaXNBcnJheSh0b2tlbikpXFxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh0b2tlbik7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xcbiAgICAgICAgcmV0dXJuIHRva2VuO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvTGlmZXRpbWUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIub3B0aW9ucyA9IHtcXG4gICAgc3luYzogZmFsc2UsXFxuICAgIGhhbmRsZUV4Y2VwdGlvbnM6IHRydWUsXFxuICAgIGV4Y2VwdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGUsIGVudmVsb3BlKSB7XFxuICAgICAgICB0eXBlb2YoY29uc29sZSkgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUubG9nKFxcXCJFeGNlcHRpb24gb2NjdXJyZWQgaW4gc3Vic2NyaWJlciB0byAnXFxcIiArIGVudmVsb3BlLnRvcGljICsgXFxcIic6IFxcXCIgKyBlLm1lc3NhZ2UpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvb3B0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5TYWdhID0gZnVuY3Rpb24gKHB1YnN1YiwgZGVmaW5pdGlvbikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG5cXG4gICAgcHVic3ViID0gcHVic3ViLmNyZWF0ZUxpZmV0aW1lKCk7XFxuICAgIHRoaXMucHVic3ViID0gcHVic3ViO1xcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XFxuXFxuICAgIGNvbmZpZ3VyZVNhZ2EoKTtcXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVzIHx8IHt9O1xcblxcbiAgICAvLyB0aGlzIGlzIG5vdCBpZTw5IGNvbXBhdGlibGUgYW5kIGluY2x1ZGVzIG9uc3RhcnQgLyBvbmVuZFxcbiAgICB0aGlzLnRvcGljcyA9IE9iamVjdC5rZXlzKGhhbmRsZXJzKTtcXG5cXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChzdGFydERhdGEpIHtcXG4gICAgICAgIHV0aWxzLmVhY2goaGFuZGxlcnMsIHNlbGYuYWRkSGFuZGxlciwgc2VsZik7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25zdGFydCkgaGFuZGxlcnMub25zdGFydChzdGFydERhdGEsIHNlbGYpO1xcbiAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3RhcnRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgb25zdGFydERhdGEpIHtcXG4gICAgICAgIHNlbGYuY2hpbGRyZW4ucHVzaChuZXcgVHJpYmUuUHViU3ViLlNhZ2EocHVic3ViLCBjaGlsZClcXG4gICAgICAgICAgICAuc3RhcnQob25zdGFydERhdGEpKTtcXG4gICAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmpvaW4gPSBmdW5jdGlvbiAoZGF0YSwgb25qb2luRGF0YSkge1xcbiAgICAgICAgdXRpbHMuZWFjaChoYW5kbGVycywgc2VsZi5hZGRIYW5kbGVyLCBzZWxmKTtcXG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25qb2luKSBoYW5kbGVycy5vbmpvaW4ob25qb2luRGF0YSwgc2VsZik7XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbiAob25lbmREYXRhKSB7XFxuICAgICAgICBpZiAoaGFuZGxlcnMub25lbmQpIGhhbmRsZXJzLm9uZW5kKG9uZW5kRGF0YSwgc2VsZik7XFxuICAgICAgICBwdWJzdWIuZW5kKCk7XFxuICAgICAgICBzZWxmLmVuZENoaWxkcmVuKG9uZW5kRGF0YSk7XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgIFRyaWJlLlB1YlN1Yi51dGlscy5lYWNoKHNlbGYuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XFxuICAgICAgICAgICAgIGNoaWxkLmVuZChkYXRhKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjb25maWd1cmVTYWdhKCkge1xcbiAgICAgICAgaWYgKGRlZmluaXRpb24pXFxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uKHNlbGYpO1xcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgVHJpYmUuUHViU3ViLnV0aWxzLmNvcHlQcm9wZXJ0aWVzKGRlZmluaXRpb24sIHNlbGYsIFsnaGFuZGxlcycsICdlbmRzQ2hpbGRyZW5FeHBsaWNpdGx5J10pO1xcbiAgICB9XFxufTtcXG5cXG5UcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2EgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHRoaXMsIGRlZmluaXRpb24pLnN0YXJ0KGRhdGEpO1xcbn07XFxuXFxuVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2E7XFxuVHJpYmUuUHViU3ViLkxpZmV0aW1lLnByb3RvdHlwZS5zdGFydFNhZ2EgPSBUcmliZS5QdWJTdWIuU2FnYS5zdGFydFNhZ2E7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL1NhZ2EuY29yZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5TYWdhLnByb3RvdHlwZS5hZGRIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIHRvcGljKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgaWYgKHRvcGljICE9PSAnb25zdGFydCcgJiYgdG9waWMgIT09ICdvbmVuZCcgJiYgdG9waWMgIT09ICdvbmpvaW4nKVxcbiAgICAgICAgaWYgKCFoYW5kbGVyKVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgZW5kSGFuZGxlcigpKTtcXG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgbWVzc2FnZUhhbmRsZXJGb3IoaGFuZGxlcikpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHRoaXMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgY2hpbGRIYW5kbGVyRm9yKGhhbmRsZXIpKTtcXG5cXG4gICAgZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJGb3IoaGFuZGxlcikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlRGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBpZiAoIXNlbGYuZW5kc0NoaWxkcmVuRXhwbGljaXRseSlcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDaGlsZHJlbihtZXNzYWdlRGF0YSk7XFxuICAgICAgICAgICAgaGFuZGxlcihtZXNzYWdlRGF0YSwgZW52ZWxvcGUsIHNlbGYpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjaGlsZEhhbmRsZXJGb3IoY2hpbGRIYW5kbGVycykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlRGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBzZWxmLnN0YXJ0Q2hpbGQoeyBoYW5kbGVzOiBjaGlsZEhhbmRsZXJzIH0sIG1lc3NhZ2VEYXRhKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZW5kSGFuZGxlcigpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEpIHtcXG4gICAgICAgICAgICBzZWxmLmVuZChtZXNzYWdlRGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxufTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvU2FnYS5oYW5kbGVycy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuc3Vic2NyaWJlT25jZSA9IGZ1bmN0aW9uICh0b3BpYywgaGFuZGxlcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB1dGlscyA9IFRyaWJlLlB1YlN1Yi51dGlscztcXG4gICAgdmFyIGxpZmV0aW1lID0gdGhpcy5jcmVhdGVMaWZldGltZSgpO1xcblxcbiAgICBpZiAodHlwZW9mICh0b3BpYykgPT09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgICAgcmV0dXJuIGxpZmV0aW1lLnN1YnNjcmliZSh0b3BpYywgd3JhcEhhbmRsZXIoaGFuZGxlcikpO1xcbiAgICBlbHNlIGlmICh1dGlscy5pc0FycmF5KHRvcGljKSlcXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUod3JhcFRvcGljQXJyYXkoKSk7XFxuICAgIGVsc2VcXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUod3JhcFRvcGljT2JqZWN0KCkpO1xcblxcbiAgICBmdW5jdGlvbiB3cmFwVG9waWNBcnJheSgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcXG4gICAgICAgIHV0aWxzLmVhY2godG9waWMsIGZ1bmN0aW9uKHRvcGljTmFtZSkge1xcbiAgICAgICAgICAgIHJlc3VsdFt0b3BpY05hbWVdID0gd3JhcEhhbmRsZXIoaGFuZGxlcik7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIHdyYXBUb3BpY09iamVjdCgpIHtcXG4gICAgICAgIHJldHVybiB1dGlscy5tYXAodG9waWMsIGZ1bmN0aW9uIChmdW5jLCB0b3BpY05hbWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gbGlmZXRpbWUuc3Vic2NyaWJlKHRvcGljTmFtZSwgd3JhcEhhbmRsZXIoZnVuYykpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gd3JhcEhhbmRsZXIoZnVuYykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIGxpZmV0aW1lLmVuZCgpO1xcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9zdWJzY3JpYmVPbmNlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVHJpYmUuUHViU3ViLlN1YnNjcmliZXJMaXN0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBzdWJzY3JpYmVycyA9IHt9O1xcbiAgICB2YXIgbGFzdFVpZCA9IC0xO1xcblxcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIChwdWJsaXNoZWRUb3BpYykge1xcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XFxuICAgICAgICBmb3IgKHZhciByZWdpc3RlcmVkVG9waWMgaW4gc3Vic2NyaWJlcnMpXFxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KHJlZ2lzdGVyZWRUb3BpYykgJiYgdG9waWNNYXRjaGVzKHB1Ymxpc2hlZFRvcGljLCByZWdpc3RlcmVkVG9waWMpKVxcbiAgICAgICAgICAgICAgICBtYXRjaGluZyA9IG1hdGNoaW5nLmNvbmNhdChzdWJzY3JpYmVyc1tyZWdpc3RlcmVkVG9waWNdKTtcXG4gICAgICAgIHJldHVybiBtYXRjaGluZztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiAodG9waWMsIGhhbmRsZXIpIHtcXG4gICAgICAgIHZhciB0b2tlbiA9ICgrK2xhc3RVaWQpLnRvU3RyaW5nKCk7XFxuICAgICAgICBpZiAoIXN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KHRvcGljKSlcXG4gICAgICAgICAgICBzdWJzY3JpYmVyc1t0b3BpY10gPSBbXTtcXG4gICAgICAgIHN1YnNjcmliZXJzW3RvcGljXS5wdXNoKHsgdG9waWM6IHRvcGljLCBoYW5kbGVyOiBoYW5kbGVyLCB0b2tlbjogdG9rZW4gfSk7XFxuICAgICAgICByZXR1cm4gdG9rZW47XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24odG9rZW4pIHtcXG4gICAgICAgIGZvciAodmFyIG0gaW4gc3Vic2NyaWJlcnMpXFxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmhhc093blByb3BlcnR5KG0pKVxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnNjcmliZXJzW21dLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1ttXVtpXS50b2tlbiA9PT0gdG9rZW4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1ttXS5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiB0b3BpY01hdGNoZXMocHVibGlzaGVkLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICBpZiAoc3Vic2NyaWJlciA9PT0gJyonKVxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgXFxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFxcXCJeXFxcIiArIHN1YnNjcmliZXJcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC4vZywgXFxcIlxcXFxcXFxcLlxcXCIpXFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwqL2csIFxcXCJbXlxcXFwuXSpcXFwiKSArIFxcXCIkXFxcIjtcXG4gICAgICAgIHJldHVybiBwdWJsaXNoZWQubWF0Y2goZXhwcmVzc2lvbik7XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9TdWJzY3JpYmVyTGlzdC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi51dGlscyA9IHt9O1xcbihmdW5jdGlvbih1dGlscykge1xcbiAgICB1dGlscy5pc0FycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XFxuICAgIH07XFxuXFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSB0YWtlbiBmcm9tIHRoZSB1bmRlcnNjb3JlIGxpYnJhcnksIGR1cGxpY2F0ZWQgdG8gYXZvaWQgZGVwZW5kZW5jeS4gTGljZW5zZSBhdCBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy5cXG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcXG4gICAgdmFyIG5hdGl2ZU1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XFxuICAgIHZhciBicmVha2VyID0ge307XFxuXFxuICAgIHV0aWxzLmVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XFxuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcXG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB1dGlscy5tYXAgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xcbiAgICAgICAgdXRpbHMuZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcXG4gICAgICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLmNvcHlQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcXG4gICAgICAgICAgICBpZihzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59KShUcmliZS5QdWJTdWIudXRpbHMpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi91dGlscy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpXFxuICAgIG1vZHVsZS5leHBvcnRzID0gbmV3IFRyaWJlLlB1YlN1YigpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9leHBvcnRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcXG4gICAgaWYgKHR5cGVvZiAoalF1ZXJ5KSA9PT0gJ3VuZGVmaW5lZCcpXFxuICAgICAgICB0aHJvdyAnalF1ZXJ5IG11c3QgYmUgbG9hZGVkIGJlZm9yZSBrbm9ja291dC5jb21wb3NpdGUgY2FuIGluaXRpYWxpc2UnO1xcbiAgICBpZiAodHlwZW9mIChrbykgPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgdGhyb3cgJ2tub2Nrb3V0LmpzIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBrbm9ja291dC5jb21wb3NpdGUgY2FuIGluaXRpYWxpc2UnO1xcbiAgICBpZiAodHlwZW9mKFQpID09PSAndW5kZWZpbmVkJylcXG4gICAgICAgIHRocm93ICdUcmliZS5Db21tb24gbXVzdCBiZSBsb2FkZWQgYmVmb3JlIGtub2Nrb3V0LmNvbXBvc2l0ZSBjYW4gaW5pdGlhbGlzZSc7XFxuXFxuICAgIGdsb2JhbC5UID0gVCB8fCB7fTtcXG4gICAgZ2xvYmFsLlQuRXZlbnRzID0ge307XFxuICAgIGdsb2JhbC5ULkZhY3RvcmllcyA9IHt9O1xcbiAgICBnbG9iYWwuVC5Mb2FkSGFuZGxlcnMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuTG9hZFN0cmF0ZWdpZXMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuVHJhbnNpdGlvbnMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuVHlwZXMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuVXRpbHMgPSB7fTtcXG4gICAgZ2xvYmFsLlQubG9nZ2VyID0gVC5sb2dnZXI7XFxuICAgIGdsb2JhbC5ULnB1YnN1YiA9IG5ldyBUcmliZS5QdWJTdWIoKTtcXG5cXG4gICAgJChmdW5jdGlvbigpIHtcXG4gICAgICAgICQoJ2hlYWQnKS5hcHBlbmQoJzxzdHlsZSBjbGFzcz1cXFwiX190cmliZVxcXCI+Ll9fcmVuZGVyaW5nIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwMHB4OyBsZWZ0OiAtMTAwMDBweDsgfTwvc3R5bGU+Jyk7XFxuICAgIH0pO1xcbn0pKHdpbmRvdyB8fCB0aGlzKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvc2V0dXAuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgICBzeW5jaHJvbm91czogZmFsc2UsXFxuICAgICAgICBoYW5kbGVFeGNlcHRpb25zOiB0cnVlLFxcbiAgICAgICAgYmFzZVBhdGg6ICcnLFxcbiAgICAgICAgbG9hZFN0cmF0ZWd5OiAnYWRob2MnLFxcbiAgICAgICAgZXZlbnRzOiBbJ2xvYWRSZXNvdXJjZXMnLCAnY3JlYXRlUHViU3ViJywgJ2NyZWF0ZU1vZGVsJywgJ2luaXRpYWxpc2VNb2RlbCcsICdyZW5kZXJQYW5lJywgJ3JlbmRlckNvbXBsZXRlJywgJ2FjdGl2ZScsICdkaXNwb3NlJ11cXG4gICAgfTtcXG59O1xcblQub3B0aW9ucyA9IFQuZGVmYXVsdE9wdGlvbnMoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvb3B0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5jc3NDbGFzcyA9IHtcXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XFxuICAgICAgICAgICAgaWYgKHZhbHVlKVxcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUpKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAga28uYmluZGluZ0hhbmRsZXJzLmVudGVyUHJlc3NlZCA9IGtleVByZXNzZWRCaW5kaW5nSGFuZGxlcigxMyk7XFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5lc2NhcGVQcmVzc2VkID0ga2V5UHJlc3NlZEJpbmRpbmdIYW5kbGVyKDI3KTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIGtleVByZXNzZWRCaW5kaW5nSGFuZGxlcih3aGljaCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xcbiAgICAgICAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB2YWx1ZUFjY2Vzc29yKCk7XFxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oY2FsbGJhY2spKVxcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQua2V5dXAodGVzdEtleSk7XFxuXFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RLZXkoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gd2hpY2gpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyRlbGVtZW50LmJsdXIoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygkZWxlbWVudC52YWwoKSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxufSkoKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2JpbmRpbmdIYW5kbGVycy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAodXRpbHMpIHsgICAgXFxuICAgIHV0aWxzLmVhY2ggPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlcmF0b3IpIHtcXG4gICAgICAgIHJldHVybiAkLmVhY2goY29sbGVjdGlvbiB8fCBbXSwgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcih2YWx1ZSwgaW5kZXgpO1xcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8vIGpRdWVyeSBtYXAgZmxhdHRlbnMgcmV0dXJuZWQgYXJyYXlzIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIGZvciBncmlkc1xcbiAgICB1dGlscy5tYXAgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlcmF0b3IpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgIHV0aWxzLmVhY2goY29sbGVjdGlvbiB8fCBbXSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3IodmFsdWUsIGluZGV4KSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLmZpbHRlciA9IGZ1bmN0aW9uKGFycmF5LCBpdGVyYXRvcikge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgICAgICAgJC5lYWNoKGFycmF5IHx8IFtdLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IodmFsdWUsIGluZGV4KSlcXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5wbHVjayA9IGZ1bmN0aW9uKGFycmF5LCBwcm9wZXJ0eSkge1xcbiAgICAgICAgcmV0dXJuIHV0aWxzLm1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbcHJvcGVydHldO1xcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnJheSwgaW5pdGlhbFZhbHVlLCByZWR1Y2VGdW5jdGlvbikge1xcbiAgICAgICAgdXRpbHMuZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gcmVkdWNlRnVuY3Rpb24oaW5pdGlhbFZhbHVlLCB2YWx1ZSwgaW5kZXgsIGFycmF5KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcXG4gICAgfTtcXG59KShULlV0aWxzKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2NvbGxlY3Rpb25zLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuLy8gdGhpcyBpcyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LWJicS8sIENvcHlyaWdodCAoYykgMjAxMCBcXFwiQ293Ym95XFxcIiBCZW4gQWxtYW4gYW5kIGFsc28gcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuXFxuLy8gRGVzZXJpYWxpemUgYSBwYXJhbXMgc3RyaW5nIGludG8gYW4gb2JqZWN0LCBvcHRpb25hbGx5IGNvZXJjaW5nIG51bWJlcnMsXFxuLy8gYm9vbGVhbnMsIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXM7IHRoaXMgbWV0aG9kIGlzIHRoZSBjb3VudGVycGFydCB0byB0aGVcXG4vLyBpbnRlcm5hbCBqUXVlcnkucGFyYW0gbWV0aG9kLlxcblQuVXRpbHMuZGVwYXJhbSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNvZXJjZSkge1xcbiAgICB2YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xcbiAgICB2YXIgb2JqID0ge30sXFxuICAgICAgY29lcmNlX3R5cGVzID0geyAndHJ1ZSc6ICEwLCAnZmFsc2UnOiAhMSwgJ251bGwnOiBudWxsIH07XFxuXFxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbmFtZT12YWx1ZSBwYWlycy5cXG4gICAgJC5lYWNoKHBhcmFtcy5yZXBsYWNlKC9cXFxcKy9nLCAnICcpLnNwbGl0KCcmJyksIGZ1bmN0aW9uIChqLCB2KSB7XFxuICAgICAgICB2YXIgcGFyYW0gPSB2LnNwbGl0KCc9JyksXFxuICAgICAgICAgIGtleSA9IGRlY29kZShwYXJhbVswXSksXFxuICAgICAgICAgIHZhbCxcXG4gICAgICAgICAgY3VyID0gb2JqLFxcbiAgICAgICAgICBpID0gMCxcXG5cXG4gICAgICAgICAgLy8gSWYga2V5IGlzIG1vcmUgY29tcGxleCB0aGFuICdmb28nLCBsaWtlICdhW10nIG9yICdhW2JdW2NdJywgc3BsaXQgaXRcXG4gICAgICAgICAgLy8gaW50byBpdHMgY29tcG9uZW50IHBhcnRzLlxcbiAgICAgICAgICBrZXlzID0ga2V5LnNwbGl0KCddWycpLFxcbiAgICAgICAgICBrZXlzX2xhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XFxuXFxuICAgICAgICAvLyBJZiB0aGUgZmlyc3Qga2V5cyBwYXJ0IGNvbnRhaW5zIFsgYW5kIHRoZSBsYXN0IGVuZHMgd2l0aCBdLCB0aGVuIFtdXFxuICAgICAgICAvLyBhcmUgY29ycmVjdGx5IGJhbGFuY2VkLlxcbiAgICAgICAgaWYgKC9cXFxcWy8udGVzdChrZXlzWzBdKSAmJiAvXFxcXF0kLy50ZXN0KGtleXNba2V5c19sYXN0XSkpIHtcXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYWlsaW5nIF0gZnJvbSB0aGUgbGFzdCBrZXlzIHBhcnQuXFxuICAgICAgICAgICAga2V5c1trZXlzX2xhc3RdID0ga2V5c1trZXlzX2xhc3RdLnJlcGxhY2UoL1xcXFxdJC8sICcnKTtcXG5cXG4gICAgICAgICAgICAvLyBTcGxpdCBmaXJzdCBrZXlzIHBhcnQgaW50byB0d28gcGFydHMgb24gdGhlIFsgYW5kIGFkZCB0aGVtIGJhY2sgb250b1xcbiAgICAgICAgICAgIC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGtleXMgYXJyYXkuXFxuICAgICAgICAgICAga2V5cyA9IGtleXMuc2hpZnQoKS5zcGxpdCgnWycpLmNvbmNhdChrZXlzKTtcXG5cXG4gICAgICAgICAgICBrZXlzX2xhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIEJhc2ljICdmb28nIHN0eWxlIGtleS5cXG4gICAgICAgICAgICBrZXlzX2xhc3QgPSAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gQXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWU9dmFsdWUgcGFpciwgb3IganVzdCBhIG5hbWU/XFxuICAgICAgICBpZiAocGFyYW0ubGVuZ3RoID09PSAyKSB7XFxuICAgICAgICAgICAgdmFsID0gZGVjb2RlKHBhcmFtWzFdKTtcXG5cXG4gICAgICAgICAgICAvLyBDb2VyY2UgdmFsdWVzLlxcbiAgICAgICAgICAgIGlmIChjb2VyY2UpIHtcXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsICYmICFpc05hTih2YWwpID8gK3ZhbCAgICAgICAgICAgICAgLy8gbnVtYmVyXFxuICAgICAgICAgICAgICAgICAgOiB2YWwgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkICAgICAgICAgLy8gdW5kZWZpbmVkXFxuICAgICAgICAgICAgICAgICAgOiBjb2VyY2VfdHlwZXNbdmFsXSAhPT0gdW5kZWZpbmVkID8gY29lcmNlX3R5cGVzW3ZhbF0gLy8gdHJ1ZSwgZmFsc2UsIG51bGxcXG4gICAgICAgICAgICAgICAgICA6IHZhbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmdcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGtleXNfbGFzdCkge1xcbiAgICAgICAgICAgICAgICAvLyBDb21wbGV4IGtleSwgYnVpbGQgZGVlcCBvYmplY3Qgc3RydWN0dXJlIGJhc2VkIG9uIGEgZmV3IHJ1bGVzOlxcbiAgICAgICAgICAgICAgICAvLyAqIFRoZSAnY3VyJyBwb2ludGVyIHN0YXJ0cyBhdCB0aGUgb2JqZWN0IHRvcC1sZXZlbC5cXG4gICAgICAgICAgICAgICAgLy8gKiBbXSA9IGFycmF5IHB1c2ggKG4gaXMgc2V0IHRvIGFycmF5IGxlbmd0aCksIFtuXSA9IGFycmF5IGlmIG4gaXMgXFxuICAgICAgICAgICAgICAgIC8vICAgbnVtZXJpYywgb3RoZXJ3aXNlIG9iamVjdC5cXG4gICAgICAgICAgICAgICAgLy8gKiBJZiBhdCB0aGUgbGFzdCBrZXlzIHBhcnQsIHNldCB0aGUgdmFsdWUuXFxuICAgICAgICAgICAgICAgIC8vICogRm9yIGVhY2gga2V5cyBwYXJ0LCBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyB1bmRlZmluZWQgY3JlYXRlIGFuXFxuICAgICAgICAgICAgICAgIC8vICAgb2JqZWN0IG9yIGFycmF5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBuZXh0IGtleXMgcGFydC5cXG4gICAgICAgICAgICAgICAgLy8gKiBNb3ZlIHRoZSAnY3VyJyBwb2ludGVyIHRvIHRoZSBuZXh0IGxldmVsLlxcbiAgICAgICAgICAgICAgICAvLyAqIFJpbnNlICYgcmVwZWF0LlxcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8PSBrZXlzX2xhc3Q7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXSA9PT0gJycgPyBjdXIubGVuZ3RoIDoga2V5c1tpXTtcXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1cltrZXldID0gaSA8IGtleXNfbGFzdFxcbiAgICAgICAgICAgICAgICAgICAgICA/IGN1cltrZXldIHx8IChrZXlzW2kgKyAxXSAmJiBpc05hTihrZXlzW2kgKyAxXSkgPyB7fSA6IFtdKVxcbiAgICAgICAgICAgICAgICAgICAgICA6IHZhbDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBrZXksIGV2ZW4gc2ltcGxlciBydWxlcywgc2luY2Ugb25seSBzY2FsYXJzIGFuZCBzaGFsbG93XFxuICAgICAgICAgICAgICAgIC8vIGFycmF5cyBhcmUgYWxsb3dlZC5cXG5cXG4gICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShvYmpba2V5XSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbCBpcyBhbHJlYWR5IGFuIGFycmF5LCBzbyBwdXNoIG9uIHRoZSBuZXh0IHZhbHVlLlxcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xcblxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbCBpc24ndCBhbiBhcnJheSwgYnV0IHNpbmNlIGEgc2Vjb25kIHZhbHVlIGhhcyBiZWVuIHNwZWNpZmllZCxcXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmFsIGludG8gYW4gYXJyYXkuXFxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtvYmpba2V5XSwgdmFsXTtcXG5cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbCBpcyBhIHNjYWxhci5cXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcXG4gICAgICAgICAgICAvLyBObyB2YWx1ZSB3YXMgZGVmaW5lZCwgc28gc2V0IHNvbWV0aGluZyBtZWFuaW5nZnVsLlxcbiAgICAgICAgICAgIG9ialtrZXldID0gY29lcmNlXFxuICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxcbiAgICAgICAgICAgICAgOiAnJztcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiBvYmo7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2RlcGFyYW0uanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24oKSB7XFxuICAgIFQuVXRpbHMuZW1iZWRTdGF0ZSA9IGZ1bmN0aW9uIChtb2RlbCwgY29udGV4dCwgbm9kZSkge1xcbiAgICAgICAgZW1iZWRQcm9wZXJ0eShtb2RlbCwgJ2NvbnRleHQnLCBjb250ZXh0KTtcXG4gICAgICAgIGVtYmVkUHJvcGVydHkobW9kZWwsICdub2RlJywgbm9kZSk7XFxuICAgIH07XFxuXFxuICAgIFQuVXRpbHMuY29udGV4dEZvciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBULlV0aWxzLmV4dHJhY3RDb250ZXh0KGtvLmNvbnRleHRGb3IoJChlbGVtZW50KVswXSkpO1xcbiAgICB9O1xcblxcbiAgICBULlV0aWxzLmV4dHJhY3RDb250ZXh0ID0gZnVuY3Rpb24gKGtvQmluZGluZ0NvbnRleHQpIHtcXG4gICAgICAgIHJldHVybiBrb0JpbmRpbmdDb250ZXh0ICYmIGVtYmVkZGVkUHJvcGVydHkoa29CaW5kaW5nQ29udGV4dC4kcm9vdCwgJ2NvbnRleHQnKTtcXG4gICAgfTtcXG5cXG4gICAgVC5VdGlscy5leHRyYWN0Tm9kZSA9IGZ1bmN0aW9uIChrb0JpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICByZXR1cm4ga29CaW5kaW5nQ29udGV4dCAmJiBlbWJlZGRlZFByb3BlcnR5KGtvQmluZGluZ0NvbnRleHQuJHJvb3QsICdub2RlJyk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGVtYmVkUHJvcGVydHkodGFyZ2V0LCBrZXksIHZhbHVlKSB7XFxuICAgICAgICBpZiAoIXRhcmdldClcXG4gICAgICAgICAgICB0aHJvdyBcXFwiQ2FuJ3QgZW1iZWQgcHJvcGVydHkgaW4gZmFsc3kgdmFsdWVcXFwiO1xcbiAgICAgICAgdGFyZ2V0WydfXycgKyBrZXldID0gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZW1iZWRkZWRQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xcbiAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXRbJ19fJyArIGtleV07XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvZW1iZWRkZWRDb250ZXh0LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgVC5VdGlscy5lbGVtZW50RGVzdHJveWVkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgIGlmIChlbGVtZW50LmNvbnN0cnVjdG9yID09PSBqUXVlcnkpXFxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XFxuXFxuICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG5cXG4gICAgICAgIC8vIFJlc29sdmUgd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgdXNpbmcgalF1ZXJ5LiBUaGlzIGlzIGEgZmFsbGJhY2sgZm9yIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIERPTU5vZGVSZW1vdmVkIGFuZCBhbHNvIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHkuXFxuICAgICAgICAkKGVsZW1lbnQpLm9uKCdkZXN0cm95ZWQnLCByZXNvbHZlKTtcXG5cXG4gICAgICAgIC8vIFJlc29sdmUgdXNpbmcgdGhlIERPTU5vZGVSZW1vdmVkIGV2ZW50LiBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhpcy5cXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFxcXCJET01Ob2RlUmVtb3ZlZFxcXCIsIG1hdGNoRWxlbWVudCk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBtYXRjaEVsZW1lbnQoZXZlbnQpIHtcXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50KVxcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlKCkge1xcbiAgICAgICAgICAgICQoZWxlbWVudCkub2ZmKCdkZXN0cm95ZWQnLCByZXNvbHZlKTtcXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ0RPTU5vZGVSZW1vdmVkJywgbWF0Y2hFbGVtZW50KTtcXG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xcbiAgICB9O1xcblxcbiAgICAvLyB0aGlzIHVzZWQgdG8gdXNlIERPTSBmdW5jdGlvbnMgdG8gcmFpc2UgZXZlbnRzLCBidXQgSUU4IGRvZXNuJ3Qgc3VwcG9ydCBjdXN0b20gZXZlbnRzXFxuICAgIC8vIHdlJ2xsIHVzZSBqUXVlcnksIGJ1dCBleHBvc2UgdGhlIG9yaWdpbmFsRXZlbnQgZm9yIERPTSBldmVudHMgYW5kIHRoZSBqUXVlcnkgZXZlbnRcXG4gICAgLy8gZm9yIGN1c3RvbSBldmVudHMgKG9yaWdpbmFsRXZlbnQgaXMgbnVsbCBmb3IgY3VzdG9tIGV2ZW50cykuXFxuICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50RGF0YSkge1xcbiAgICAgICAgdmFyIGUgPSAkLkV2ZW50KG5hbWUpO1xcbiAgICAgICAgZS5ldmVudERhdGEgPSBldmVudERhdGE7XFxuICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKGUpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgaGFuZGxlcnMgPSB7fTtcXG5cXG4gICAgLy8gaWYgYSBoYW5kbGVyIGlzIHVzZWQgZm9yIG1vcmUgdGhhbiBvbmUgZXZlbnQsIGEgbGVhayB3aWxsIG9jY3VyXFxuICAgIFQuVXRpbHMuaGFuZGxlRG9jdW1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XFxuICAgICAgICAkKGRvY3VtZW50KS5vbihuYW1lLCBpbnRlcm5hbEhhbmRsZXIpO1xcbiAgICAgICAgaGFuZGxlcnNbaGFuZGxlcl0gPSBpbnRlcm5hbEhhbmRsZXI7XFxuICAgICAgICBcXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsSGFuZGxlcihlKSB7XFxuICAgICAgICAgICAgaGFuZGxlcihlLm9yaWdpbmFsRXZlbnQgfHwgZSk7XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIFQuVXRpbHMuZGV0YWNoRG9jdW1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XFxuICAgICAgICAkKGRvY3VtZW50KS5vZmYobmFtZSwgaGFuZGxlcnNbaGFuZGxlcl0pO1xcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2hhbmRsZXJdO1xcbiAgICB9O1xcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9ldmVudHMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlV0aWxzLnRyeUNhdGNoID0gZnVuY3Rpb24oZnVuYywgYXJncywgaGFuZGxlRXhjZXB0aW9ucywgbWVzc2FnZSkge1xcbiAgICBpZiAoaGFuZGxlRXhjZXB0aW9ucylcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IobWVzc2FnZSwgZXgpO1xcbiAgICAgICAgfVxcbiAgICBlbHNlXFxuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9leGNlcHRpb25zLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgVC5VdGlscy5pZEdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbmV4dDogKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gMDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCsrO1xcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH0pKClcXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIHZhciBnZW5lcmF0b3IgPSBULlV0aWxzLmlkR2VuZXJhdG9yKCk7XFxuICAgIFQuVXRpbHMuZ2V0VW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLm5leHQoKTtcXG4gICAgfTtcXG59KSgpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvaWRHZW5lcmF0b3IuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLykge1xcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBuLCBrLCB0ID0gT2JqZWN0KHRoaXMpLFxcbiAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xcblxcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgIH1cXG4gICAgICAgIG4gPSAwO1xcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgICAgbiA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xcbiAgICAgICAgICAgIGlmIChuICE9IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxcbiAgICAgICAgICAgICAgICBuID0gMDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gIT0gMCAmJiBuICE9IEluZmluaXR5ICYmIG4gIT0gLUluZmluaXR5KSB7XFxuICAgICAgICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG4gPj0gbGVuKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yIChrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKSA7IGsgPCBsZW47IGsrKykge1xcbiAgICAgICAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgIH07XFxufVxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvaW5kZXhPZi5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoJCkge1xcbiAgICAkLmNvbXBsZXRlID0gZnVuY3Rpb24gKGRlZmVycmVkcykge1xcbiAgICAgICAgdmFyIHdyYXBwZXJzID0gW107XFxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XFxuICAgICAgICB2YXIgcmVzb2x2ZSA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKCQuaXNBcnJheShkZWZlcnJlZHMpKVxcbiAgICAgICAgICAgICQuZWFjaChkZWZlcnJlZHMsIHdyYXBEZWZlcnJlZCk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgd3JhcERlZmVycmVkKDAsIGRlZmVycmVkcyk7XFxuXFxuICAgICAgICAkLndoZW4uYXBwbHkoJCwgd3JhcHBlcnMpLmRvbmUoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgcmVzb2x2ZSA/XFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKSA6XFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XFxuXFxuICAgICAgICBmdW5jdGlvbiB3cmFwRGVmZXJyZWQoaW5kZXgsIG9yaWdpbmFsKSB7XFxuICAgICAgICAgICAgd3JhcHBlcnMucHVzaCgkLkRlZmVycmVkKGZ1bmN0aW9uICh0aGlzRGVmZXJyZWQpIHtcXG4gICAgICAgICAgICAgICAgJC53aGVuKG9yaWdpbmFsKVxcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0RlZmVycmVkLnJlc29sdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59KShqUXVlcnkpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvanF1ZXJ5LmNvbXBsZXRlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgkKSB7XFxuICAgIHZhciBvbGRDbGVhbiA9IGpRdWVyeS5jbGVhbkRhdGE7XFxuXFxuICAgIC8vIGtub2Nrb3V0IGFsc28gY2FsbHMgY2xlYW5EYXRhIGZyb20gaXQncyBjbGVhbk5vZGUgbWV0aG9kIC0gYXZvaWQgYW55IGxvb3BzXFxuICAgIC8vdmFyIGNsZWFuaW5nID0ge307XFxuXFxuICAgICQuY2xlYW5EYXRhID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbGVtZW50c1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XFxuICAgICAgICAgICAgLy9pZiAoIWNsZWFuaW5nW2VsZW1lbnRdKSB7XFxuICAgICAgICAgICAgICAgIC8vY2xlYW5pbmdbZWxlbWVudF0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnRyaWdnZXJIYW5kbGVyKFxcXCJkZXN0cm95ZWRcXFwiKTtcXG4gICAgICAgICAgICAgICAgLy9kZWxldGUgY2xlYW5pbmdbZWxlbWVudF07XFxuICAgICAgICAgICAgLy99XFxuICAgICAgICB9XFxuICAgICAgICBvbGRDbGVhbihlbGVtZW50cyk7XFxuICAgIH07XFxufSkoalF1ZXJ5KTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2pxdWVyeS5kZXN0cm95ZWQuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlV0aWxzLmNsZWFuRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgIC8vIHByZXZlbnQga25vY2tvdXQgZnJvbSBjYWxsaW5nIGNsZWFuRGF0YSBcXG4gICAgLy8gLSBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIHVsdGltYXRlbHkgcmVzdWx0IGZyb20gY2xlYW5EYXRhIGJlaW5nIGNhbGxlZCBieSBqUXVlcnksIHNvIGEgbG9vcCB3aWxsIG9jY3VyXFxuICAgIHZhciBmdW5jID0gJC5jbGVhbkRhdGE7XFxuICAgICQuY2xlYW5EYXRhID0gdW5kZWZpbmVkO1xcbiAgICBrby5jbGVhbk5vZGUoZWxlbWVudCk7XFxuICAgICQuY2xlYW5EYXRhID0gZnVuYztcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMva25vY2tvdXQuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlV0aWxzLmFyZ3VtZW50cyA9IGZ1bmN0aW9uIChhcmdzKSB7XFxuICAgIHZhciBieUNvbnN0cnVjdG9yID0ge307XFxuICAgICQuZWFjaChhcmdzLCBmdW5jdGlvbiAoaW5kZXgsIGFyZykge1xcbiAgICAgICAgYnlDb25zdHJ1Y3RvclthcmcuY29uc3RydWN0b3JdID0gYXJnO1xcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIGJ5Q29uc3RydWN0b3I6IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xcbiAgICAgICAgICAgIHJldHVybiBieUNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvYmplY3Q6IGJ5Q29uc3RydWN0b3JbT2JqZWN0XSxcXG4gICAgICAgIHN0cmluZzogYnlDb25zdHJ1Y3RvcltTdHJpbmddLFxcbiAgICAgICAgZnVuYzogYnlDb25zdHJ1Y3RvcltGdW5jdGlvbl0sXFxuICAgICAgICBhcnJheTogYnlDb25zdHJ1Y3RvcltBcnJheV0sXFxuICAgICAgICBudW1iZXI6IGJ5Q29uc3RydWN0b3JbTnVtYmVyXVxcbiAgICB9O1xcbn07XFxuXFxuVC5VdGlscy5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XFxuICAgIHZhciBpbmRleCA9ICQuaW5BcnJheShpdGVtLCBhcnJheSk7XFxuICAgIGlmIChpbmRleCA+IC0xKVxcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcXG59O1xcblxcblQuVXRpbHMuaW5oZXJpdE9wdGlvbnMgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdGlvbnMpIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgIHRvW29wdGlvbnNbaV1dID0gZnJvbVtvcHRpb25zW2ldXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuXFxuVC5VdGlscy5jbG9uZURhdGEgPSBmdW5jdGlvbiAoZnJvbSwgZXhjZXB0KSB7XFxuICAgIGlmICghZnJvbSkgcmV0dXJuO1xcbiAgICB2YXIgcmVzdWx0ID0ge307XFxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZyb20pIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IGZyb21bcHJvcGVydHldO1xcbiAgICAgICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmXFxuICAgICAgICAgICAgKCFleGNlcHQgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcmd1bWVudHMsIHByb3BlcnR5KSA9PT0gLTEpICYmXFxuICAgICAgICAgICAgKCF2YWx1ZSB8fCAodmFsdWUuY29uc3RydWN0b3IgIT09IEZ1bmN0aW9uIHx8IGtvLmlzT2JzZXJ2YWJsZSh2YWx1ZSkpKSlcXG5cXG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblQuVXRpbHMubm9ybWFsaXNlQmluZGluZ3MgPSBmdW5jdGlvbiAodmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvcikge1xcbiAgICB2YXIgZGF0YSA9IGFsbEJpbmRpbmdzQWNjZXNzb3IoKTtcXG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcXG4gICAgaWYgKCFrby5pc09ic2VydmFibGUoZGF0YS52YWx1ZSkgJiYgJC5pc0Z1bmN0aW9uKGRhdGEudmFsdWUpKVxcbiAgICAgICAgZGF0YS52YWx1ZSA9IGRhdGEudmFsdWUoKTtcXG4gICAgcmV0dXJuIGRhdGE7XFxufTtcXG5cXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL29iamVjdHMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdXRpbHMgPSBULlV0aWxzO1xcblxcbiAgICB1dGlscy5nZXRQYW5lT3B0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlLCBvdGhlck9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBvcHRpb25zID0gdmFsdWUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IHsgcGF0aDogdmFsdWUgfSA6IHZhbHVlO1xcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBvdGhlck9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5iaW5kUGFuZSA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50LCBwYW5lT3B0aW9ucywgY29udGV4dCkge1xcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdXRpbHMuY29udGV4dEZvcihlbGVtZW50KSB8fCBULmNvbnRleHQoKTtcXG4gICAgICAgIHZhciBwYW5lID0gbmV3IFQuVHlwZXMuUGFuZSgkLmV4dGVuZCh7IGVsZW1lbnQ6ICQoZWxlbWVudClbMF0gfSwgcGFuZU9wdGlvbnMpKTtcXG4gICAgICAgIG5vZGUuc2V0UGFuZShwYW5lKTtcXG5cXG4gICAgICAgIGNvbnRleHQucmVuZGVyT3BlcmF0aW9uLmFkZChwYW5lKTtcXG5cXG4gICAgICAgIHZhciBwaXBlbGluZSA9IG5ldyBULlR5cGVzLlBpcGVsaW5lKFQuRXZlbnRzLCBjb250ZXh0KTtcXG4gICAgICAgIHBpcGVsaW5lLmV4ZWN1dGUoY29udGV4dC5vcHRpb25zLmV2ZW50cywgcGFuZSk7XFxuXFxuICAgICAgICByZXR1cm4gcGFuZTtcXG4gICAgfTtcXG5cXG4gICAgdXRpbHMuaW5zZXJ0UGFuZUFmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHRhcmdldCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCgnPGRpdi8+JykuaW5zZXJ0QWZ0ZXIodGFyZ2V0KTtcXG4gICAgICAgIHJldHVybiB1dGlscy5iaW5kUGFuZShub2RlLCBlbGVtZW50LCBwYW5lT3B0aW9ucywgY29udGV4dCk7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL3BhbmVzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uKCkge1xcbiAgICBULlBhdGggPSBQYXRoO1xcblxcbiAgICBmdW5jdGlvbiBQYXRoKHBhdGgpIHtcXG4gICAgICAgIHBhdGggPSBwYXRoID8gbm9ybWFsaXNlKHBhdGgudG9TdHJpbmcoKSkgOiAnJztcXG4gICAgICAgIHZhciBmaWxlbmFtZUluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZihcXFwiL1xcXCIpICsgMTtcXG4gICAgICAgIHZhciBleHRlbnNpb25JbmRleCA9IHBhdGgubGFzdEluZGV4T2YoXFxcIi5cXFwiKTtcXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgd2l0aG91dEZpbGVuYW1lOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgocGF0aC5zdWJzdHJpbmcoMCwgZmlsZW5hbWVJbmRleCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZmlsZW5hbWU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChwYXRoLnN1YnN0cmluZyhmaWxlbmFtZUluZGV4KSk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBleHRlbnNpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uSW5kZXggPT09IC0xID8gJycgOiBwYXRoLnN1YnN0cmluZyhleHRlbnNpb25JbmRleCArIDEpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgd2l0aG91dEV4dGVuc2lvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKGV4dGVuc2lvbkluZGV4ID09PSAtMSA/IHBhdGggOiBwYXRoLnN1YnN0cmluZygwLCBleHRlbnNpb25JbmRleCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY29tYmluZTogZnVuY3Rpb24gKGFkZGl0aW9uYWxQYXRoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKChwYXRoID8gcGF0aCArICcvJyA6ICcnKSArIGFkZGl0aW9uYWxQYXRoLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8XFxuICAgICAgICAgICAgICAgICAgICBwYXRoLmluZGV4T2YoJzovLycpID4gLTE7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBtYWtlQWJzb2x1dGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aCgnLycgKyBwYXRoKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG1ha2VSZWxhdGl2ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGgpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYXNNYXJrdXBJZGVudGlmaWVyOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbigpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxcXC8vZywgJy0nKS5yZXBsYWNlKC9cXFxcLi9nLCAnJyk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzZXRFeHRlbnNpb246IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aCh0aGlzLndpdGhvdXRFeHRlbnNpb24oKSArICcuJyArIGV4dGVuc2lvbik7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShpbnB1dCkge1xcbiAgICAgICAgICAgIGlucHV0ID0gcmVtb3ZlRG91YmxlU2xhc2hlcyhpbnB1dCk7XFxuICAgICAgICAgICAgaW5wdXQgPSByZW1vdmVQYXJlbnRQYXRocyhpbnB1dCk7XFxuICAgICAgICAgICAgaW5wdXQgPSByZW1vdmVDdXJyZW50UGF0aHMoaW5wdXQpO1xcblxcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZURvdWJsZVNsYXNoZXMoaW5wdXQpIHtcXG4gICAgICAgICAgICB2YXIgcHJlZml4RW5kID0gaW5wdXQuaW5kZXhPZignOi8vJykgPiAtMSA/IGlucHV0LmluZGV4T2YoJzovLycpICsgMyA6IDA7XFxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGlucHV0LnN1YnN0cmluZygwLCBwcmVmaXhFbmQpO1xcbiAgICAgICAgICAgIHZhciBpbnB1dFBhdGggPSBpbnB1dC5zdWJzdHJpbmcocHJlZml4RW5kKTtcXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgaW5wdXRQYXRoLnJlcGxhY2UoL1xcXFwvezIsfS9nLCAnLycpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGFyZW50UGF0aHMoaW5wdXQpIHtcXG4gICAgICAgICAgICB2YXIgcmVnZXggPSAvW15cXFxcL1xcXFwuXStcXFxcL1xcXFwuXFxcXC5cXFxcLy87XFxuXFxuICAgICAgICAgICAgd2hpbGUgKGlucHV0Lm1hdGNoKHJlZ2V4KSlcXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKHJlZ2V4LCAnJyk7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ3VycmVudFBhdGhzKGlucHV0KSB7XFxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL1xcXFwuXFxcXC8vZztcXG4gICAgICAgICAgICAvLyBJZ25vcmUgbGVhZGluZyBwYXJlbnQgcGF0aHMgLSB0aGUgcmVzdCB3aWxsIGhhdmUgYmVlbiBzdHJpcHBlZFxcbiAgICAgICAgICAgIC8vIEkgY2FuJ3QgZmlndXJlIG91dCBhIHJlZ2V4IHRoYXQgd29uJ3Qgc3RyaXAgdGhlIC4vIG91dCBvZiAuLi9cXG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGlucHV0Lmxhc3RJbmRleE9mKCcuLi8nKTtcXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSAtMSA/IDAgOiBzdGFydEluZGV4ICsgMztcXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXgpICsgaW5wdXQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLnJlcGxhY2UocmVnZXgsICcnKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvUGF0aC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIC8vIFRoaXMgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIG1vZHVsZXMgZnJvbSB0aGUgWVVJIExpYnJhcnkgLSBcXG4gICAgLy8gaHR0cDovL3l1aWxpYnJhcnkuY29tL3l1aS9kb2NzL2FwaS9maWxlcy9xdWVyeXN0cmluZ19qc19xdWVyeXN0cmluZy1wYXJzZS5qcy5odG1sXFxuICAgIC8vIEVpdGhlciBpdCBzaG91bGQgYmUgcmV3cml0dGVuIG9yIGF0dHJpYnV0aW9uIGFuZCBsaWNlbnNpbmcgYmUgYXZhaWxhYmxlIGhlcmUgYW5kIG9uIHRoZSB3ZWJzaXRlIGxpa2UgaW4gaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXFxuXFxuICAgIFQuVXRpbHMuUXVlcnlzdHJpbmcgPSBULlV0aWxzLlF1ZXJ5c3RyaW5nIHx8IHt9O1xcblxcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgc2VwZXJhdG9yLCBlcVN5bWJvbCkge1xcbiAgICAgICAgc3RyaXBMZWFkSW4oKTtcXG4gICAgICAgIFxcbiAgICAgICAgcmV0dXJuIFQuVXRpbHMucmVkdWNlKFxcbiAgICAgICAgICAgIFQuVXRpbHMubWFwKFxcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3BsaXQoc2VwZXJhdG9yIHx8IFxcXCImXFxcIiksXFxuICAgICAgICAgICAgICAgIHBpZWNlUGFyc2VyKGVxU3ltYm9sIHx8IFxcXCI9XFxcIilcXG4gICAgICAgICAgICApLFxcbiAgICAgICAgICAgIHt9LFxcbiAgICAgICAgICAgIG1lcmdlUGFyYW1zXFxuICAgICAgICApO1xcblxcbiAgICAgICAgZnVuY3Rpb24gc3RyaXBMZWFkSW4oKSB7XFxuICAgICAgICAgICAgaWYoc291cmNlLmxlbmd0aCA+IDAgJiYgc291cmNlLmNoYXJBdCgwKSA9PT0gJz8nKVxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKDEpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUocykge1xcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzLnJlcGxhY2UoL1xcXFwrL2csICcgJykpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBwaWVjZVBhcnNlcihlcSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlUGllY2Uoa2V5LCB2YWwpIHtcXG5cXG4gICAgICAgICAgICB2YXIgc2xpY2VkLCBudW1WYWwsIGhlYWQsIHRhaWwsIHJldDtcXG5cXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xcbiAgICAgICAgICAgICAgICAvLyBrZXk9dmFsLCBjYWxsZWQgZnJvbSB0aGUgbWFwL3JlZHVjZVxcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3BsaXQoZXEpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VQaWVjZShcXG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlKGtleS5zaGlmdCgpKSxcXG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlKGtleS5qb2luKGVxKSksXFxuICAgICAgICAgICAgICAgICAgICB0cnVlXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZywgJycpO1xcbiAgICAgICAgICAgIGlmICh2YWwuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKTtcXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBudW1lcmFscyB0byBudW1iZXJzXFxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbnVtVmFsID0gK3ZhbDtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bVZhbC50b1N0cmluZygxMCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBudW1WYWw7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgc2xpY2VkID0gLyguKilcXFxcWyhbXlxcXFxdXSopXFxcXF0kLy5leGVjKGtleSk7XFxuICAgICAgICAgICAgaWYgKCFzbGljZWQpIHtcXG4gICAgICAgICAgICAgICAgcmV0ID0ge307XFxuICAgICAgICAgICAgICAgIGlmIChrZXkpXFxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgLy8gW1xcXCJmb29bXVtiYXJdW11bYmF6XVxcXCIsIFxcXCJmb29bXVtiYXJdW11cXFwiLCBcXFwiYmF6XFxcIl1cXG4gICAgICAgICAgICB0YWlsID0gc2xpY2VkWzJdO1xcbiAgICAgICAgICAgIGhlYWQgPSBzbGljZWRbMV07XFxuXFxuICAgICAgICAgICAgLy8gYXJyYXk6IGtleVtdPXZhbFxcbiAgICAgICAgICAgIGlmICghdGFpbClcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGllY2UoaGVhZCwgW3ZhbF0sIHRydWUpO1xcblxcbiAgICAgICAgICAgIC8vIG9iamVjdDoga2V5W3N1YmtleV09dmFsXFxuICAgICAgICAgICAgcmV0ID0ge307XFxuICAgICAgICAgICAgcmV0W3RhaWxdID0gdmFsO1xcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBpZWNlKGhlYWQsIHJldCwgdHJ1ZSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8vIHRoZSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVhY2ggcXVlcnkgcGllY2UgdG9nZXRoZXIgaW50byBvbmUgc2V0IG9mIHBhcmFtc1xcbiAgICBmdW5jdGlvbiBtZXJnZVBhcmFtcyhwYXJhbXMsIGFkZGl0aW9uKSB7XFxuICAgICAgICByZXR1cm4gKFxcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgdW5jb250ZXN0ZWQsIHRoZW4ganVzdCByZXR1cm4gdGhlIGFkZGl0aW9uLlxcbiAgICAgICAgICAgICghcGFyYW1zKSA/IGFkZGl0aW9uXFxuICAgICAgICAgICAgLy8gaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIGNvbmNhdCBpdC5cXG4gICAgICAgICAgICA6ICgkLmlzQXJyYXkocGFyYW1zKSkgPyBwYXJhbXMuY29uY2F0KGFkZGl0aW9uKVxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgYW4gYXJyYXksIGFuZCBlaXRoZXIgYXJlIG5vdCBvYmplY3RzLCBhcnJheWlmeSBpdC5cXG4gICAgICAgICAgICA6ICghJC5pc1BsYWluT2JqZWN0KHBhcmFtcykgfHwgISQuaXNQbGFpbk9iamVjdChhZGRpdGlvbikpID8gW3BhcmFtc10uY29uY2F0KGFkZGl0aW9uKVxcbiAgICAgICAgICAgIC8vIGVsc2UgbWVyZ2UgdGhlbSBhcyBvYmplY3RzLCB3aGljaCBpcyBhIGxpdHRsZSBtb3JlIGNvbXBsZXhcXG4gICAgICAgICAgICA6IG1lcmdlT2JqZWN0cyhwYXJhbXMsIGFkZGl0aW9uKVxcbiAgICAgICAgKTtcXG4gICAgfVxcblxcbiAgICAvLyBNZXJnZSB0d28gKm9iamVjdHMqIHRvZ2V0aGVyLiBJZiB0aGlzIGlzIGNhbGxlZCwgd2UndmUgYWxyZWFkeSBydWxlZFxcbiAgICAvLyBvdXQgdGhlIHNpbXBsZSBjYXNlcywgYW5kIG5lZWQgdG8gZG8gdGhlIGZvci1pbiBidXNpbmVzcy5cXG4gICAgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKHBhcmFtcywgYWRkaXRpb24pIHtcXG4gICAgICAgIGZvciAodmFyIGkgaW4gYWRkaXRpb24pXFxuICAgICAgICAgICAgaWYgKGkgJiYgYWRkaXRpb24uaGFzT3duUHJvcGVydHkoaSkpXFxuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IG1lcmdlUGFyYW1zKHBhcmFtc1tpXSwgYWRkaXRpb25baV0pO1xcblxcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcXG4gICAgfVxcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9xdWVyeXN0cmluZy5wYXJzZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIC8vIFRoaXMgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIG1vZHVsZXMgZnJvbSB0aGUgWVVJIExpYnJhcnkgLSBcXG4gICAgLy8gaHR0cDovL3l1aWxpYnJhcnkuY29tL3l1aS9kb2NzL2FwaS9maWxlcy9xdWVyeXN0cmluZ19qc19xdWVyeXN0cmluZy1zdHJpbmdpZnkuanMuaHRtbFxcbiAgICAvLyBFaXRoZXIgaXQgc2hvdWxkIGJlIHJld3JpdHRlbiBvciBhdHRyaWJ1dGlvbiBhbmQgbGljZW5zaW5nIGJlIGF2YWlsYWJsZSBoZXJlIGFuZCBvbiB0aGUgd2Vic2l0ZSBsaWtlIGluIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xcblxcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nID0gVC5VdGlscy5RdWVyeXN0cmluZyB8fCB7fTtcXG5cXG4gICAgdmFyIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcXG5cXG4gICAgVC5VdGlscy5RdWVyeXN0cmluZy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XFxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHNvdXJjZSwgb3B0aW9ucyk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShzb3VyY2UsIG9wdGlvbnMsIG5hbWUsIHN0YWNrKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIHN0YWNrID0gc3RhY2sgfHwgW107XFxuICAgICAgICB2YXIgYmVnaW4sIGVuZCwgaSwgbCwgbiwgcztcXG4gICAgICAgIHZhciBzZXAgPSBvcHRpb25zLnNlcGVyYXRvciB8fCBcXFwiJlxcXCI7XFxuICAgICAgICB2YXIgZXEgPSBvcHRpb25zLmVxU3ltYm9sIHx8IFxcXCI9XFxcIjtcXG4gICAgICAgIHZhciBhcnJheUtleSA9IG9wdGlvbnMuYXJyYXlLZXkgIT09IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgIHJldHVybiBuYW1lID8gZXNjYXBlKG5hbWUpICsgZXEgOiAnJztcXG5cXG4gICAgICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IgPT09IEJvb2xlYW4gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNvdXJjZSkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJylcXG4gICAgICAgICAgICBzb3VyY2UgPSArc291cmNlO1xcblxcbiAgICAgICAgaWYgKCFpc05hTihzb3VyY2UpIHx8IHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGUobmFtZSkgKyBlcSArIGVzY2FwZShzb3VyY2UpO1xcblxcbiAgICAgICAgaWYgKCQuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgICAgICAgcyA9IFtdO1xcbiAgICAgICAgICAgIG5hbWUgPSBhcnJheUtleSA/IG5hbWUgKyAnW10nIDogbmFtZTtcXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgICAgICBzLnB1c2goc3RyaW5naWZ5KHNvdXJjZVtpXSwgb3B0aW9ucywgbmFtZSwgc3RhY2spKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHMuam9pbihzZXApO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICAvLyBub3cgd2Uga25vdyBpdCdzIGFuIG9iamVjdC5cXG4gICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWNhbCByZWZlcmVuY2VzIGluIG5lc3RlZCBvYmplY3RzXFxuICAgICAgICBmb3IgKGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcXG4gICAgICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHNvdXJjZSlcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJULlV0aWxzLlF1ZXJ5c3RyaW5nLnN0cmluZ2lmeTogY3ljbGljYWwgcmVmZXJlbmNlXFxcIik7XFxuXFxuICAgICAgICBzdGFjay5wdXNoKHNvdXJjZSk7XFxuICAgICAgICBzID0gW107XFxuICAgICAgICBiZWdpbiA9IG5hbWUgPyBuYW1lICsgJ1snIDogJyc7XFxuICAgICAgICBlbmQgPSBuYW1lID8gJ10nIDogJyc7XFxuICAgICAgICBmb3IgKGkgaW4gc291cmNlKSB7XFxuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICBuID0gYmVnaW4gKyBpICsgZW5kO1xcbiAgICAgICAgICAgICAgICBzLnB1c2goc3RyaW5naWZ5KHNvdXJjZVtpXSwgb3B0aW9ucywgbiwgc3RhY2spKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdGFjay5wb3AoKTtcXG4gICAgICAgIHMgPSBzLmpvaW4oc2VwKTtcXG4gICAgICAgIGlmICghcyAmJiBuYW1lKVxcbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgXFxcIj1cXFwiO1xcblxcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQuVHlwZXMuRmxvdyA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uU291cmNlLCBkZWZpbml0aW9uKSB7XFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgICAgICB0aGlzLm5vZGUgPSBuYXZpZ2F0aW9uTm9kZSgpO1xcbiAgICAgICAgdGhpcy5wdWJzdWIgPSB0aGlzLm5vZGUucGFuZS5wdWJzdWIub3duZXI7XFxuICAgICAgICB0aGlzLnNhZ2FzID0gW107XFxuXFxuICAgICAgICBkZWZpbml0aW9uID0gY3JlYXRlRGVmaW5pdGlvbihzZWxmLCBkZWZpbml0aW9uKTtcXG4gICAgICAgIHRoaXMuc2FnYSA9IG5ldyBUcmliZS5QdWJTdWIuU2FnYSh0aGlzLnB1YnN1YiwgZGVmaW5pdGlvbik7XFxuXFxuICAgICAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oZGF0YSkge1xcbiAgICAgICAgICAgIHNlbGYuc2FnYS5zdGFydChkYXRhKTtcXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgICAgICBzZWxmLnNhZ2EuZW5kKGRhdGEpO1xcbiAgICAgICAgICAgIFQuVXRpbHMuZWFjaChzZWxmLnNhZ2FzLCBmdW5jdGlvbihzYWdhKSB7XFxuICAgICAgICAgICAgICAgIHNhZ2EuZW5kKGRhdGEpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIG5hdmlnYXRpb25Ob2RlKCkge1xcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uU291cmNlLmNvbnN0cnVjdG9yID09PSBULlR5cGVzLk5vZGUpXFxuICAgICAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0aW9uU291cmNlLmZpbmROYXZpZ2F0aW9uKCkubm9kZTtcXG4gICAgICAgICAgICBpZiAobmF2aWdhdGlvblNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5QYW5lKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvblNvdXJjZS5ub2RlLmZpbmROYXZpZ2F0aW9uKCkubm9kZTtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIm5hdmlnYXRpb25Tb3VyY2UgbXVzdCBiZSBlaXRoZXIgVC5UeXBlcy5QYW5lIG9yIFQuVHlwZXMuTm9kZVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLnN0YXJ0Q2hpbGQgPSBmdW5jdGlvbihkZWZpbml0aW9uLCBkYXRhKSB7XFxuICAgICAgICBkZWZpbml0aW9uID0gY3JlYXRlRGVmaW5pdGlvbih0aGlzLCBkZWZpbml0aW9uKTtcXG4gICAgICAgIHRoaXMuc2FnYS5zdGFydENoaWxkKGRlZmluaXRpb24sIGRhdGEpO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xcbiAgICAgICAgdGhpcy5ub2RlLm5hdmlnYXRlKHBhdGhPck9wdGlvbnMsIGRhdGEpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgLy8gVGhpcyBrZWVwcyBhIHNlcGFyYXRlIGNvbGxlY3Rpb24gb2Ygc2FnYXMgYm91bmQgdG8gdGhpcyBmbG93J3MgbGlmZXRpbWVcXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSB0byBtYWtlIHRoZW0gY2hpbGRyZW4gb2YgdGhlIHVuZGVybHlpbmcgc2FnYSwgYnV0XFxuICAgIC8vIHRoZW4gdGhleSB3b3VsZCBlbmQgYW55IHRpbWUgYSBtZXNzYWdlIHdhcyBleGVjdXRlZC5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydFNhZ2EgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICAgICAgdmFyIHNhZ2EgPSB0aGlzLnB1YnN1Yi5zdGFydFNhZ2EoZGVmaW5pdGlvbiwgZGF0YSk7XFxuICAgICAgICB0aGlzLnNhZ2FzLnB1c2goc2FnYSk7XFxuICAgICAgICByZXR1cm4gc2FnYTtcXG4gICAgfTtcXG5cXG4gICAgLy8gZmxvdyBoZWxwZXJzXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLmVuZHNBdCA9IGZ1bmN0aW9uIChwYXRoT3JPcHRpb25zLCBkYXRhKSB7XFxuICAgICAgICB2YXIgZmxvdyA9IHRoaXM7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGZsb3cubm9kZS5uYXZpZ2F0ZShwYXRoT3JPcHRpb25zLCBkYXRhKTtcXG4gICAgICAgICAgICBmbG93LmVuZCgpO1xcbiAgICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZsb3csIGRhdGEpIHtcXG4gICAgICAgIHZhciB0aGlzRmxvdyA9IHRoaXM7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgdGhpc0Zsb3cuc3RhcnRDaGlsZChmbG93LCBkYXRhKTtcXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuXFxuICAgIC8vIFRoaXMgaXMgcmV1c2VkIGJ5IE5vZGUgYW5kIFBhbmVcXG4gICAgVC5UeXBlcy5GbG93LnN0YXJ0RmxvdyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBkYXRhKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFQuVHlwZXMuRmxvdyh0aGlzLCBkZWZpbml0aW9uKS5zdGFydChkYXRhKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24oZmxvdywgZGVmaW5pdGlvbikge1xcbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuZXcgZGVmaW5pdGlvbihmbG93KTtcXG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xcbiAgICB9XFxufSkoKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvRmxvdy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuSGlzdG9yeSA9IGZ1bmN0aW9uIChoaXN0b3J5KSB7XFxuICAgIHZhciBjdXJyZW50U3RhdGUgPSAwO1xcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIHdpbmRvdy50aXRsZSk7XFxuXFxuICAgIHZhciBwb3BBY3Rpb25zID0ge1xcbiAgICAgICAgcmFpc2VFdmVudDogZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBULlV0aWxzLnJhaXNlRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIHsgY291bnQ6IChlLnN0YXRlIC0gY3VycmVudFN0YXRlKSB9KTtcXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBlLnN0YXRlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHVwZGF0ZVN0YWNrOiBmdW5jdGlvbihlKSB7XFxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZS5zdGF0ZTtcXG4gICAgICAgICAgICBjdXJyZW50QWN0aW9uID0gcG9wQWN0aW9ucy5yYWlzZUV2ZW50O1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICB2YXIgY3VycmVudEFjdGlvbiA9IHBvcEFjdGlvbnMucmFpc2VFdmVudDtcXG5cXG4gICAgLy8gdGhpcyBsZWF2ZXMgSUU3ICYgOCBoaWdoIGFuZCBkcnkuIFdlJ2xsIHByb2JhYmx5IHJlcXVpcmUgYSBwb2x5ZmlsbCBhbmQgY3JlYXRlIGEgZ2VuZXJpYyBldmVudCBzdWJzY3JpcHRpb24gbWV0aG9kXFxuICAgIGlmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKVxcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZXhlY3V0ZUN1cnJlbnRBY3Rpb24pO1xcblxcbiAgICBmdW5jdGlvbiBleGVjdXRlQ3VycmVudEFjdGlvbihlKSB7XFxuICAgICAgICBpZiAoZS5zdGF0ZSAhPT0gbnVsbCkgY3VycmVudEFjdGlvbihlKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKHVybE9wdGlvbnMpIHtcXG4gICAgICAgIHVybE9wdGlvbnMgPSB1cmxPcHRpb25zIHx8IHt9O1xcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoKytjdXJyZW50U3RhdGUsIHVybE9wdGlvbnMudGl0bGUsIHVybE9wdGlvbnMudXJsKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5nbyA9IGZ1bmN0aW9uKGZyYW1lQ291bnQpIHtcXG4gICAgICAgIGhpc3RvcnkuZ28oZnJhbWVDb3VudCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oZnJhbWVDb3VudCkge1xcbiAgICAgICAgY3VycmVudEFjdGlvbiA9IHBvcEFjdGlvbnMudXBkYXRlU3RhY2s7XFxuICAgICAgICBoaXN0b3J5LmdvKGZyYW1lQ291bnQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBleGVjdXRlQ3VycmVudEFjdGlvbik7XFxuICAgIH07XFxufTtcXG5cXG5pZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKVxcbiAgICBULmhpc3RvcnkgPSBuZXcgVC5UeXBlcy5IaXN0b3J5KHdpbmRvdy5oaXN0b3J5KTtcXG5lbHNlXFxuICAgIFQuaGlzdG9yeSA9IG5ldyBULlR5cGVzLkhpc3Rvcnkoe1xcbiAgICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7IH1cXG4gICAgfSk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL0hpc3RvcnkuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLkxvYWRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgcmVzb3VyY2VzID0ge307XFxuXFxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24odXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcXG4gICAgICAgIGlmIChyZXNvdXJjZXNbdXJsXSAhPT0gdW5kZWZpbmVkKVxcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXNbdXJsXTtcXG5cXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBULlBhdGgodXJsKS5leHRlbnNpb24oKS50b1N0cmluZygpO1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBULkxvYWRIYW5kbGVyc1tleHRlbnNpb25dO1xcblxcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlcih1cmwsIHJlc291cmNlUGF0aCwgY29udGV4dCk7XFxuICAgICAgICAgICAgcmVzb3VyY2VzW3VybF0gPSByZXN1bHQ7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgJC53aGVuKHJlc3VsdCkuYWx3YXlzKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXNvdXJjZXNbdXJsXSA9IG51bGw7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFQubG9nZ2VyLndhcm4oXFxcIlJlc291cmNlIG9mIHR5cGUgXFxcIiArIGV4dGVuc2lvbiArIFxcXCIgYnV0IG5vIGhhbmRsZXIgcmVnaXN0ZXJlZC5cXFwiKTtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9O1xcbn07XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL0xvYWRlci5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XFxuICAgIG5vcm1hbGlzZU9wdGlvbnMoKTtcXG4gICAgc2V0SW5pdGlhbFBhbmVTdGF0ZSgpO1xcblxcbiAgICB2YXIgc3RhY2sgPSBbaW5pdGlhbFN0YWNrSXRlbSgpXTtcXG4gICAgdmFyIGN1cnJlbnRGcmFtZSA9IDA7XFxuXFxuICAgIHRoaXMubm9kZSA9IG5vZGU7XFxuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcXG5cXG4gICAgdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYW5lT3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvd3NlcilcXG4gICAgICAgICAgICBULmhpc3RvcnkubmF2aWdhdGUob3B0aW9ucy5icm93c2VyICYmIG9wdGlvbnMuYnJvd3Nlci51cmxEYXRhRnJvbShwYW5lT3B0aW9ucykpO1xcblxcbiAgICAgICAgdHJpbVN0YWNrKCk7XFxuICAgICAgICBzdGFjay5wdXNoKHBhbmVPcHRpb25zKTtcXG4gICAgICAgIGN1cnJlbnRGcmFtZSsrO1xcblxcbiAgICAgICAgbmF2aWdhdGVUbyhwYW5lT3B0aW9ucyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuaXNBdFN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lID09PSAwO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmdvID0gZnVuY3Rpb24oZnJhbWVDb3VudCkge1xcbiAgICAgICAgZ28oZnJhbWVDb3VudCk7XFxuICAgICAgICBpZiAob3B0aW9ucy5icm93c2VyKSBULmhpc3RvcnkudXBkYXRlKGZyYW1lQ291bnQpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgaWYob3B0aW9ucy5icm93c2VyKSBULlV0aWxzLmhhbmRsZURvY3VtZW50RXZlbnQoJ2Jyb3dzZXIuZ28nLCBvbkJyb3dzZXJHbyk7XFxuICAgIGZ1bmN0aW9uIG9uQnJvd3NlckdvKGUpIHtcXG4gICAgICAgIGdvKGUuZXZlbnREYXRhLmNvdW50KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnbyhmcmFtZUNvdW50KSB7XFxuICAgICAgICB2YXIgbmV3RnJhbWUgPSBjdXJyZW50RnJhbWUgKyBmcmFtZUNvdW50O1xcbiAgICAgICAgaWYgKG5ld0ZyYW1lIDwgMCkgbmV3RnJhbWUgPSAwO1xcbiAgICAgICAgaWYgKG5ld0ZyYW1lID49IHN0YWNrLmxlbmd0aCkgbmV3RnJhbWUgPSBzdGFjay5sZW5ndGggLSAxO1xcblxcbiAgICAgICAgaWYgKG5ld0ZyYW1lICE9IGN1cnJlbnRGcmFtZSlcXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvKHN0YWNrW25ld0ZyYW1lXSwgZnJhbWVDb3VudCA8IDApO1xcblxcbiAgICAgICAgY3VycmVudEZyYW1lID0gbmV3RnJhbWU7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVUbyhwYW5lT3B0aW9ucywgcmV2ZXJzZSkge1xcbiAgICAgICAgVC5VdGlscy5yYWlzZURvY3VtZW50RXZlbnQoJ25hdmlnYXRpbmcnLCB7IG5vZGU6IG5vZGUsIG9wdGlvbnM6IHBhbmVPcHRpb25zLCBicm93c2VyRGF0YTogb3B0aW9ucy5icm93c2VyRGF0YSB9KTtcXG4gICAgICAgIG5vZGUudHJhbnNpdGlvblRvKHBhbmVPcHRpb25zLCBvcHRpb25zLnRyYW5zaXRpb24sIHJldmVyc2UpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHRyaW1TdGFjaygpIHtcXG4gICAgICAgIHN0YWNrLnNwbGljZShjdXJyZW50RnJhbWUgKyAxLCBzdGFjay5sZW5ndGgpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgVC5VdGlscy5kZXRhY2hEb2N1bWVudEV2ZW50KCdicm93c2VyLmdvJywgb25Ccm93c2VyR28pO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlT3B0aW9ucygpIHtcXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT09IFN0cmluZylcXG4gICAgICAgICAgICBvcHRpb25zID0geyB0cmFuc2l0aW9uOiBvcHRpb25zIH07XFxuICAgICAgICBpZiAob3B0aW9ucy5icm93c2VyID09PSB0cnVlKVxcbiAgICAgICAgICAgIG9wdGlvbnMuYnJvd3NlciA9IFQub3B0aW9ucy5kZWZhdWx0VXJsUHJvdmlkZXI7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIHNldEluaXRpYWxQYW5lU3RhdGUoKSB7XFxuICAgICAgICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5tYXRjaCgvXFxcXCMuKi8pO1xcbiAgICAgICAgaWYgKHF1ZXJ5KSBxdWVyeSA9IHF1ZXJ5WzBdLnN1YnN0cmluZygxKTtcXG4gICAgICAgIHZhciB1cmxTdGF0ZSA9IG9wdGlvbnMuYnJvd3NlciAmJiBvcHRpb25zLmJyb3dzZXIucGFuZU9wdGlvbnNGcm9tKHF1ZXJ5KTtcXG4gICAgICAgIGlmICh1cmxTdGF0ZSkge1xcbiAgICAgICAgICAgIG5vZGUucGFuZS5wYXRoID0gdXJsU3RhdGUucGF0aDtcXG4gICAgICAgICAgICBub2RlLnBhbmUuZGF0YSA9IHVybFN0YXRlLmRhdGE7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIGluaXRpYWxTdGFja0l0ZW0oKSB7XFxuICAgICAgICByZXR1cm4geyBwYXRoOiBub2RlLnBhbmUucGF0aCwgZGF0YTogbm9kZS5wYW5lLmRhdGEgfTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL05hdmlnYXRpb24uanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLk5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBwYW5lKSB7XFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XFxuICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogdGhpcztcXG4gICAgdGhpcy5pZCA9IFQuVXRpbHMuZ2V0VW5pcXVlSWQoKTtcXG5cXG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XFxuICAgIGlmIChwYW5lKSB0aGlzLnNldFBhbmUocGFuZSk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPclBhbmUsIGRhdGEpIHtcXG4gICAgdmFyIHBhbmVPcHRpb25zID0gVC5VdGlscy5nZXRQYW5lT3B0aW9ucyhwYXRoT3JQYW5lLCB7IGRhdGE6IGRhdGEgfSk7XFxuICAgIGlmICghVC5QYXRoKHBhbmVPcHRpb25zLnBhdGgpLmlzQWJzb2x1dGUoKSlcXG4gICAgICAgIC8vIHRoaXMgaXMgZHVwbGljYXRlZCBpbiBQYW5lLmluaGVyaXRQYXRoRnJvbSAtIHRoZSBjb25jZXB0IChyZWxhdGl2ZSBwYXRocyBpbmhlcml0IGV4aXN0aW5nIHBhdGhzKSBuZWVkcyB0byBiZSBjbGVhcmVyXFxuICAgICAgICBwYW5lT3B0aW9ucy5wYXRoID0gVC5QYXRoKHRoaXMubm9kZUZvclBhdGgoKS5wYW5lLnBhdGgpLndpdGhvdXRGaWxlbmFtZSgpLmNvbWJpbmUocGFuZU9wdGlvbnMucGF0aCkudG9TdHJpbmcoKTtcXG4gICAgXFxuICAgIHRoaXMuZmluZE5hdmlnYXRpb24oKS5uYXZpZ2F0ZShwYW5lT3B0aW9ucyk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5maW5kTmF2aWdhdGlvbigpLmdvKC0xKTtcXG59O1xcblxcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUuZmluZE5hdmlnYXRpb24gPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMuZGVmYXVsdE5hdmlnYXRpb24pXFxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TmF2aWdhdGlvbjtcXG5cXG4gICAgZWxzZSBpZiAodGhpcy5uYXZpZ2F0aW9uKVxcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbjtcXG4gICAgICAgIFxcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XFxuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgVC5UeXBlcy5OYXZpZ2F0aW9uKHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbjtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZmluZE5hdmlnYXRpb24oKTtcXG59O1xcblxcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24ocGFuZU9wdGlvbnMsIHRyYW5zaXRpb24sIHJldmVyc2UpIHtcXG4gICAgVC50cmFuc2l0aW9uKHRoaXMsIHRyYW5zaXRpb24sIHJldmVyc2UpLnRvKHBhbmVPcHRpb25zKTtcXG59O1xcblxcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUuc2V0UGFuZSA9IGZ1bmN0aW9uIChwYW5lKSB7XFxuICAgIGlmICh0aGlzLnBhbmUpXFxuICAgICAgICB0aGlzLnBhbmUubm9kZSA9IG51bGw7XFxuXFxuICAgIHBhbmUubm9kZSA9IHRoaXM7XFxuICAgIHRoaXMucGFuZSA9IHBhbmU7XFxuICAgIHRoaXMuc2tpcFBhdGggPSBwYW5lLnNraXBQYXRoO1xcblxcbiAgICBpZiAocGFuZS5oYW5kbGVzTmF2aWdhdGlvbikge1xcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmV3IFQuVHlwZXMuTmF2aWdhdGlvbih0aGlzLCBwYW5lLmhhbmRsZXNOYXZpZ2F0aW9uKTtcXG4gICAgICAgIFxcbiAgICAgICAgLy8gdGhpcyBzZXRzIHRoaXMgcGFuZSBhcyB0aGUgXFxcImRlZmF1bHRcXFwiLCBhY2Nlc3NpYmxlIGZyb20gcGFuZXMgb3V0c2lkZSB0aGUgdHJlZS4gRmlyc3QgaW4gYmVzdCBkcmVzc2VkLlxcbiAgICAgICAgdGhpcy5yb290LmRlZmF1bHROYXZpZ2F0aW9uID0gdGhpcy5yb290LmRlZmF1bHROYXZpZ2F0aW9uIHx8IHRoaXMubmF2aWdhdGlvbjtcXG4gICAgfVxcblxcbiAgICBwYW5lLmluaGVyaXRQYXRoRnJvbSh0aGlzLnBhcmVudCk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLm5vZGVGb3JQYXRoID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLnNraXBQYXRoICYmIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubm9kZUZvclBhdGgoKSA6IHRoaXM7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9PT0gdGhpcy5uYXZpZ2F0aW9uKVxcbiAgICAgICAgdGhpcy5yb290LmRlZmF1bHROYXZpZ2F0aW9uID0gbnVsbDtcXG5cXG4gICAgaWYgKHRoaXMucGFyZW50KVxcbiAgICAgICAgVC5VdGlscy5yZW1vdmVJdGVtKHRoaXMucGFyZW50LmNoaWxkcmVuLCB0aGlzKTtcXG5cXG4gICAgaWYgKHRoaXMucGFuZSAmJiB0aGlzLnBhbmUuZGlzcG9zZSkge1xcbiAgICAgICAgZGVsZXRlIHRoaXMucGFuZS5ub2RlO1xcbiAgICAgICAgdGhpcy5wYW5lLmRpc3Bvc2UoKTtcXG4gICAgfVxcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5zdGFydEZsb3cgPSBULlR5cGVzLkZsb3cuc3RhcnRGbG93O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9Ob2RlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5PcGVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIGluY29tcGxldGUgPSBbXTtcXG5cXG4gICAgdGhpcy5wcm9taXNlID0gJC5EZWZlcnJlZCgpO1xcblxcbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGlkKSB7XFxuICAgICAgICBpbmNvbXBsZXRlLnB1c2goaWQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgICBULlV0aWxzLnJlbW92ZUl0ZW0oaW5jb21wbGV0ZSwgaWQpO1xcbiAgICAgICAgaWYgKGluY29tcGxldGUubGVuZ3RoID09PSAwKVxcbiAgICAgICAgICAgIHNlbGYucHJvbWlzZS5yZXNvbHZlKCk7XFxuICAgIH07XFxuICAgIFxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL09wZXJhdGlvbi5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuUGFuZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgIFQuVXRpbHMuaW5oZXJpdE9wdGlvbnMob3B0aW9ucywgdGhpcywgWydwYXRoJywgJ2RhdGEnLCAnZWxlbWVudCcsICd0cmFuc2l0aW9uJywgJ3JldmVyc2VUcmFuc2l0aW9uSW4nLCAnaGFuZGxlc05hdmlnYXRpb24nLCAncHVic3ViJywgJ2lkJywgJ3NraXBQYXRoJ10pO1xcblxcbiAgICAvLyBldmVudHMgd2UgYXJlIGludGVyZXN0ZWQgaW4gaG9va2luZyBpbiB0byAtIHRoaXMgY291bGQgYmUgZG9uZSBjb21wbGV0ZWx5IGdlbmVyaWNhbGx5IGJ5IHRoZSBwaXBlbGluZVxcbiAgICB0aGlzLmlzID0ge1xcbiAgICAgICAgcmVuZGVyZWQ6ICQuRGVmZXJyZWQoKSxcXG4gICAgICAgIGRpc3Bvc2VkOiAkLkRlZmVycmVkKClcXG4gICAgfTsgICAgXFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPclBhbmUsIGRhdGEpIHtcXG4gICAgdGhpcy5ub2RlICYmIHRoaXMubm9kZS5uYXZpZ2F0ZShwYXRoT3JQYW5lLCBkYXRhKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUubmF2aWdhdGVCYWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLm5hdmlnYXRlQmFjaygpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQodGhpcy5lbGVtZW50KS5yZW1vdmUoKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5kaXNwb3NlKVxcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwb3NlKCk7XFxuXFxuICAgIGlmICh0aGlzLm5vZGUpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vZGUucGFuZTtcXG4gICAgICAgIHRoaXMubm9kZS5kaXNwb3NlKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZWxlbWVudClcXG4gICAgICAgIFQuVXRpbHMuY2xlYW5FbGVtZW50KHRoaXMuZWxlbWVudCk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmluaGVyaXRQYXRoRnJvbSA9IGZ1bmN0aW9uIChub2RlKSB7XFxuICAgIG5vZGUgPSBub2RlICYmIG5vZGUubm9kZUZvclBhdGgoKTtcXG4gICAgdmFyIHBhbmUgPSBub2RlICYmIG5vZGUucGFuZTsgICAgXFxuICAgIHZhciBwYXRoID0gVC5QYXRoKHRoaXMucGF0aCk7XFxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUoKSB8fCAhcGFuZSlcXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgubWFrZUFic29sdXRlKCkudG9TdHJpbmcoKTtcXG4gICAgZWxzZVxcbiAgICAgICAgdGhpcy5wYXRoID0gVC5QYXRoKHBhbmUucGF0aCkud2l0aG91dEZpbGVuYW1lKCkuY29tYmluZShwYXRoKS50b1N0cmluZygpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuICQodGhpcy5lbGVtZW50KS5maW5kKHNlbGVjdG9yKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuc3RhcnRSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQodGhpcy5lbGVtZW50KS5hZGRDbGFzcygnX19yZW5kZXJpbmcnKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuZW5kUmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKHRoaXMuZWxlbWVudCkucmVtb3ZlQ2xhc3MoJ19fcmVuZGVyaW5nJyk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gXFxcInsgcGF0aDogJ1xcXCIgKyB0aGlzLnBhdGggKyBcXFwiJyB9XFxcIjtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuc3RhcnRTYWdhID0gZnVuY3Rpb24ocGF0aCwgYXJncykge1xcbiAgICB2YXIgc2FnYSA9IFQuY29udGV4dCgpLnNhZ2FzW3BhdGhdO1xcbiAgICB0aGlzLnB1YnN1Yi5zdGFydFNhZ2EuYXBwbHkodGhpcy5wdWJzdWIsIFtzYWdhLmNvbnN0cnVjdG9yXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5zdGFydEZsb3cgPSBULlR5cGVzLkZsb3cuc3RhcnRGbG93O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9QYW5lLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5QaXBlbGluZSA9IGZ1bmN0aW9uIChldmVudHMsIGNvbnRleHQpIHtcXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24gKGV2ZW50c1RvRXhlY3V0ZSwgdGFyZ2V0KSB7XFxuICAgICAgICB2YXIgY3VycmVudEV2ZW50ID0gLTE7XFxuICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG4gICAgICAgIGV4ZWN1dGVOZXh0RXZlbnQoKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVOZXh0RXZlbnQoKSB7XFxuICAgICAgICAgICAgY3VycmVudEV2ZW50Kys7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFdmVudCA+PSBldmVudHNUb0V4ZWN1dGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudHNUb0V4ZWN1dGVbY3VycmVudEV2ZW50XTtcXG4gICAgICAgICAgICB2YXIgdGhpc0V2ZW50ID0gZXZlbnRzW2V2ZW50TmFtZV07XFxuXFxuICAgICAgICAgICAgaWYgKCF0aGlzRXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgVC5sb2dnZXIud2FybihcXFwiTm8gZXZlbnQgZGVmaW5lZCBmb3IgXFxcIiArIGV2ZW50TmFtZSk7XFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVOZXh0RXZlbnQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAkLndoZW4odGhpc0V2ZW50KHRhcmdldCwgY29udGV4dCkpXFxuICAgICAgICAgICAgICAgIC5kb25lKGV4ZWN1dGVOZXh0RXZlbnQpXFxuICAgICAgICAgICAgICAgIC5mYWlsKGhhbmRsZUZhaWx1cmUpO1xcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUZhaWx1cmUoKSB7XFxuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KCk7XFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXREZXNjcmlwdGlvbiA9IHRhcmdldCA/IHRhcmdldC50b1N0cmluZygpIDogXFxcImVtcHR5IHRhcmdldFxcXCI7XFxuICAgICAgICAgICAgICAgIFQubG9nZ2VyLmVycm9yKFxcXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgJ1xcXCIgKyBldmVudE5hbWUgKyBcXFwiJyBldmVudCBmb3IgXFxcIiArIHRhcmdldERlc2NyaXB0aW9uKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgfTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9QaXBlbGluZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuUmVzb3VyY2VzID0gZnVuY3Rpb24gKCkgeyB9O1xcblxcblQuVHlwZXMuUmVzb3VyY2VzLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChyZXNvdXJjZVBhdGgsIGNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XFxuICAgIHRoaXNbcmVzb3VyY2VQYXRoXSA9IHtcXG4gICAgICAgIGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3RvcixcXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge31cXG4gICAgfTtcXG4gICAgVC5sb2dnZXIuZGVidWcoXFxcIk1vZGVsIGxvYWRlZCBmb3IgXFxcIiArIHJlc291cmNlUGF0aCk7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvUmVzb3VyY2VzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5UZW1wbGF0ZXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy5zdG9yZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcGF0aCkge1xcbiAgICAgICAgdmFyIGlkID0gVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpLnRvU3RyaW5nKCk7XFxuICAgICAgICBlbWJlZFRlbXBsYXRlKHRlbXBsYXRlLCAndGVtcGxhdGUtJyArIGlkKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIGVtYmVkVGVtcGxhdGUodGVtcGxhdGUsIGlkKSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnX190cmliZSc7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L3RlbXBsYXRlJyk7XFxuICAgICAgICBlbGVtZW50LmlkID0gaWQ7XFxuICAgICAgICBlbGVtZW50LnRleHQgPSB0ZW1wbGF0ZTtcXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XFxuICAgIH1cXG4gICAgXFxuICAgIHRoaXMubG9hZGVkID0gZnVuY3Rpb24ocGF0aCkge1xcbiAgICAgICAgcmV0dXJuICQoJ2hlYWQgc2NyaXB0I3RlbXBsYXRlLScgKyBULlBhdGgocGF0aCkuYXNNYXJrdXBJZGVudGlmaWVyKCkpLmxlbmd0aCA+IDA7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcGF0aCkge1xcbiAgICAgICAgdmFyIGlkID0gVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpO1xcbiAgICAgICAgLy8gY2FuJ3QgdXNlIGh0bWwoKSB0byBhcHBlbmQgLSB0aGlzIHVzZXMgdGhlIGVsZW1lbnQgaW5uZXJIVE1MIHByb3BlcnR5IGFuZCBJRTcgYW5kIDggd2lsbCBzdHJpcCBjb21tZW50cyAoaS5lLiBjb250YWluZXJsZXNzIGNvbnRyb2wgZmxvdyBiaW5kaW5ncylcXG4gICAgICAgICQodGFyZ2V0KS5lbXB0eSgpLmFwcGVuZCgkKCdoZWFkIHNjcmlwdCN0ZW1wbGF0ZS0nICsgaWQpLmh0bWwoKSk7XFxuICAgIH07XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvVGVtcGxhdGVzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuYWN0aXZlID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgcmV0dXJuIFQuVXRpbHMuZWxlbWVudERlc3Ryb3llZChwYW5lLmVsZW1lbnQpO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9hY3RpdmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHZhciBkZWZpbml0aW9uID0gY29udGV4dC5tb2RlbHNbcGFuZS5wYXRoXTtcXG4gICAgdmFyIG1vZGVsID0gZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLmNvbnN0cnVjdG9yID9cXG4gICAgICAgIG5ldyBkZWZpbml0aW9uLmNvbnN0cnVjdG9yKHBhbmUpIDpcXG4gICAgICAgIHsgcGFuZTogcGFuZSwgZGF0YTogcGFuZS5kYXRhIH07XFxuXFxuICAgIFQuVXRpbHMuZW1iZWRTdGF0ZShtb2RlbCwgY29udGV4dCwgcGFuZS5ub2RlKTtcXG5cXG4gICAgcGFuZS5tb2RlbCA9IG1vZGVsO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9jcmVhdGVNb2RlbC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLmNyZWF0ZVB1YlN1YiA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIGlmIChjb250ZXh0LnB1YnN1YilcXG4gICAgICAgIHBhbmUucHVic3ViID0gY29udGV4dC5wdWJzdWIuY3JlYXRlTGlmZXRpbWUgP1xcbiAgICAgICAgICAgIGNvbnRleHQucHVic3ViLmNyZWF0ZUxpZmV0aW1lKCkgOlxcbiAgICAgICAgICAgIGNvbnRleHQucHVic3ViO1xcbn07XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9jcmVhdGVQdWJTdWIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5kaXNwb3NlID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgcGFuZS5wdWJzdWIgJiYgcGFuZS5wdWJzdWIuZW5kICYmIHBhbmUucHVic3ViLmVuZCgpO1xcbiAgICBwYW5lLmRpc3Bvc2UoKTtcXG4gICAgcGFuZS5pcy5kaXNwb3NlZC5yZXNvbHZlKCk7XFxufTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL2Rpc3Bvc2UuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5pbml0aWFsaXNlTW9kZWwgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAocGFuZS5tb2RlbC5pbml0aWFsaXNlKVxcbiAgICAgICAgcmV0dXJuIHBhbmUubW9kZWwuaW5pdGlhbGlzZSgpO1xcbiAgICByZXR1cm4gbnVsbDtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvaW5pdGlhbGlzZU1vZGVsLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMubG9hZFJlc291cmNlcyA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdHJhdGVneSA9IFQuTG9hZFN0cmF0ZWdpZXNbY29udGV4dC5vcHRpb25zLmxvYWRTdHJhdGVneV07XFxuICAgIFxcbiAgICBpZiAoIXN0cmF0ZWd5KVxcbiAgICAgICAgdGhyb3cgXFxcIlVua25vd24gcmVzb3VyY2UgbG9hZCBzdHJhdGVneVxcXCI7XFxuXFxuICAgIHJldHVybiBzdHJhdGVneShwYW5lLCBjb250ZXh0KTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvbG9hZFJlc291cmNlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLnJlbmRlckNvbXBsZXRlID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgJC53aGVuKFxcbiAgICAgICAgVC50cmFuc2l0aW9uKHBhbmUsIHBhbmUudHJhbnNpdGlvbiwgcGFuZS5yZXZlcnNlVHJhbnNpdGlvbkluKVsnaW4nXSgpKVxcbiAgICAgLmRvbmUoZXhlY3V0ZVJlbmRlckNvbXBsZXRlKTtcXG4gICAgXFxuICAgIHBhbmUuZW5kUmVuZGVyKCk7XFxuXFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVSZW5kZXJDb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmIChwYW5lLm1vZGVsLnJlbmRlckNvbXBsZXRlKVxcbiAgICAgICAgICAgIHBhbmUubW9kZWwucmVuZGVyQ29tcGxldGUoKTtcXG4gICAgICAgIHBhbmUuaXMucmVuZGVyZWQucmVzb2x2ZSgpO1xcbiAgICAgICAgVC5VdGlscy5yYWlzZURvY3VtZW50RXZlbnQoJ3JlbmRlckNvbXBsZXRlJywgcGFuZSk7XFxuICAgICAgICBjb250ZXh0LnJlbmRlck9wZXJhdGlvbiA9IG5ldyBULlR5cGVzLk9wZXJhdGlvbigpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL3JlbmRlckNvbXBsZXRlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMucmVuZGVyUGFuZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHZhciByZW5kZXJPcGVyYXRpb24gPSBjb250ZXh0LnJlbmRlck9wZXJhdGlvbjtcXG5cXG4gICAgcGFuZS5zdGFydFJlbmRlcigpO1xcbiAgICBjb250ZXh0LnRlbXBsYXRlcy5yZW5kZXIocGFuZS5lbGVtZW50LCBwYW5lLnBhdGgpO1xcbiAgICBULlV0aWxzLnRyeUNhdGNoKGFwcGx5QmluZGluZ3MsIG51bGwsIGNvbnRleHQub3B0aW9ucy5oYW5kbGVFeGNlcHRpb25zLCAnQW4gZXJyb3Igb2NjdXJyZWQgYXBwbHlpbmcgdGhlIGJpbmRpbmdzIGZvciAnICsgcGFuZS50b1N0cmluZygpKTtcXG5cXG4gICAgaWYgKHBhbmUubW9kZWwucGFuZVJlbmRlcmVkKVxcbiAgICAgICAgcGFuZS5tb2RlbC5wYW5lUmVuZGVyZWQoKTtcXG5cXG4gICAgcmVuZGVyT3BlcmF0aW9uLmNvbXBsZXRlKHBhbmUpO1xcbiAgICByZXR1cm4gcmVuZGVyT3BlcmF0aW9uLnByb21pc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3MoKSB7XFxuICAgICAgICBrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyhwYW5lLm1vZGVsLCBwYW5lLmVsZW1lbnQpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL3JlbmRlclBhbmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkxvYWRIYW5kbGVycy5qcyA9IGZ1bmN0aW9uICh1cmwsIHJlc291cmNlUGF0aCwgY29udGV4dCkge1xcbiAgICByZXR1cm4gJC5hamF4KHtcXG4gICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcXG4gICAgICAgIGFzeW5jOiAhY29udGV4dC5vcHRpb25zLnN5bmNocm9ub3VzLFxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxcbiAgICAgICAgc3VjY2VzczogZXhlY3V0ZVNjcmlwdFxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVNjcmlwdChzY3JpcHQpIHtcXG4gICAgICAgIFQuc2NyaXB0RW52aXJvbm1lbnQgPSB7XFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoOiByZXNvdXJjZVBhdGgsXFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIFQuVXRpbHMudHJ5Q2F0Y2goJC5nbG9iYWxFdmFsLCBbYXBwZW5kU291cmNlVXJsKHNjcmlwdCldLCBjb250ZXh0Lm9wdGlvbnMuaGFuZGxlRXhjZXB0aW9ucyxcXG4gICAgICAgICAgICAnQW4gZXJyb3Igb2NjdXJyZWQgZXhlY3V0aW5nIHNjcmlwdCBsb2FkZWQgZnJvbSAnICsgdXJsICsgKHJlc291cmNlUGF0aCA/ICcgZm9yIHJlc291cmNlICcgKyByZXNvdXJjZVBhdGggOiAnJykpO1xcblxcbiAgICAgICAgZGVsZXRlIFQuc2NyaXB0RW52aXJvbm1lbnQ7XFxuXFxuICAgICAgICBULmxvZ2dlci5kZWJ1ZygnTG9hZGVkIHNjcmlwdCBmcm9tICcgKyB1cmwpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGFwcGVuZFNvdXJjZVVybChzY3JpcHQpIHtcXG4gICAgICAgIHJldHVybiBzY3JpcHQgKyAnXFxcXG4vL0Agc291cmNlVVJMPXRyaWJlOi8vQXBwbGljYXRpb24vJyArIHVybC5yZXBsYWNlKC8gL2csIFxcXCJfXFxcIik7XFxuICAgIH0gICAgXFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZEhhbmRsZXJzL3NjcmlwdHMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkxvYWRIYW5kbGVycy5jc3MgPSBmdW5jdGlvbiAodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcXG4gICAgdmFyIHN1cHBvcnRzVGV4dE5vZGVzID0gdHJ1ZTtcXG4gICAgXFxuICAgIHJldHVybiAkLmFqYXgoe1xcbiAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxcbiAgICAgICAgYXN5bmM6ICFjb250ZXh0Lm9wdGlvbnMuc3luY2hyb25vdXMsXFxuICAgICAgICBjYWNoZTogZmFsc2UsXFxuICAgICAgICBzdWNjZXNzOiByZW5kZXJTdHlsZXNoZWV0XFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiByZW5kZXJTdHlsZXNoZWV0KHN0eWxlc2hlZXQpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fdHJpYmVTdHlsZXMnKTtcXG4gICAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xcbiAgICAgICAgICAgIGVsZW1lbnQuaWQgPSAnX190cmliZVN0eWxlcyc7XFxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChlbGVtZW50KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmKHN1cHBvcnRzVGV4dE5vZGVzKVxcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVzaGVldCkpO1xcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNUZXh0Tm9kZXMgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXN1cHBvcnRzVGV4dE5vZGVzKVxcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnN0eWxlU2hlZXQpIHtcXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgc3R5bGVTaGVldC5jc3NUZXh0IGlzIHJlcXVpcmVkIGZvciBJRTggc3VwcG9ydFxcbiAgICAgICAgICAgICAgICAvLyBJRTggYWxzbyBoYXMgYSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIDxzdHlsZS8+IGVsZW1lbnRzLCBzbyBhcHBlbmQgaXQgdG8gdGhlIHNhbWUgbm9kZVxcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCArPSBzdHlsZXNoZWV0O1xcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBhcHBlbmQgc3R5bGVzaGVldCBmb3IgJyArIHJlc291cmNlUGF0aCArICcgdG8gZG9jdW1lbnQuJyk7XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9Mb2FkSGFuZGxlcnMvc3R5bGVzaGVldHMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkxvYWRIYW5kbGVycy5odG0gPSBmdW5jdGlvbiAodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcXG4gICAgcmV0dXJuICQuYWpheCh7XFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGRhdGFUeXBlOiAnaHRtbCcsXFxuICAgICAgICBhc3luYzogIWNvbnRleHQub3B0aW9ucy5zeW5jaHJvbm91cyxcXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgIHN1Y2Nlc3M6IHN0b3JlVGVtcGxhdGVcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIHN0b3JlVGVtcGxhdGUodGVtcGxhdGUpIHtcXG4gICAgICAgIGNvbnRleHQudGVtcGxhdGVzLnN0b3JlKHRlbXBsYXRlLCByZXNvdXJjZVBhdGgpO1xcbiAgICB9XFxufTtcXG5ULkxvYWRIYW5kbGVycy5odG1sID0gVC5Mb2FkSGFuZGxlcnMuaHRtO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9Mb2FkSGFuZGxlcnMvdGVtcGxhdGVzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkU3RyYXRlZ2llcy5hZGhvYyA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIGlmIChjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gIT09IHVuZGVmaW5lZClcXG4gICAgICAgIHJldHVybiBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF07XFxuXFxuICAgIHZhciBwYXRoID0gVC5QYXRoKGNvbnRleHQub3B0aW9ucy5iYXNlUGF0aCkuY29tYmluZShULlBhdGgocGFuZS5wYXRoKS5tYWtlUmVsYXRpdmUoKSk7XFxuXFxuICAgIGlmIChjb250ZXh0LnRlbXBsYXRlcy5sb2FkZWQocGFuZS5wYXRoKSB8fCBjb250ZXh0Lm1vZGVsc1twYW5lLnBhdGhdKVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuXFxuICAgIHZhciBkZWZlcnJlZCA9ICQuY29tcGxldGUoW1xcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdqcycpLnRvU3RyaW5nKCksIHBhbmUucGF0aCwgY29udGV4dCksXFxuICAgICAgICBjb250ZXh0LmxvYWRlci5nZXQocGF0aC5zZXRFeHRlbnNpb24oJ2h0bScpLnRvU3RyaW5nKCksIHBhbmUucGF0aCwgY29udGV4dCksXFxuICAgICAgICBjb250ZXh0LmxvYWRlci5nZXQocGF0aC5zZXRFeHRlbnNpb24oJ2NzcycpLnRvU3RyaW5nKCksIHBhbmUucGF0aCwgY29udGV4dClcXG4gICAgXSk7XFxuXFxuICAgIGNvbnRleHQubG9hZGVkUGFuZXNbcGFuZS5wYXRoXSA9IGRlZmVycmVkO1xcblxcbiAgICAkLndoZW4oZGVmZXJyZWQpXFxuICAgICAgICAuZmFpbChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICBULmxvZ2dlci5lcnJvcihcXFwiVW5hYmxlIHRvIGxvYWQgcmVzb3VyY2VzIGZvciAnXFxcIiArIHBhbmUucGF0aCArIFxcXCInLlxcXCIpO1xcbiAgICAgICAgfSlcXG4gICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNvbnRleHQubG9hZGVkUGFuZXNbcGFuZS5wYXRoXSA9IG51bGw7XFxuICAgICAgICB9KTtcXG5cXG4gICAgcmV0dXJuIGRlZmVycmVkO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0xvYWRTdHJhdGVnaWVzL2FkaG9jLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkU3RyYXRlZ2llcy5wcmVsb2FkZWQgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAoIWNvbnRleHQubW9kZWxzW3BhbmUucGF0aF0gJiYgIWNvbnRleHQudGVtcGxhdGVzLmxvYWRlZChwYW5lLnBhdGgpKSB7XFxuICAgICAgICBULmxvZ2dlci5lcnJvcihcXFwiTm8gcmVzb3VyY2VzIGxvYWRlZCBmb3IgJ1xcXCIgKyBwYW5lLnBhdGggKyBcXFwiJy5cXFwiKTtcXG4gICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVqZWN0KCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZFN0cmF0ZWdpZXMvcHJlbG9hZGVkLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC50cmFuc2l0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgdHJhbnNpdGlvbiwgcmV2ZXJzZSkge1xcbiAgICB2YXIgbm9kZTtcXG4gICAgdmFyIHBhbmU7XFxuICAgIHZhciBlbGVtZW50O1xcbiAgICBzZXRTdGF0ZSgpO1xcbiAgICBcXG4gICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gfHwgKHBhbmUgJiYgcGFuZS50cmFuc2l0aW9uKSB8fCAobm9kZSAmJiBub2RlLnRyYW5zaXRpb24pO1xcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBULlRyYW5zaXRpb25zW3RyYW5zaXRpb25dO1xcbiAgICBpZiAocmV2ZXJzZSAmJiBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5yZXZlcnNlKVxcbiAgICAgICAgaW1wbGVtZW50YXRpb24gPSBULlRyYW5zaXRpb25zW2ltcGxlbWVudGF0aW9uLnJldmVyc2VdO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgICAgJ2luJzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICQoZWxlbWVudCkuc2hvdygpO1xcbiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvblsnaW4nXShlbGVtZW50KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXG4gICAgICAgIG91dDogZnVuY3Rpb24gKHJlbW92ZSkge1xcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Nb2RlKCk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5vdXQoZWxlbWVudCk7XFxuICAgICAgICAgICAgJC53aGVuKHByb21pc2UpLmRvbmUocmVtb3ZlRWxlbWVudCk7XFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkuaGlkZSgpLmF0dHIoJ3N0eWxlJywgJycpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkucmVtb3ZlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcbiAgICAgICAgdG86IGZ1bmN0aW9uIChwYW5lT3B0aW9ucywgcmVtb3ZlKSB7XFxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBULmNvbnRleHQoKTtcXG4gICAgICAgICAgICBpZiAobm9kZSlcXG4gICAgICAgICAgICAgICAgVC5VdGlscy5pbnNlcnRQYW5lQWZ0ZXIobm9kZSwgZWxlbWVudCwgVC5VdGlscy5nZXRQYW5lT3B0aW9ucyhwYW5lT3B0aW9ucywgeyB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLCByZXZlcnNlVHJhbnNpdGlvbkluOiByZXZlcnNlIH0pLCBjb250ZXh0KTtcXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIFQuaW5zZXJ0Tm9kZUFmdGVyKGVsZW1lbnQsIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGFuZU9wdGlvbnMsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgcmV2ZXJzZVRyYW5zaXRpb25JbjogcmV2ZXJzZSB9KSwgbnVsbCwgY29udGV4dCk7XFxuICAgICAgICAgICAgdGhpcy5vdXQocmVtb3ZlKTtcXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5yZW5kZXJPcGVyYXRpb24ucHJvbWlzZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIHNldFRyYW5zaXRpb25Nb2RlKCkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcXG4gICAgICAgIGlmIChULnRyYW5zaXRpb24ubW9kZSA9PT0gJ2ZpeGVkJylcXG4gICAgICAgICAgICAkZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcXG4gICAgICAgICAgICAgICAgd2lkdGg6ICRlbGVtZW50LndpZHRoKCksXFxuICAgICAgICAgICAgICAgIGxlZnQ6ICRlbGVtZW50Lm9mZnNldCgpLmxlZnQsXFxuICAgICAgICAgICAgICAgIHRvcDogJGVsZW1lbnQub2Zmc2V0KCkudG9wXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAkZWxlbWVudC53aWR0aCgpLFxcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZWxlbWVudC5wb3NpdGlvbigpLmxlZnQsXFxuICAgICAgICAgICAgICAgIHRvcDogJGVsZW1lbnQucG9zaXRpb24oKS50b3BcXG4gICAgICAgICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcXG4gICAgICAgIGlmICghdGFyZ2V0KSB0aHJvdyBcXFwiTm8gdGFyZ2V0IHBhc3NlZCB0byBULnRyYW5zaXRpb25cXFwiO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAodGFyZ2V0LmNvbnN0cnVjdG9yID09PSBULlR5cGVzLk5vZGUpIHtcXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0O1xcbiAgICAgICAgICAgIHBhbmUgPSBub2RlLnBhbmU7XFxuICAgICAgICAgICAgZWxlbWVudCA9IHBhbmUuZWxlbWVudDtcXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNvbnN0cnVjdG9yID09PSBULlR5cGVzLlBhbmUpIHtcXG4gICAgICAgICAgICBwYW5lID0gdGFyZ2V0O1xcbiAgICAgICAgICAgIG5vZGUgPSBwYW5lLm5vZGU7XFxuICAgICAgICAgICAgZWxlbWVudCA9IHBhbmUuZWxlbWVudDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZWxlbWVudCA9IHRhcmdldDtcXG4gICAgICAgIH1cXG4gICAgfSAgICBcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UcmFuc2l0aW9ucy90cmFuc2l0aW9uLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRzVHJhbnNpdGlvbnMoKTtcXG4gICAgXFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ2ZhZGUnKTtcXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVMZWZ0JywgJ3NsaWRlUmlnaHQnKTtcXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVSaWdodCcsICdzbGlkZUxlZnQnKTtcXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVVcCcsICdzbGlkZURvd24nKTtcXG4gICAgY3JlYXRlQ3NzVHJhbnNpdGlvbignc2xpZGVEb3duJywgJ3NsaWRlVXAnKTtcXG5cXG4gICAgdmFyIHRyYW5zaXRpb25FbmRFdmVudHMgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uZW5kIG1zVHJhbnNpdGlvbkVuZCc7XFxuXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNzc1RyYW5zaXRpb24odHJhbnNpdGlvbiwgcmV2ZXJzZSkge1xcbiAgICAgICAgVC5UcmFuc2l0aW9uc1t0cmFuc2l0aW9uXSA9IHtcXG4gICAgICAgICAgICAnaW4nOiBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRlZCkgcmV0dXJuIG51bGw7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5iaW5kKHRyYW5zaXRpb25FbmRFdmVudHMsIHRyYW5zaXRpb25FbmRlZChlbGVtZW50LCBwcm9taXNlKSlcXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygncHJlcGFyZSBpbiAnICsgdHJhbnNpdGlvbik7XFxuXFxuICAgICAgICAgICAgICAgIHRyaWdnZXIoZWxlbWVudCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgb3V0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRlZCkgcmV0dXJuIG51bGw7XFxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gJC5EZWZlcnJlZCgpO1xcblxcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKCdwcmVwYXJlIG91dCAnICsgdHJhbnNpdGlvbilcXG4gICAgICAgICAgICAgICAgICAgIC5vbih0cmFuc2l0aW9uRW5kRXZlbnRzLCB0cmFuc2l0aW9uRW5kZWQoZWxlbWVudCwgcHJvbWlzZSwgdHJ1ZSkpO1xcblxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHJldmVyc2U6IHJldmVyc2UgfHwgdHJhbnNpdGlvblxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXIoZWxlbWVudCkge1xcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKCd0cmlnZ2VyJyk7XFxuICAgICAgICAgICAgfSwgMzApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZGVkKGVsZW1lbnQsIHByb21pc2UsIGhpZGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgICQoZWxlbWVudCkudW5iaW5kKHRyYW5zaXRpb25FbmRFdmVudHMpXFxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModHJhbnNpdGlvbiArICcgaW4gb3V0IHByZXBhcmUgdHJpZ2dlcicpO1xcbiAgICAgICAgICAgICAgICBpZiAoaGlkZSkgJChlbGVtZW50KS5oaWRlKCk7XFxuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNpdGlvbnMoKSB7XFxuICAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcbiAgICAgICAgdmFyIHN0eWxlID0gYi5zdHlsZTtcXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9ICd0cmFuc2l0aW9uJztcXG4gICAgICAgIHZhciB2ZW5kb3JzID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcGVydHldID09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9XFxuXFxuICAgICAgICAvLyBUZXN0cyBmb3IgdmVuZG9yIHNwZWNpZmljIHByb3BcXG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZlbmRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVt2ZW5kb3JzW2ldICsgcHJvcGVydHldID09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1RyYW5zaXRpb25zL0Nzcy9jc3MuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5cXG4vL1xcbndpbmRvdy5fX2FwcGVuZFN0eWxlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX190cmliZVN0eWxlcycpO1xcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnX190cmliZSc7XFxuICAgICAgICBlbGVtZW50LmlkID0gJ19fdHJpYmVTdHlsZXMnO1xcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChlbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICBpZihlbGVtZW50LnN0eWxlU2hlZXQpXFxuICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCArPSBjb250ZW50O1xcbiAgICBlbHNlXFxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcXG59Oy8vXFxud2luZG93Ll9fYXBwZW5kU3R5bGUoJy50cmlnZ2Vyey13ZWJraXQtdHJhbnNpdGlvbjphbGwgMjUwbXMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgMjUwbXMgZWFzZS1pbi1vdXR9LmZhZGUuaW4ucHJlcGFyZXtvcGFjaXR5OjB9LmZhZGUuaW4udHJpZ2dlcntvcGFjaXR5OjF9LmZhZGUub3V0LnByZXBhcmV7b3BhY2l0eToxfS5mYWRlLm91dC50cmlnZ2Vye29wYWNpdHk6MH0uc2xpZGVSaWdodC5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKX0uc2xpZGVSaWdodC5pbi50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnNsaWRlUmlnaHQub3V0LnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKX0uc2xpZGVMZWZ0LmluLnByZXBhcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKX0uc2xpZGVMZWZ0LmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0uc2xpZGVMZWZ0Lm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKX0uc2xpZGVEb3duLmluLnByZXBhcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwMCUpfS5zbGlkZURvd24uaW4udHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfS5zbGlkZURvd24ub3V0LnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKX0uc2xpZGVVcC5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSl9LnNsaWRlVXAuaW4udHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfS5zbGlkZVVwLm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKX0nKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHJhbnNpdGlvbnMvQ3NzL3N0eWxlLmNzcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQucmVnaXN0ZXJNb2RlbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGFkZFJlc291cmNlKCdtb2RlbHMnLCBULlV0aWxzLmFyZ3VtZW50cyhhcmd1bWVudHMpKTtcXG4gICAgfTtcXG5cXG4gICAgVC5yZWdpc3RlclNhZ2EgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhZGRSZXNvdXJjZSgnc2FnYXMnLCBULlV0aWxzLmFyZ3VtZW50cyhhcmd1bWVudHMpKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIGFkZFJlc291cmNlKGNvbnRleHRQcm9wZXJ0eSwgYXJncykge1xcbiAgICAgICAgdmFyIGVudmlyb25tZW50ID0gVC5zY3JpcHRFbnZpcm9ubWVudCB8fCB7fTtcXG4gICAgICAgIHZhciBjb250ZXh0ID0gZW52aXJvbm1lbnQuY29udGV4dCB8fCBULmNvbnRleHQoKTtcXG5cXG4gICAgICAgIHZhciBwYXRoID0gYXJncy5zdHJpbmcgfHwgZW52aXJvbm1lbnQucmVzb3VyY2VQYXRoO1xcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYXJncy5mdW5jO1xcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9iamVjdDtcXG5cXG4gICAgICAgIGNvbnRleHRbY29udGV4dFByb3BlcnR5XS5yZWdpc3RlcihwYXRoLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XFxuICAgIH1cXG5cXG4gICAgVC5ydW4gPSBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgICAgICBULm9wdGlvbnMgPSAkLmV4dGVuZChULm9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgVC5vcHRpb25zLnB1YnN1YiA9IFQub3B0aW9ucy5wdWJzdWIgfHwgbmV3IFRyaWJlLlB1YlN1Yih7IHN5bmM6IFQub3B0aW9ucy5zeW5jaHJvbm91cywgaGFuZGxlRXhjZXB0aW9uczogVC5vcHRpb25zLmhhbmRsZUV4Y2VwdGlvbnMgfSk7XFxuICAgICAgICBrby5hcHBseUJpbmRpbmdzKCk7XFxuICAgICAgICAvL2lmIChwcmVsb2FkKSB7XFxuICAgICAgICAvLyAgICB2YXIgcHJvbWlzZXMgPSBbXTtcXG4gICAgICAgIC8vICAgIHZhciBjb250ZXh0ID0gVC5jb250ZXh0KCk7XFxuXFxuICAgICAgICAvLyAgICBpZiAoJC5pc0FycmF5KHByZWxvYWQpKVxcbiAgICAgICAgLy8gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJlbG9hZC5sZW5ndGg7IGkgPCBsOyBpKyspXFxuICAgICAgICAvLyAgICAgICAgICAgIGFkZFByb21pc2UocHJlbG9hZFtpXSk7XFxuICAgICAgICAvLyAgICBlbHNlIGlmKHByZWxvYWQuY29uc3RydWN0b3IgPT09IFN0cmluZylcXG4gICAgICAgIC8vICAgICAgICBhZGRQcm9taXNlKHByZWxvYWQpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgLy8gICAgZnVuY3Rpb24gYWRkUHJvbWlzZShwYXRoKSB7XFxuICAgICAgICAvLyAgICAgICAgcHJvbWlzZXMucHVzaChjb250ZXh0LmxvYWRlci5nZXQoVC5QYXRoKGNvbnRleHQub3B0aW9ucy5iYXNlUGF0aCkuY29tYmluZShwYXRoKS50b1N0cmluZygpLCBudWxsLCBjb250ZXh0KSk7XFxuICAgICAgICAvLyAgICB9XFxuXFxuICAgICAgICAvLyAgICByZXR1cm4gJC53aGVuLmFwcGx5KG51bGwsIHByb21pc2VzKS5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vICAgICAgICBrby5hcHBseUJpbmRpbmdzKG1vZGVsKTtcXG4gICAgICAgIC8vICAgIH0pO1xcbiAgICAgICAgLy99IGVsc2VcXG4gICAgICAgIC8vICAgIGtvLmFwcGx5QmluZGluZ3MobW9kZWwpO1xcbiAgICB9O1xcbn0pKCk7IFxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9BcGkvYXBpLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRpY1N0YXRlO1xcblxcbiAgICBULmNvbnRleHQgPSBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICBzdGF0aWNTdGF0ZSA9IHN0YXRpY1N0YXRlIHx8IHtcXG4gICAgICAgICAgICBtb2RlbHM6IG5ldyBULlR5cGVzLlJlc291cmNlcygpLFxcbiAgICAgICAgICAgIHNhZ2FzOiBuZXcgVC5UeXBlcy5SZXNvdXJjZXMoKSxcXG4gICAgICAgICAgICBsb2FkZXI6IG5ldyBULlR5cGVzLkxvYWRlcigpLFxcbiAgICAgICAgICAgIG9wdGlvbnM6IFQub3B0aW9ucyxcXG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IG5ldyBULlR5cGVzLlRlbXBsYXRlcygpLFxcbiAgICAgICAgICAgIGxvYWRlZFBhbmVzOiB7fVxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBwZXJDb250ZXh0U3RhdGUgPSB7XFxuICAgICAgICAgICAgcmVuZGVyT3BlcmF0aW9uOiBuZXcgVC5UeXBlcy5PcGVyYXRpb24oKSxcXG4gICAgICAgICAgICBwdWJzdWI6IFQub3B0aW9ucy5wdWJzdWJcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIHN0YXRpY1N0YXRlLCBwZXJDb250ZXh0U3RhdGUsIHNvdXJjZSk7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL2NvbnRleHQuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULm9wdGlvbnMuZGVmYXVsdFVybFByb3ZpZGVyID0ge1xcbiAgICB1cmxEYXRhRnJvbTogZnVuY3Rpb24ocGFuZU9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBwYW5lT3B0aW9ucyAmJiB7IHVybDogJyMnICsgJC5wYXJhbShwYW5lT3B0aW9ucykgfTtcXG4gICAgfSxcXG4gICAgcGFuZU9wdGlvbnNGcm9tOiBmdW5jdGlvbih1cmwpIHtcXG4gICAgICAgIHJldHVybiB1cmwgJiYgVC5VdGlscy5kZXBhcmFtKHVybC5zdWJzdHIoMSkpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL2RlZmF1bHRVcmxQcm92aWRlci5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB1dGlscyA9IFQuVXRpbHM7XFxuXFxuICAgIFQuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCkge1xcbiAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgVC5ub2RlRm9yKGVsZW1lbnQpO1xcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdXRpbHMuY29udGV4dEZvcihlbGVtZW50KSB8fCBULmNvbnRleHQoKTtcXG5cXG4gICAgICAgIHZhciBub2RlID0gbmV3IFQuVHlwZXMuTm9kZShwYXJlbnROb2RlKTtcXG4gICAgICAgIHV0aWxzLmJpbmRQYW5lKG5vZGUsIGVsZW1lbnQsIHBhbmVPcHRpb25zLCBjb250ZXh0KTtcXG5cXG4gICAgICAgIHJldHVybiBub2RlO1xcbiAgICB9O1xcblxcbiAgICBULmFwcGVuZE5vZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCkge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKCc8ZGl2Lz4nKS5hcHBlbmRUbyh0YXJnZXQpO1xcbiAgICAgICAgcmV0dXJuIFQuY3JlYXRlTm9kZShlbGVtZW50LCBwYW5lT3B0aW9ucywgcGFyZW50Tm9kZSwgY29udGV4dCk7XFxuICAgIH07XFxuXFxuICAgIFQuaW5zZXJ0Tm9kZUFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCgnPGRpdi8+JykuaW5zZXJ0QWZ0ZXIodGFyZ2V0KTtcXG4gICAgICAgIHJldHVybiBULmNyZWF0ZU5vZGUoZWxlbWVudCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUgfHwgVC5ub2RlRm9yKHRhcmdldCksIGNvbnRleHQpO1xcbiAgICB9O1xcblxcbiAgICBULm5vZGVGb3IgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Tm9kZShrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcXG4gICAgfTtcXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9BcGkvbm9kZXMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24oKSB7XFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5mb3JlYWNoUHJvcGVydHkgPSB7XFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaC5pbml0KGVsZW1lbnQsIG1ha2VBY2Nlc3NvcihtYXBUb0FycmF5KHZhbHVlQWNjZXNzb3IoKSkpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5mb3JlYWNoLnVwZGF0ZShlbGVtZW50LCBtYWtlQWNjZXNzb3IobWFwVG9BcnJheSh2YWx1ZUFjY2Vzc29yKCkpKSwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3Ioc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWFwVG9BcnJheShzb3VyY2UpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSlcXG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdCwgZXh0ZW5kIGl0IG9udG8gYSBuZXcgb2JqZWN0XFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCQuZXh0ZW5kKHsgJGtleTogcHJvcGVydHkgfSwgc291cmNlW3Byb3BlcnR5XSkpO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0JpbmRpbmdIYW5kbGVycy9mb3JlYWNoUHJvcGVydHkuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5rby5iaW5kaW5nSGFuZGxlcnMubmF2aWdhdGUgPSB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICB2YXIgbm9kZSA9IFQubm9kZUZvcihlbGVtZW50KTtcXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xcblxcbiAgICAgICAgdmFyIGRhdGEgPSBULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBrby5iaW5kaW5nSGFuZGxlcnMudmFsaWRhdGVkQ2xpY2sgfHwga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrO1xcbiAgICAgICAgaGFuZGxlci5pbml0KGVsZW1lbnQsIG5hdmlnYXRlLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gbmF2aWdhdGUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5uYXZpZ2F0ZShkYXRhLnZhbHVlLCBULlV0aWxzLmNsb25lRGF0YShkYXRhLmRhdGEpKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL25hdmlnYXRlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxua28uYmluZGluZ0hhbmRsZXJzLm5hdmlnYXRlQmFjayA9IHtcXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcXG4gICAgICAgIHZhciBub2RlID0gVC5ub2RlRm9yKGVsZW1lbnQpO1xcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XFxuXFxuICAgICAgICBrby5iaW5kaW5nSGFuZGxlcnMuY2xpY2suaW5pdChlbGVtZW50LCBuYXZpZ2F0ZUJhY2ssIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBuYXZpZ2F0ZUJhY2soKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5uYXZpZ2F0ZUJhY2soKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL25hdmlnYXRlQmFjay5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbigpIHtcXG4gICAga28uYmluZGluZ0hhbmRsZXJzLnBhbmUgPSB7IGluaXQ6IHVwZGF0ZUJpbmRpbmcgfTtcXG5cXG4gICAgZnVuY3Rpb24gdXBkYXRlQmluZGluZyhlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICBULmNyZWF0ZU5vZGUoZWxlbWVudCwgY29uc3RydWN0UGFuZU9wdGlvbnMoKSwgVC5VdGlscy5leHRyYWN0Tm9kZShiaW5kaW5nQ29udGV4dCksIFQuVXRpbHMuZXh0cmFjdENvbnRleHQoYmluZGluZ0NvbnRleHQpKTtcXG5cXG4gICAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RQYW5lT3B0aW9ucygpIHtcXG4gICAgICAgICAgICByZXR1cm4gVC5VdGlscy5nZXRQYW5lT3B0aW9ucyhrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSksIGFsbEJpbmRpbmdzQWNjZXNzb3IoKSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9CaW5kaW5nSGFuZGxlcnMvcGFuZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmtvLmJpbmRpbmdIYW5kbGVycy5wdWJsaXNoID0ge1xcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgdmFyIHB1YnN1YiA9IFQubm9kZUZvcihlbGVtZW50KS5wYW5lLnB1YnN1YjtcXG4gICAgICAgIGlmICghcHVic3ViKSByZXR1cm47XFxuXFxuICAgICAgICB2YXIgZGF0YSA9IFQuVXRpbHMubm9ybWFsaXNlQmluZGluZ3ModmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvcik7XFxuICAgICAgICB2YXIgaGFuZGxlciA9IGtvLmJpbmRpbmdIYW5kbGVycy52YWxpZGF0ZWRDbGljayB8fCBrby5iaW5kaW5nSGFuZGxlcnMuY2xpY2s7XFxuICAgICAgICBoYW5kbGVyLmluaXQoZWxlbWVudCwgcHVibGlzaEFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEFjY2Vzc29yKCkge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHB1YnN1Yi5wdWJsaXNoKGRhdGEudmFsdWUsIFQuVXRpbHMuY2xvbmVEYXRhKGRhdGEuZGF0YSkpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9CaW5kaW5nSGFuZGxlcnMvcHVibGlzaC5qc1wiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc2FnYTogVC5yZWdpc3RlclNhZ2EsXHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IHJlZ2lzdGVyIGEgc3RhdGljIGhhbmRsZXIgb24gdGhlIGNsaWVudCAoeWV0KSFcIik7XHJcbiAgICB9LFxyXG4gICAgc2VydmljZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCByZWdpc3RlciBhIHNlcnZpY2Ugb24gdGhlIGNsaWVudCFcIik7XHJcbiAgICB9XHJcbn07IiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL3BhbmUnIH07XG7vu78vL3BhbmUiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvcmVzb3VyY2UnIH07XG7vu78vL3Jlc291cmNlIiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL3NjcmlwdCcgfTtcbu+7vy8vc2NyaXB0Il19
