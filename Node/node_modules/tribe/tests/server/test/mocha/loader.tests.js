suite('tribe.test.mocha.loader', function () {
    var Mocha = require('mocha'),
        broadcastTo,
        mocha,
        loader,
        restore;

    setup(function () {
        require.refresh('tribe/test/mocha/loader');
        require.stub('tribe/server/channels', { broadcastTo: broadcastTo = sinon.spy() });
        require.stub('tribe/load', {
            file: function (options) {
                options.beforeExecute();
                restore = options.afterExecute;
                return { fail: function () { } };
            }
        });
        mocha = new Mocha();
        loader = require('tribe/test/mocha/loader');
        loader.loadFile(mocha, 'path');
    });

    test("addTest override creates tests and sets filename", function () {
        mocha.suite.addTest(new Mocha.Test('title', function () { }));
        mocha.suite.addTest(new Mocha.Test('title2', function () { }));
        expect(mocha.suite.tests.length).to.equal(2);
        expect(mocha.suite.tests[0].title).to.equal('title');
        expect(mocha.suite.tests[0].filename).to.equal('path');
        restore();
    });

    // this won't be necessary when tests are run in a separate process
    test("addTest override replaces existing tests", function () {
        mocha.suite.addTest(new Mocha.Test('title', function () { }));
        mocha.suite.addTest(new Mocha.Test('title', function () { }));
        expect(mocha.suite.tests.length).to.equal(1);
        expect(mocha.suite.tests[0].title).to.equal('title');
        restore();
    });

    test("test.loaded message is published when test is added", function () {
        mocha.suite.addTest(new Mocha.Test('title', function () { }));
        expect(broadcastTo.calledOnce).to.be.true;
        expect(broadcastTo.firstCall.args[1].topic).to.equal('test.loaded');
        restore();
    });

    test("test.removed message is published when test is removed from file", function () {
        mocha.suite.addTest(new Mocha.Test('title', function () { }));
        loader.loadFile(mocha, 'path');
        restore();
        expect(broadcastTo.callCount).to.equal(2);
        expect(broadcastTo.secondCall.args[1].topic).to.equal('test.removed');
    });
});