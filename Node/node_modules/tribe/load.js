var fs = require('q-io/fs'),
    vm = require('vm'),
    q = require('q'),
    _ = require('underscore'),
    utils = require('tribe/utilities'),
    path = require('path'),
    Module = require('module');

module.exports = {
    file: loadFile,
    directory: loadDirectory,
    enumerate: enumerateFiles
};

function loadFile(pathOrOptions) {
    var options = normaliseOptions(pathOrOptions);
    return fs.read(options.path)
        .then(function (source) {
            extendArgs();

            var newModule = new Module(options.path);
            newModule.paths = Module._nodeModulePaths(options.path);
            newModule._compile(constructSource(source), debugPath());

            if (options.beforeExecute) options.beforeExecute(options.path);
            var result = newModule.exports.apply(options.thisArg, _.values(options.args));
            if (options.afterExecute) options.afterExecute(options.path);

            return result;
        })
    .fail(utils.rethrow('Error loading file: ' + options.path));

    function constructSource(source) {
        var pre = 'module.exports = (function(' + Object.keys(options.args).join(', ') + ') { extendRequire(require); ';
        var post = '} )';

        if (options.withArg && options.args[options.withArg]) {
            pre += 'with (' + options.withArg + ') {';
            post = '} ' + post;
        }
        post = '\n' + post;

        return pre + source + post;
    }

    function debugPath() {
        return options.debugPath ?
            ('http://' + (options.debugDomain ? options.debugDomain + '/' : '') + options.debugPath).replace(/\\/g, '/') :
            options.path;
    }

    function extendArgs() {
        options.args = _.extend({
            // __dirname and __filename resolve to the path that we pass to module._compile. 
            // Given this is our debug path, override these values with the true value.
            __filename: options.path,
            __dirname: path.dirname(options.path),
            extendRequire: extendRequire
        }, options.args);
    }

    function extendRequire(target) {
        _.extend(target, options.requireExtensions);
    }
}

function enumerateFiles(directoryPath, callback, recursive) {
    directoryPath = path.normalize(directoryPath);
    return fs.listTree(directoryPath, guard)
        .then(function (filePaths) {
            var promises = _.map(filePaths, function (filePath) {
                filePath = path.normalize(filePath);
                return callback(filePath, filePath.replace(directoryPath, ''));
            });
            return q.all(promises);
        })
    .fail(utils.rethrow('Error enumerating directory: ' + directoryPath));

    function guard(path, stat) {
        if (stat.isDirectory())
            return recursive !== false ? false : null;
        return true;
    }
}

function loadDirectory(pathOrOptions) {
    pathOrOptions = normaliseOptions(pathOrOptions);
    return enumerateFiles(pathOrOptions.path, function (filePath, relativePath) {
        var options = _.extend({}, pathOrOptions, {
            path: filePath,
            debugPath: (pathOrOptions.debugPath || '') + path.normalize(filePath).replace(path.normalize(pathOrOptions.path), '').replace(/\\/g, '/')
        });
        return loadFile(options);
    });
}

function normaliseOptions(pathOrOptions) {
    var options = typeof (pathOrOptions) === "string" ?
        { path: pathOrOptions } :
        pathOrOptions;
    options.path = path.normalize(options.path);
    return options;
}