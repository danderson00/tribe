require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/fixture' };
﻿T.registerModel(function (pane) {
    this.fixture = pane.data;
});
},{}],2:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/layout' };
﻿T.registerModel(function (pane) {
    var self = this,
        saga,
        channel = pane.pubsub.channel('__test').connect();

    this.initialise = function () {
        return T.services('Tests').invoke().then(function (fixture) {
            saga = channel.startSaga(null, 'session', fixture);
            self.fixture = fixture;
        });        
    };

    //this.renderComplete = function () {
    //    channel.publish('test.run');
    //};
});
},{}],3:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/list' };
﻿T.registerModel(function (pane) {
    this.tests = flatten(pane.data);

    // should write a test for this
    function flatten(fixture) {
        var tests = fixture.tests,
            fixtures = fixture.fixtures;

        for (var fixtureName in fixtures)
            if(fixtures.hasOwnProperty(fixtureName))
                tests = tests.concat(flatten(fixtures[fixtureName]));
        
        return tests;
        //return _.flatten(_.map(fixture.fixtures, flatten), fixture.tests);
    }
});
},{}],4:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/test' };
﻿T.registerModel(function (pane) {
    var self = this,
        test = pane.data;

    this.test = test;

    this.error = ko.computed(function () {
        var error = test.error();
        return error && error.replace(/\n/g, '<br/>');
    });

    this.fixture = test.fixture ?
        test.fixture.join('.') :
        'No fixture';

    this.showDetails = ko.observable(test.state() === 'failed');

    this.toggleDetails = function () {
        self.showDetails(!self.showDetails());
    };

    this.run = function () {
        pane.pubsub.publish({ topic: 'test.run', data: [{ fixture: test.fixture, title: test.title }], channelId: '__test' });
    };

    this.select = function () {
        test.selected(!test.selected());
    };
});
},{}],5:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/toolbar' };
﻿T.registerModel(function (pane) {
    this.run = function () {
        pane.pubsub.publish({ topic: 'test.run', channelId: '__test' });
    };

    this.debug = function () {
        var debugWindow = window.open('http://localhost:8080/debug?port=5859', 'debugger');
        debugWindow.focus();
    };
});
},{}],6:[function(require,module,exports){
T.scriptEnvironment = { resourcePath: '/session' };
﻿require('tribe/register').saga(function (saga) {
    var fixture;

    saga.handles = {
        onstart: function (data) {
            //fixture = extendFixture(data);
        },
        'test.complete': updateTest,
        'test.loaded': updateTest,
        //'test.removed': removeTest
    };

    function updateTest(update) {
        var test = findTest(update);
        test.stale(update.state === undefined);
        if(update.state) test.state(update.state);
        test.error(update.error);
        test.duration(update.duration);
    }
});

},{"tribe/register":"2OrlGQ"}],7:[function(require,module,exports){

window.eval("\nif (typeof (T) == 'undefined') T = {};\nT.Types = T.Types || {};\n\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/setup.js");


window.eval("\n(function () {\n    Tribe.PubSub.prototype.startSaga = function (id, path, data) {\n        if (path.charAt(0) !== '/')\n            path = '/' + path;\n\n        var saga = new Tribe.PubSub.Saga(this, sagaDefinition(path));\n\n        if (id) {\n            saga.id = id;\n            attachToHub(saga);\n            T.hub.startSaga(path, id, data);\n        }\n\n        return saga.start(data);\n    };\n\n    Tribe.PubSub.prototype.joinSaga = function (id, path, data) {\n        var deferred = $.Deferred();\n        var self = this;\n        $.when($.get('Data/' + id + '/' + id))\n            .done(function (data) {\n                var saga = new Tribe.PubSub.Saga(self, sagaDefinition(data.path));\n                saga.id = id;\n                saga.join(T.serializer.deserialize(data.data));\n                attachToHub(saga);\n                deferred.resolve(saga);\n            })\n            .fail(function (reason) {\n                if (reason.status === 404 && path) {\n                    var saga = self.startSaga(id, path, data);\n                    deferred.resolve(saga);\n                }\n                else deferred.reject(reason);\n\n            });\n        return deferred;\n    };\n\n    function sagaDefinition(path) {\n        return T.context().sagas[path].constructor;\n    }\n\n    // need to also be able to detach\n    function attachToHub(saga) {\n        T.hub.join(saga.id);\n        saga.pubsub.subscribe(saga.topics, function (message, envelope) {\n            envelope.sagaId = saga.id;\n            T.hub.publish(envelope);\n        });\n    }\n\n    Tribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.prototype.startSaga;\n    Tribe.PubSub.Lifetime.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;\n    Tribe.PubSub.Channel.prototype.startSaga = Tribe.PubSub.prototype.startSaga;\n    Tribe.PubSub.Channel.prototype.joinSaga = Tribe.PubSub.prototype.joinSaga;\n\n    Tribe.PubSub.Channel.prototype.connect = function (topics) {\n        var self = this;\n\n        T.hub.join(this.id);\n        this.subscribe(topics || '*', function(data, envelope) {\n            T.hub.publish(envelope);\n        });\n\n        var end = this.end;\n        this.end = function() {\n            T.hub.leave(self.channelId);\n            end();\n        };\n\n        return this;\n    };\n})();\n\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/PubSub.extensions.js");


window.eval("\nT.services = function (name) {\n    return {\n        invoke: function () {\n            return $.get('Services', { name: name, args: Array.prototype.splice.call(arguments, 0) })\n                .fail(function (response) {\n                    T.logger.error(response.responseText);\n                });\n        }\n    };\n};\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/services.js");


window.eval("\nT.Types.Hub = function (io, pubsub, options) {\n    var socket = io.connect(options.socketUrl);\n\n    socket.on('message', function (envelope) {\n        envelope.origin = 'server';\n        pubsub.publish(envelope);\n    });\n\n    this.publish = function(envelope) {\n        if (!socket)\n            throw 'Hub must be connected before calling publish';\n        if(envelope.origin !== 'server')\n            socket.emit('message', envelope, function () {\n                console.log('message acknowledged');\n            });\n    };\n\n    this.join = function(channel) {\n        socket.emit('join', channel);\n    };\n\n    this.startSaga = function(path, id, data) {\n        socket.emit('startSaga', { path: path, id: id, data: data });\n    };\n};\n//@ sourceURL=http://Tribe.Node/node_modules/tribe/client/types/Hub.js");

},{}],8:[function(require,module,exports){
/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */


window.eval("\n(function () {\n    var level = 4;\n    var levels = {\n        debug: 4,\n        info: 3,\n        warn: 2,\n        error: 1,\n        none: 0\n    };\n\n    var api = {\n        setLevel: function (newLevel) {\n            level = levels[newLevel];\n            if (level === undefined) level = 4;\n        },\n        debug: function (message) {\n            if (level >= 4)\n                console.log(('DEBUG: ' + message));\n        },\n        info: function (message) {\n            if (level >= 3)\n                console.info(('INFO: ' + message));\n        },\n        warn: function (message) {\n            if (level >= 2)\n                console.warn(('WARN: ' + message));\n        },\n        error: function (message, error) {\n            if (level >= 1)\n                console.error(('ERROR: ' + message + '\\n'), api.errorDetails(error));\n        },\n        errorDetails: function (ex) {\n            if (!ex) return '';\n            return (ex.constructor === String) ? ex :\n                (ex.stack || '') + (ex.inner ? '\\n\\n' + this.errorDetails(ex.inner) : '\\n');\n        }\n    };\n    api.log = api.debug;\n    \n    if (typeof (exports) !== 'undefined' && typeof (module) !== 'undefined')\n        module.exports = api;\n    else {\n        if (typeof (T) === 'undefined')\n            T = {};\n        T.logger = api;\n    }\n})();\n\n\n//@ sourceURL=http://Tribe.Common/Source/logger.js");


window.eval("\n(function () {\n    // man... this cross-platform stuff sucks...\n    var ko;\n    if (typeof (window) !== 'undefined')\n        ko = window.ko;\n    if (typeof (require) !== 'undefined')\n        ko = require('knockout');\n\n    var api = {\n        serialize: function (source) {\n            return JSON.stringify(this.extractMetadata(source));\n        },\n        extractMetadata: function (source) {\n            var target = source,\n                metadata = {};\n            removeObservables();\n            return {\n                target: target,\n                metadata: metadata\n            };\n\n            function removeObservables() {\n                metadata.observables = [];\n                for (var property in target)\n                    if (target.hasOwnProperty(property) && ko.isObservable(target[property])) {\n                        target[property] = target[property]();\n                        metadata.observables.push(property);\n                    }\n\n            }\n        },\n        deserialize: function (source) {\n            source = JSON.parse(source);\n            if (source.target)\n                return this.applyMetadata(source.target, source.metadata);\n            return source;\n        },\n        applyMetadata: function (target, metadata) {\n            if (metadata)\n                restoreObservables();\n            return target;\n\n            function restoreObservables() {\n                var observables = metadata.observables;\n                for (var i = 0, l = observables.length; i < l; i++)\n                    restoreProperty(observables[i]);\n            }\n\n            function restoreProperty(property) {\n                target[property] = createObservable(target[property]);\n            }\n\n            function createObservable(value) {\n                return value.constructor === Array ?\n                    ko.observableArray(value) :\n                    ko.observable(value);\n            }\n        }\n    };\n\n    if (typeof (exports) !== 'undefined' && typeof (module) !== 'undefined')\n        module.exports = api;\n    else {\n        if (typeof (T) === 'undefined')\n            T = {};\n        T.serializer = api;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Common/Source/serializer.js");


window.eval("\nif (typeof (Tribe) === 'undefined')\n    Tribe = {};\n\nTribe.PubSub = function (options) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    this.owner = this;\n    this.options = options || {};\n    this.sync = option('sync');\n     \n    var subscribers = new Tribe.PubSub.SubscriberList();\n    this.subscribers = subscribers;\n\n    function publish(envelope) {\n        var messageSubscribers = subscribers.get(envelope.topic);\n        var sync = envelope.sync === true || self.sync === true;\n\n        for (var i = 0, l = messageSubscribers.length; i < l; i++) {\n            if (sync)\n                executeSubscriber(messageSubscribers[i].handler);\n            else {\n                (function (subscriber) {\n                    setTimeout(function () {\n                        executeSubscriber(subscriber.handler);\n                    });\n                })(messageSubscribers[i]);\n            }\n        }\n\n        function executeSubscriber(func) {\n            var exceptionHandler = option('exceptionHandler');\n            \n            if(option('handleExceptions')  && exceptionHandler)\n                try {\n                    func(envelope.data, envelope);\n                } catch (e) {\n                    exceptionHandler(e, envelope);\n                }\n            else\n                func(envelope.data, envelope);\n        }\n    }\n\n    this.publish = function (topicOrEnvelope, data) {\n        return publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        var envelope = createEnvelope(topicOrEnvelope, data);\n        envelope.sync = true;\n        return publish(envelope);\n    };\n    \n    function createEnvelope(topicOrEnvelope, data) {\n        return topicOrEnvelope && topicOrEnvelope.topic\n            ? topicOrEnvelope\n            : { topic: topicOrEnvelope, data: data };\n    }\n\n    this.subscribe = function (topic, func) {\n        if (typeof (topic) === \"string\")\n            return subscribers.add(topic, func);\n        else if (utils.isArray(topic))\n            return utils.map(topic, function(topicName) {\n                return subscribers.add(topicName, func);\n            });\n        else\n            return utils.map(topic, function (individualFunc, topicName) {\n                return subscribers.add(topicName, individualFunc);\n            });\n    };\n\n    this.unsubscribe = function (tokens) {\n        if (Tribe.PubSub.utils.isArray(tokens)) {\n            var results = [];\n            for (var i = 0, l = tokens.length; i < l; i++)\n                results.push(subscribers.remove(tokens[i]));\n            return results;\n        }\n\n        return subscribers.remove(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n    \n    function option(name) {\n        return (self.options.hasOwnProperty(name)) ? self.options[name] : Tribe.PubSub.options[name];\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/PubSub.js");


window.eval("\nTribe.PubSub.Channel = function (pubsub, channelId) {\n    var self = this;\n    pubsub = pubsub.createLifetime();\n\n    this.id = channelId;\n    this.owner = pubsub.owner;\n\n    this.publish = function (topicOrEnvelope, data) {\n        return pubsub.publish(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.publishSync = function (topicOrEnvelope, data) {\n        return pubsub.publishSync(createEnvelope(topicOrEnvelope, data));\n    };\n\n    this.subscribe = function(topic, func) {\n        return pubsub.subscribe(topic, filterMessages(func));\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        return pubsub.subscribeOnce(topic, filterMessages(func));\n    };\n    \n    this.unsubscribe = function(token) {\n        return pubsub.unsubscribe(token);\n    };\n\n    this.end = function() {\n        return pubsub.end();\n    };\n\n    this.createLifetime = function () {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n\n    function createEnvelope(topicOrEnvelope, data) {\n        var envelope = topicOrEnvelope && topicOrEnvelope.topic\n          ? topicOrEnvelope\n          : { topic: topicOrEnvelope, data: data };\n        envelope.channelId = channelId;\n        return envelope;\n    }\n    \n    function filterMessages(func) {\n        return function(data, envelope) {\n            if (envelope.channelId === channelId)\n                func(data, envelope);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Channel.js");


window.eval("\nTribe.PubSub.Lifetime = function (parent, owner) {\n    var self = this;\n    var tokens = [];\n\n    this.owner = owner;\n\n    this.publish = function(topicOrEnvelope, data) {\n        return parent.publish(topicOrEnvelope, data);\n    };\n\n    this.publishSync = function(topic, data) {\n        return parent.publishSync(topic, data);\n    };\n\n    this.subscribe = function(topic, func) {\n        var token = parent.subscribe(topic, func);\n        return recordToken(token);\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        var token = parent.subscribeOnce(topic, func);\n        return recordToken(token);\n    };\n    \n    this.unsubscribe = function(token) {\n        // we should really remove the token(s) from our token list, but it has trivial impact if we don't\n        return parent.unsubscribe(token);\n    };\n\n    this.channel = function(channelId) {\n        return new Tribe.PubSub.Channel(self, channelId);\n    };\n\n    this.end = function() {\n        return parent.unsubscribe(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n    \n    function recordToken(token) {\n        if (Tribe.PubSub.utils.isArray(token))\n            tokens = tokens.concat(token);\n        else\n            tokens.push(token);\n        return token;\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/Lifetime.js");


window.eval("\nTribe.PubSub.options = {\n    sync: false,\n    handleExceptions: true,\n    exceptionHandler: function(e, envelope) {\n        typeof(console) !== 'undefined' && console.log(\"Exception occurred in subscriber to '\" + envelope.topic + \"': \" + e.message);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/options.js");


window.eval("\nTribe.PubSub.Saga = function (pubsub, definition) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    pubsub = pubsub.createLifetime();\n    this.pubsub = pubsub;\n    this.children = [];\n\n    configureSaga();\n    var handlers = this.handles || {};\n\n    // this is not ie<9 compatible and includes onstart / onend\n    this.topics = Object.keys(handlers);\n\n    this.start = function (startData) {\n        utils.each(handlers, self.addHandler, self);\n        if (handlers.onstart) handlers.onstart(startData, self);\n        return self;\n    };\n\n    this.startChild = function (child, onstartData) {\n        self.children.push(new Tribe.PubSub.Saga(pubsub, child)\n            .start(onstartData));\n        return self;\n    };\n\n    this.join = function (data, onjoinData) {\n        utils.each(handlers, self.addHandler, self);\n        self.data = data;\n        if (handlers.onjoin) handlers.onjoin(onjoinData, self);\n        return self;\n    };\n\n    this.end = function (onendData) {\n        if (handlers.onend) handlers.onend(onendData, self);\n        pubsub.end();\n        self.endChildren(onendData);\n        return self;\n    };\n\n    this.endChildren = function(data) {\n        Tribe.PubSub.utils.each(self.children, function(child) {\n             child.end(data);\n        });\n    }\n    \n    function configureSaga() {\n        if (definition)\n            if (definition.constructor === Function)\n                definition(self);\n            else\n                Tribe.PubSub.utils.copyProperties(definition, self, ['handles', 'endsChildrenExplicitly']);\n    }\n};\n\nTribe.PubSub.Saga.startSaga = function (definition, data) {\n    return new Tribe.PubSub.Saga(this, definition).start(data);\n};\n\nTribe.PubSub.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\nTribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\n//@ sourceURL=http://Tribe.PubSub/Saga.core.js");


window.eval("\nTribe.PubSub.Saga.prototype.addHandler = function (handler, topic) {\n    var self = this;\n\n    if (topic !== 'onstart' && topic !== 'onend' && topic !== 'onjoin')\n        if (!handler)\n            this.pubsub.subscribe(topic, endHandler());\n        else if (handler.constructor === Function)\n            this.pubsub.subscribe(topic, messageHandlerFor(handler));\n        else\n            this.pubsub.subscribe(topic, childHandlerFor(handler));\n\n    function messageHandlerFor(handler) {\n        return function (messageData, envelope) {\n            if (!self.endsChildrenExplicitly)\n                self.endChildren(messageData);\n            handler(messageData, envelope, self);\n        };\n    }\n\n    function childHandlerFor(childHandlers) {\n        return function (messageData, envelope) {\n            self.startChild({ handles: childHandlers }, messageData);\n        };\n    }\n\n    function endHandler() {\n        return function (messageData) {\n            self.end(messageData);\n        };\n    }\n};\n\n//@ sourceURL=http://Tribe.PubSub/Saga.handlers.js");


window.eval("\nTribe.PubSub.prototype.subscribeOnce = function (topic, handler) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n    var lifetime = this.createLifetime();\n\n    if (typeof (topic) === \"string\")\n        return lifetime.subscribe(topic, wrapHandler(handler));\n    else if (utils.isArray(topic))\n        return lifetime.subscribe(wrapTopicArray());\n    else\n        return lifetime.subscribe(wrapTopicObject());\n\n    function wrapTopicArray() {\n        var result = {};\n        utils.each(topic, function(topicName) {\n            result[topicName] = wrapHandler(handler);\n        });\n        return result;\n    }\n    \n    function wrapTopicObject() {\n        return utils.map(topic, function (func, topicName) {\n            return lifetime.subscribe(topicName, wrapHandler(func));\n        });\n    }\n\n    function wrapHandler(func) {\n        return function() {\n            lifetime.end();\n            func.apply(self, arguments);\n        };\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/subscribeOnce.js");


window.eval("\nTribe.PubSub.SubscriberList = function() {\n    var subscribers = {};\n    var lastUid = -1;\n\n    this.get = function (publishedTopic) {\n        var matching = [];\n        for (var registeredTopic in subscribers)\n            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))\n                matching = matching.concat(subscribers[registeredTopic]);\n        return matching;\n    };\n\n    this.add = function (topic, handler) {\n        var token = (++lastUid).toString();\n        if (!subscribers.hasOwnProperty(topic))\n            subscribers[topic] = [];\n        subscribers[topic].push({ topic: topic, handler: handler, token: token });\n        return token;\n    };\n\n    this.remove = function(token) {\n        for (var m in subscribers)\n            if (subscribers.hasOwnProperty(m))\n                for (var i = 0, l = subscribers[m].length; i < l; i++)\n                    if (subscribers[m][i].token === token) {\n                        subscribers[m].splice(i, 1);\n                        return token;\n                    }\n\n        return false;\n    };\n\n    function topicMatches(published, subscriber) {\n        if (subscriber === '*')\n            return true;\n        \n        var expression = \"^\" + subscriber\n            .replace(/\\./g, \"\\\\.\")\n            .replace(/\\*/g, \"[^\\.]*\") + \"$\";\n        return published.match(expression);\n    }\n};\n//@ sourceURL=http://Tribe.PubSub/SubscriberList.js");


window.eval("\nTribe.PubSub.utils = {};\n(function(utils) {\n    utils.isArray = function (source) {\n        return source.constructor === Array;\n    };\n\n    // The following functions are taken from the underscore library, duplicated to avoid dependency. License at http://underscorejs.org.\n    var nativeForEach = Array.prototype.forEach;\n    var nativeMap = Array.prototype.map;\n    var breaker = {};\n\n    utils.each = function (obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker) return;\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) return;\n                }\n            }\n        }\n    };\n\n    utils.map = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        utils.each(obj, function (value, index, list) {\n            results[results.length] = iterator.call(context, value, index, list);\n        });\n        return results;\n    };\n\n    utils.copyProperties = function (source, target, properties) {\n        for (var i = 0, l = properties.length; i < l; i++) {\n            var property = properties[i];\n            if(source.hasOwnProperty(property))\n                target[property] = source[property];\n        }\n    };\n})(Tribe.PubSub.utils);\n\n//@ sourceURL=http://Tribe.PubSub/utils.js");


window.eval("\nif (typeof(module) !== 'undefined')\n    module.exports = new Tribe.PubSub();\n//@ sourceURL=http://Tribe.PubSub/exports.js");


window.eval("\n(function (global) {\n    if (typeof (jQuery) === 'undefined')\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (typeof (ko) === 'undefined')\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n    if (typeof(T) === 'undefined')\n        throw 'Tribe.Common must be loaded before knockout.composite can initialise';\n\n    global.T = T || {};\n    global.T.Events = {};\n    global.T.Factories = {};\n    global.T.LoadHandlers = {};\n    global.T.LoadStrategies = {};\n    global.T.Transitions = {};\n    global.T.Types = {};\n    global.T.Utils = {};\n    global.T.logger = T.logger;\n    global.T.pubsub = new Tribe.PubSub();\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n    });\n})(window || this);\n\n//@ sourceURL=http://Tribe.Composite/setup.js");


window.eval("\nT.defaultOptions = function() {\n    return {\n        synchronous: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']\n    };\n};\nT.options = T.defaultOptions();\n\n//@ sourceURL=http://Tribe.Composite/options.js");


window.eval("\n(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/bindingHandlers.js");


window.eval("\n(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n\n    utils.pluck = function(array, property) {\n        return utils.map(array, function(value) {\n            return value && value[property];\n        });\n    };\n\n    utils.reduce = function (array, initialValue, reduceFunction) {\n        utils.each(array, function(value, index) {\n            initialValue = reduceFunction(initialValue, value, index, array);\n        });\n        return initialValue;\n    };\n})(T.Utils);\n\n//@ sourceURL=http://Tribe.Composite/Utilities/collections.js");


window.eval("\n// this is taken from https://github.com/cowboy/jquery-bbq/, Copyright (c) 2010 \"Cowboy\" Ben Alman and also released under the MIT license\n\n// Deserialize a params string into an object, optionally coercing numbers,\n// booleans, null and undefined values; this method is the counterpart to the\n// internal jQuery.param method.\nT.Utils.deparam = function (params, coerce) {\n    var decode = decodeURIComponent;\n    var obj = {},\n      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    // Iterate over all name=value pairs.\n    $.each(params.replace(/\\+/g, ' ').split('&'), function (j, v) {\n        var param = v.split('='),\n          key = decode(param[0]),\n          val,\n          cur = obj,\n          i = 0,\n\n          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n          // into its component parts.\n          keys = key.split(']['),\n          keys_last = keys.length - 1;\n\n        // If the first keys part contains [ and the last ends with ], then []\n        // are correctly balanced.\n        if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n            // Remove the trailing ] from the last keys part.\n            keys[keys_last] = keys[keys_last].replace(/\\]$/, '');\n\n            // Split first keys part into two parts on the [ and add them back onto\n            // the beginning of the keys array.\n            keys = keys.shift().split('[').concat(keys);\n\n            keys_last = keys.length - 1;\n        } else {\n            // Basic 'foo' style key.\n            keys_last = 0;\n        }\n\n        // Are we dealing with a name=value pair, or just a name?\n        if (param.length === 2) {\n            val = decode(param[1]);\n\n            // Coerce values.\n            if (coerce) {\n                val = val && !isNaN(val) ? +val              // number\n                  : val === 'undefined' ? undefined         // undefined\n                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n                  : val;                                                // string\n            }\n\n            if (keys_last) {\n                // Complex key, build deep object structure based on a few rules:\n                // * The 'cur' pointer starts at the object top-level.\n                // * [] = array push (n is set to array length), [n] = array if n is \n                //   numeric, otherwise object.\n                // * If at the last keys part, set the value.\n                // * For each keys part, if the current level is undefined create an\n                //   object or array based on the type of the next keys part.\n                // * Move the 'cur' pointer to the next level.\n                // * Rinse & repeat.\n                for (; i <= keys_last; i++) {\n                    key = keys[i] === '' ? cur.length : keys[i];\n                    cur = cur[key] = i < keys_last\n                      ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])\n                      : val;\n                }\n\n            } else {\n                // Simple key, even simpler rules, since only scalars and shallow\n                // arrays are allowed.\n\n                if ($.isArray(obj[key])) {\n                    // val is already an array, so push on the next value.\n                    obj[key].push(val);\n\n                } else if (obj[key] !== undefined) {\n                    // val isn't an array, but since a second value has been specified,\n                    // convert val into an array.\n                    obj[key] = [obj[key], val];\n\n                } else {\n                    // val is a scalar.\n                    obj[key] = val;\n                }\n            }\n\n        } else if (key) {\n            // No value was defined, so set something meaningful.\n            obj[key] = coerce\n              ? undefined\n              : '';\n        }\n    });\n\n    return obj;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/deparam.js");


window.eval("\n(function() {\n    T.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    T.Utils.contextFor = function (element) {\n        return element && T.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    T.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');\n    };\n\n    T.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/embeddedContext.js");


window.eval("\n(function () {\n    T.Utils.elementDestroyed = function (element) {\n        if (element.constructor === jQuery)\n            element = element[0];\n\n        var promise = $.Deferred();\n\n        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n        $(element).on('destroyed', resolve);\n\n        // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n        $(document).on(\"DOMNodeRemoved\", matchElement);\n\n        function matchElement(event) {\n            if (event.target === element)\n                resolve();\n        }\n\n        function resolve() {\n            $(element).off('destroyed', resolve);\n            $(document).off('DOMNodeRemoved', matchElement);\n            promise.resolve();\n        }\n\n        return promise;\n    };\n\n    // this used to use DOM functions to raise events, but IE8 doesn't support custom events\n    // we'll use jQuery, but expose the originalEvent for DOM events and the jQuery event\n    // for custom events (originalEvent is null for custom events).\n    T.Utils.raiseDocumentEvent = function (name, eventData) {\n        var e = $.Event(name);\n        e.eventData = eventData;\n        $(document).trigger(e);\n    };\n\n    var handlers = {};\n\n    // if a handler is used for more than one event, a leak will occur\n    T.Utils.handleDocumentEvent = function (name, handler) {\n        $(document).on(name, internalHandler);\n        handlers[handler] = internalHandler;\n        \n        function internalHandler(e) {\n            handler(e.originalEvent || e);\n        }\n    };\n\n    T.Utils.detachDocumentEvent = function (name, handler) {\n        $(document).off(name, handlers[handler]);\n        delete handlers[handler];\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/events.js");


window.eval("\nT.Utils.tryCatch = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(this, args || []);\n        } catch (ex) {\n            T.logger.error(message, ex);\n        }\n    else\n        func.apply(this, args || []);\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/exceptions.js");


window.eval("\n(function () {\n    T.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = T.Utils.idGenerator();\n    T.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//@ sourceURL=http://Tribe.Composite/Utilities/idGenerator.js");


window.eval("\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\n        'use strict';\n        if (this == null) {\n            throw new TypeError();\n        }\n        var n, k, t = Object(this),\n            len = t.length >>> 0;\n\n        if (len === 0) {\n            return -1;\n        }\n        n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0) ; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    };\n}\n//@ sourceURL=http://Tribe.Composite/Utilities/indexOf.js");


window.eval("\n(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.complete.js");


window.eval("\n(function ($) {\n    var oldClean = jQuery.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})(jQuery);\n//@ sourceURL=http://Tribe.Composite/Utilities/jquery.destroyed.js");


window.eval("\nT.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//@ sourceURL=http://Tribe.Composite/Utilities/knockout.js");


window.eval("\nT.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        func: byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nT.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nT.Utils.inheritOptions = function (from, to, options) {\n    for (var i = 0, l = options.length; i < l; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nT.Utils.cloneData = function (from, except) {\n    if (!from) return;\n    var result = {};\n    for (var property in from) {\n        var value = from[property];\n        if (from.hasOwnProperty(property) &&\n            (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&\n            (!value || (value.constructor !== Function || ko.isObservable(value))))\n\n            result[property] = ko.utils.unwrapObservable(value);\n    }\n    return result;\n};\n\nT.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {\n    var data = allBindingsAccessor();\n    data.value = valueAccessor();\n    if (!ko.isObservable(data.value) && $.isFunction(data.value))\n        data.value = data.value();\n    return data;\n};\n\n\n//@ sourceURL=http://Tribe.Composite/Utilities/objects.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n\n    utils.bindPane = function (node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || T.context();\n        var pane = new T.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new T.Types.Pipeline(T.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    utils.insertPaneAfter = function (node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return utils.bindPane(node, element, paneOptions, context);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/panes.js");


window.eval("\n(function() {\n    T.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path.charAt(0) === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, '');\n            },\n            setExtension: function(extension) {\n                return Path(this.withoutExtension() + '.' + extension);\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/Path.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    T.Utils.Querystring.parse = function (source, seperator, eqSymbol) {\n        stripLeadIn();\n        \n        return T.Utils.reduce(\n            T.Utils.map(\n                source.split(seperator || \"&\"),\n                pieceParser(eqSymbol || \"=\")\n            ),\n            {},\n            mergeParams\n        );\n\n        function stripLeadIn() {\n            if(source.length > 0 && source.charAt(0) === '?')\n                source = source.substring(1);\n        }\n    };\n    \n    function unescape(s) {\n        return decodeURIComponent(s.replace(/\\+/g, ' '));\n    };\n\n    function pieceParser(eq) {\n        return function parsePiece(key, val) {\n\n            var sliced, numVal, head, tail, ret;\n\n            if (arguments.length === 2) {\n                // key=val, called from the map/reduce\n                key = key.split(eq);\n                return parsePiece(\n                    unescape(key.shift()),\n                    unescape(key.join(eq)),\n                    true\n                );\n            }\n            \n            key = key.replace(/^\\s+|\\s+$/g, '');\n            if (val.constructor === String) {\n                val = val.replace(/^\\s+|\\s+$/g, '');\n                // convert numerals to numbers\n                if (!isNaN(val)) {\n                    numVal = +val;\n                    if (val === numVal.toString(10)) {\n                        val = numVal;\n                    }\n                }\n            }\n            \n            sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n            if (!sliced) {\n                ret = {};\n                if (key)\n                    ret[key] = val;\n                return ret;\n            }\n            \n            // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n            tail = sliced[2];\n            head = sliced[1];\n\n            // array: key[]=val\n            if (!tail)\n                return parsePiece(head, [val], true);\n\n            // object: key[subkey]=val\n            ret = {};\n            ret[tail] = val;\n            return parsePiece(head, ret, true);\n        };\n    }\n\n    // the reducer function that merges each query piece together into one set of params\n    function mergeParams(params, addition) {\n        return (\n            // if it's uncontested, then just return the addition.\n            (!params) ? addition\n            // if the existing value is an array, then concat it.\n            : ($.isArray(params)) ? params.concat(addition)\n            // if the existing value is not an array, and either are not objects, arrayify it.\n            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)\n            // else merge them as objects, which is a little more complex\n            : mergeObjects(params, addition)\n        );\n    }\n\n    // Merge two *objects* together. If this is called, we've already ruled\n    // out the simple cases, and need to do the for-in business.\n    function mergeObjects(params, addition) {\n        for (var i in addition)\n            if (i && addition.hasOwnProperty(i))\n                params[i] = mergeParams(params[i], addition[i]);\n\n        return params;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.parse.js");


window.eval("\n(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    T.Utils.Querystring = T.Utils.Querystring || {};\n\n    var escape = encodeURIComponent;\n\n    T.Utils.Querystring.stringify = function (source, options) {\n        return stringify(source, options);\n    };\n\n    function stringify(source, options, name, stack) {\n        options = options || {};\n        stack = stack || [];\n        var begin, end, i, l, n, s;\n        var sep = options.seperator || \"&\";\n        var eq = options.eqSymbol || \"=\";\n        var arrayKey = options.arrayKey !== false;\n\n        if (source === null || source === undefined || source.constructor === Function)\n            return name ? escape(name) + eq : '';\n\n        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')\n            source = +source;\n\n        if (!isNaN(source) || source.constructor === String)\n            return escape(name) + eq + escape(source);\n\n        if ($.isArray(source)) {\n            s = [];\n            name = arrayKey ? name + '[]' : name;\n            for (i = 0, l = source.length; i < l; i++) {\n                s.push(stringify(source[i], options, name, stack));\n            }\n\n            return s.join(sep);\n        }\n        \n        // now we know it's an object.\n        // Check for cyclical references in nested objects\n        for (i = stack.length - 1; i >= 0; --i)\n            if (stack[i] === source)\n                throw new Error(\"T.Utils.Querystring.stringify: cyclical reference\");\n\n        stack.push(source);\n        s = [];\n        begin = name ? name + '[' : '';\n        end = name ? ']' : '';\n        for (i in source) {\n            if (source.hasOwnProperty(i)) {\n                n = begin + i + end;\n                s.push(stringify(source[i], options, n, stack));\n            }\n        }\n\n        stack.pop();\n        s = s.join(sep);\n        if (!s && name)\n            return name + \"=\";\n\n        return s;\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Utilities/querystring.stringify.js");


window.eval("\n(function () {\n    T.Types.Flow = function (navigationSource, definition) {\n        var self = this;\n\n        this.node = navigationNode();\n        this.pubsub = this.node.pane.pubsub.owner;\n        this.sagas = [];\n\n        definition = createDefinition(self, definition);\n        this.saga = new Tribe.PubSub.Saga(this.pubsub, definition);\n\n        this.start = function(data) {\n            self.saga.start(data);\n            return self;\n        };\n\n        this.end = function(data) {\n            self.saga.end(data);\n            T.Utils.each(self.sagas, function(saga) {\n                saga.end(data);\n            });\n            return self;\n        };\n\n        function navigationNode() {\n            if (navigationSource.constructor === T.Types.Node)\n                return navigationSource.findNavigation().node;\n            if (navigationSource.constructor === T.Types.Pane)\n                return navigationSource.node.findNavigation().node;\n            throw new Error(\"navigationSource must be either T.Types.Pane or T.Types.Node\");\n        }\n    };\n\n    T.Types.Flow.prototype.startChild = function(definition, data) {\n        definition = createDefinition(this, definition);\n        this.saga.startChild(definition, data);\n        return this;\n    };\n\n    T.Types.Flow.prototype.navigate = function (pathOrOptions, data) {\n        this.node.navigate(pathOrOptions, data);\n    };\n    \n    // This keeps a separate collection of sagas bound to this flow's lifetime\n    // It would be nice to make them children of the underlying saga, but\n    // then they would end any time a message was executed.\n    T.Types.Flow.prototype.startSaga = function (definition, data) {\n        var saga = this.pubsub.startSaga(definition, data);\n        this.sagas.push(saga);\n        return saga;\n    };\n\n    // flow helpers\n    T.Types.Flow.prototype.to = function (pathOrOptions, data) {\n        var node = this.node;\n        return function () {\n            node.navigate(pathOrOptions, data);\n        };\n    };\n\n    T.Types.Flow.prototype.endsAt = function (pathOrOptions, data) {\n        var flow = this;\n        return function () {\n            flow.node.navigate(pathOrOptions, data);\n            flow.end();\n        };\n    };\n\n    T.Types.Flow.prototype.start = function(flow, data) {\n        var thisFlow = this;\n        return function() {\n            thisFlow.startChild(flow, data);\n        };\n    };\n\n\n    // This is reused by Node and Pane\n    T.Types.Flow.startFlow = function (definition, data) {\n        return new T.Types.Flow(this, definition).start(data);\n    };\n    \n    function createDefinition(flow, definition) {\n        if (definition.constructor === Function)\n            definition = new definition(flow);\n        return definition;\n    }\n})();\n//@ sourceURL=http://Tribe.Composite/Types/Flow.js");


window.eval("\nT.Types.History = function (history) {\n    var currentState = 0;\n    history.replaceState(currentState, window.title);\n\n    var popActions = {\n        raiseEvent: function (e) {\n            T.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });\n            currentState = e.state;\n        },\n        updateStack: function(e) {\n            currentState = e.state;\n            currentAction = popActions.raiseEvent;\n        }\n    };\n    var currentAction = popActions.raiseEvent;\n\n    // this leaves IE7 & 8 high and dry. We'll probably require a polyfill and create a generic event subscription method\n    if(window.addEventListener)\n        window.addEventListener('popstate', executeCurrentAction);\n\n    function executeCurrentAction(e) {\n        if (e.state !== null) currentAction(e);\n    }\n\n    this.navigate = function (urlOptions) {\n        urlOptions = urlOptions || {};\n        history.pushState(++currentState, urlOptions.title, urlOptions.url);\n    };\n\n    this.go = function(frameCount) {\n        history.go(frameCount);\n    };\n\n    this.update = function(frameCount) {\n        currentAction = popActions.updateStack;\n        history.go(frameCount);\n    };\n\n    this.dispose = function () {\n        window.removeEventListener('popstate', executeCurrentAction);\n    };\n};\n\nif (window.history.pushState)\n    T.history = new T.Types.History(window.history);\nelse\n    T.history = new T.Types.History({\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { }\n    });\n//@ sourceURL=http://Tribe.Composite/Types/History.js");


window.eval("\nT.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = T.Path(url).extension().toString();\n        var handler = T.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        T.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//@ sourceURL=http://Tribe.Composite/Types/Loader.js");


window.eval("\nT.Types.Navigation = function (node, options) {\n    normaliseOptions();\n    setInitialPaneState();\n\n    var stack = [initialStackItem()];\n    var currentFrame = 0;\n\n    this.node = node;\n    this.stack = stack;\n\n    this.navigate = function (paneOptions) {\n        if (options.browser)\n            T.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));\n\n        trimStack();\n        stack.push(paneOptions);\n        currentFrame++;\n\n        navigateTo(paneOptions);\n    };\n\n    this.isAtStart = function() {\n        return currentFrame === 0;\n    };\n\n    this.go = function(frameCount) {\n        go(frameCount);\n        if (options.browser) T.history.update(frameCount);\n    };\n    \n    if(options.browser) T.Utils.handleDocumentEvent('browser.go', onBrowserGo);\n    function onBrowserGo(e) {\n        go(e.eventData.count);\n    }\n\n    function go(frameCount) {\n        var newFrame = currentFrame + frameCount;\n        if (newFrame < 0) newFrame = 0;\n        if (newFrame >= stack.length) newFrame = stack.length - 1;\n\n        if (newFrame != currentFrame)\n            navigateTo(stack[newFrame], frameCount < 0);\n\n        currentFrame = newFrame;\n    }\n\n    function navigateTo(paneOptions, reverse) {\n        T.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });\n        node.transitionTo(paneOptions, options.transition, reverse);\n    }\n\n    function trimStack() {\n        stack.splice(currentFrame + 1, stack.length);\n    }\n\n    this.dispose = function() {\n        T.Utils.detachDocumentEvent('browser.go', onBrowserGo);\n    };\n    \n    function normaliseOptions() {\n        options = options || {};\n        if (options.constructor === String)\n            options = { transition: options };\n        if (options.browser === true)\n            options.browser = T.options.defaultUrlProvider;\n    }\n    \n    function setInitialPaneState() {\n        var query = window.location.href.match(/\\#.*/);\n        if (query) query = query[0].substring(1);\n        var urlState = options.browser && options.browser.paneOptionsFrom(query);\n        if (urlState) {\n            node.pane.path = urlState.path;\n            node.pane.data = urlState.data;\n        }\n    }\n    \n    function initialStackItem() {\n        return { path: node.pane.path, data: node.pane.data };\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Types/Navigation.js");


window.eval("\nT.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n    this.id = T.Utils.getUniqueId();\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nT.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = T.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!T.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = T.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();\n    \n    this.findNavigation().navigate(paneOptions);\n};\n\nT.Types.Node.prototype.navigateBack = function () {\n    this.findNavigation().go(-1);\n};\n\nT.Types.Node.prototype.findNavigation = function() {\n    if (this.defaultNavigation)\n        return this.defaultNavigation;\n\n    else if (this.navigation)\n        return this.navigation;\n        \n    if (!this.parent) {\n        this.navigation = new T.Types.Navigation(this);\n        return this.navigation;\n    }\n\n    return this.parent.findNavigation();\n};\n\nT.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    T.transition(this, transition, reverse).to(paneOptions);\n};\n\nT.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.navigation = new T.Types.Navigation(this, pane.handlesNavigation);\n        \n        // this sets this pane as the \"default\", accessible from panes outside the tree. First in best dressed.\n        this.root.defaultNavigation = this.root.defaultNavigation || this.navigation;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nT.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nT.Types.Node.prototype.dispose = function() {\n    if (this.root.defaultNavigation === this.navigation)\n        this.root.defaultNavigation = null;\n\n    if (this.parent)\n        T.Utils.removeItem(this.parent.children, this);\n\n    if (this.pane && this.pane.dispose) {\n        delete this.pane.node;\n        this.pane.dispose();\n    }\n};\n\nT.Types.Node.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Node.js");


window.eval("\nT.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        T.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//@ sourceURL=http://Tribe.Composite/Types/Operation.js");


window.eval("\nT.Types.Pane = function (options) {\n    T.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };    \n};\n\nT.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nT.Types.Pane.prototype.navigateBack = function () {\n    this.node && this.node.navigateBack();\n};\n\nT.Types.Pane.prototype.remove = function () {\n    $(this.element).remove();\n};\n\nT.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        delete this.node.pane;\n        this.node.dispose();\n    }\n\n    if (this.element)\n        T.Utils.cleanElement(this.element);\n};\n\nT.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;    \n    var path = T.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = T.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nT.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nT.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nT.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nT.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n\nT.Types.Pane.prototype.startSaga = function(path, args) {\n    var saga = T.context().sagas[path];\n    this.pubsub.startSaga.apply(this.pubsub, [saga.constructor].concat(Array.prototype.slice.call(arguments, 1)));\n};\n\nT.Types.Pane.prototype.startFlow = T.Types.Flow.startFlow;\n\n//@ sourceURL=http://Tribe.Composite/Types/Pane.js");


window.eval("\nT.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var thisEvent = events[eventName];\n\n            if (!thisEvent) {\n                T.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            $.when(thisEvent(target, context))\n                .done(executeNextEvent)\n                .fail(handleFailure);\n\n            function handleFailure() {\n                promise.reject();\n                var targetDescription = target ? target.toString() : \"empty target\";\n                T.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription);\n            }\n        }\n\n        return promise;\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Pipeline.js");


window.eval("\nT.Types.Resources = function () { };\n\nT.Types.Resources.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    T.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//@ sourceURL=http://Tribe.Composite/Types/Resources.js");


window.eval("\nT.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = T.Path(path).asMarkupIdentifier().toString();\n        embedTemplate(template, 'template-' + id);\n    };\n    \n    function embedTemplate(template, id) {\n        var element = document.createElement('script');\n        element.className = '__tribe';\n        element.setAttribute('type', 'text/template');\n        element.id = id;\n        element.text = template;\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n    \n    this.loaded = function(path) {\n        return $('head script#template-' + T.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = T.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//@ sourceURL=http://Tribe.Composite/Types/Templates.js");


window.eval("\nT.Events.active = function (pane, context) {\n    return T.Utils.elementDestroyed(pane.element);\n};\n//@ sourceURL=http://Tribe.Composite/Events/active.js");


window.eval("\nT.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path];\n    var model = definition && definition.constructor ?\n        new definition.constructor(pane) :\n        { pane: pane, data: pane.data };\n\n    T.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n};\n//@ sourceURL=http://Tribe.Composite/Events/createModel.js");


window.eval("\nT.Events.createPubSub = function (pane, context) {\n    if (context.pubsub)\n        pane.pubsub = context.pubsub.createLifetime ?\n            context.pubsub.createLifetime() :\n            context.pubsub;\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/createPubSub.js");


window.eval("\nT.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//@ sourceURL=http://Tribe.Composite/Events/dispose.js");


window.eval("\nT.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/Events/initialiseModel.js");


window.eval("\nT.Events.loadResources = function (pane, context) {\n    var strategy = T.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//@ sourceURL=http://Tribe.Composite/Events/loadResources.js");


window.eval("\nT.Events.renderComplete = function (pane, context) {\n    $.when(\n        T.transition(pane, pane.transition, pane.reverseTransitionIn)['in']())\n     .done(executeRenderComplete);\n    \n    pane.endRender();\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        T.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new T.Types.Operation();\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderComplete.js");


window.eval("\nT.Events.renderPane = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    T.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n\n    function applyBindings() {\n        ko.applyBindingsToDescendants(pane.model, pane.element);\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Events/renderPane.js");


window.eval("\nT.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeScript\n    });\n\n    function executeScript(script) {\n        T.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        T.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete T.scriptEnvironment;\n\n        T.logger.debug('Loaded script from ' + url);\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//@ sourceURL=tribe://Application/' + url.replace(/ /g, \"_\");\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/scripts.js");


window.eval("\nT.LoadHandlers.css = function (url, resourcePath, context) {\n    var supportsTextNodes = true;\n    \n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        var element = document.getElementById('__tribeStyles');\n        if (!element) {\n            element = document.createElement('style');\n            element.className = '__tribe';\n            element.id = '__tribeStyles';\n            document.getElementsByTagName('head')[0].appendChild(element);\n        }\n\n        if(supportsTextNodes)\n            try {\n                element.appendChild(document.createTextNode(stylesheet));\n            } catch(ex) {\n                supportsTextNodes = false;\n            }\n\n        if (!supportsTextNodes)\n            if (element.styleSheet) {\n                // using styleSheet.cssText is required for IE8 support\n                // IE8 also has a limit on the number of <style/> elements, so append it to the same node\n                element.styleSheet.cssText += stylesheet;\n            } else throw new Error('Unable to append stylesheet for ' + resourcePath + ' to document.');\n    }\n};\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/stylesheets.js");


window.eval("\nT.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nT.LoadHandlers.html = T.LoadHandlers.htm;\n\n//@ sourceURL=http://Tribe.Composite/LoadHandlers/templates.js");


window.eval("\nT.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = T.Path(context.options.basePath).combine(T.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            T.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/adhoc.js");


window.eval("\nT.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        T.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//@ sourceURL=http://Tribe.Composite/LoadStrategies/preloaded.js");


window.eval("\nT.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n    \n    transition = transition || (pane && pane.transition) || (node && node.transition);\n    var implementation = T.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = T.Transitions[implementation.reverse];\n\n    return {\n        'in': function () {\n            $(element).show();\n            return implementation && implementation['in'](element);\n        },\n        \n        out: function (remove) {\n            setTransitionMode();\n            \n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n            \n            function removeElement() {\n                if (remove === false) {\n                    $(element).hide().attr('style', '');\n                } else\n                    $(element).remove();\n            }\n        },\n        \n        to: function (paneOptions, remove) {\n            var context = T.context();\n            if (node)\n                T.Utils.insertPaneAfter(node, element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                T.insertNodeAfter(element, T.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove);\n            return context.renderOperation.promise;\n        }\n    };\n    \n    function setTransitionMode() {\n        var $element = $(element);\n        if (T.transition.mode === 'fixed')\n            $element.css({\n                position: 'fixed',\n                width: $element.width(),\n                left: $element.offset().left,\n                top: $element.offset().top\n            });\n        else\n            $element.css({\n                position: 'absolute',\n                width: $element.width(),\n                left: $element.position().left,\n                top: $element.position().top\n            });\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to T.transition\";\n        \n        if (target.constructor === T.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === T.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }    \n};\n//@ sourceURL=http://Tribe.Composite/Transitions/transition.js");


window.eval("\n(function () {\n    var supported = supportsTransitions();\n    \n    createCssTransition('fade');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n\n    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';\n\n    function createCssTransition(transition, reverse) {\n        T.Transitions[transition] = {\n            'in': function (element) {\n                if (!supported) return null;\n                \n                var promise = $.Deferred();\n                $(element).bind(transitionEndEvents, transitionEnded(element, promise))\n                    .addClass('prepare in ' + transition);\n\n                trigger(element);\n                return promise;\n            },\n\n            out: function (element) {\n                if (!supported) return null;\n                var promise = $.Deferred();\n\n                $(element).addClass('prepare out ' + transition)\n                    .on(transitionEndEvents, transitionEnded(element, promise, true));\n\n                trigger(element);\n                return promise;\n            },\n            reverse: reverse || transition\n        };\n\n        function trigger(element) {\n            setTimeout(function () {\n                $(element).addClass('trigger');\n            }, 30);\n        }\n\n        function transitionEnded(element, promise, hide) {\n            return function() {\n                $(element).unbind(transitionEndEvents)\n                    .removeClass(transition + ' in out prepare trigger');\n                if (hide) $(element).hide();\n                promise.resolve();\n            };\n        }\n    }\n    \n    function supportsTransitions() {\n        var b = document.body || document.documentElement;\n        var style = b.style;\n        var property = 'transition';\n        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n        if (typeof style[property] == 'string') { return true; }\n\n        // Tests for vendor specific prop\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        for (var i = 0, l = vendors.length; i < l; i++) {\n            if (typeof style[vendors[i] + property] == 'string') { return true; }\n        }\n        \n        return false;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/css.js");


window.eval("\n\n//\nwindow.__appendStyle = function (content) {\n    var element = document.getElementById('__tribeStyles');\n    if (!element) {\n        element = document.createElement('style');\n        element.className = '__tribe';\n        element.id = '__tribeStyles';\n        document.getElementsByTagName('head')[0].appendChild(element);\n    }\n\n    if(element.styleSheet)\n        element.styleSheet.cssText += content;\n    else\n        element.appendChild(document.createTextNode(content));\n};//\nwindow.__appendStyle('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}');\n//@ sourceURL=http://Tribe.Composite/Transitions/Css/style.css.js");


window.eval("\n(function () {\n    T.registerModel = function () {\n        addResource('models', T.Utils.arguments(arguments));\n    };\n\n    T.registerSaga = function () {\n        addResource('sagas', T.Utils.arguments(arguments));\n    };\n    \n    function addResource(contextProperty, args) {\n        var environment = T.scriptEnvironment || {};\n        var context = environment.context || T.context();\n\n        var path = args.string || environment.resourcePath;\n        var constructor = args.func;\n        var options = args.object;\n\n        context[contextProperty].register(path, constructor, options);\n    }\n\n    T.run = function(options) {\n        T.options = $.extend(T.options, options);\n        T.options.pubsub = T.options.pubsub || new Tribe.PubSub({ sync: T.options.synchronous, handleExceptions: T.options.handleExceptions });\n        ko.applyBindings();\n        //if (preload) {\n        //    var promises = [];\n        //    var context = T.context();\n\n        //    if ($.isArray(preload))\n        //        for (var i = 0, l = preload.length; i < l; i++)\n        //            addPromise(preload[i]);\n        //    else if(preload.constructor === String)\n        //        addPromise(preload);\n            \n        //    function addPromise(path) {\n        //        promises.push(context.loader.get(T.Path(context.options.basePath).combine(path).toString(), null, context));\n        //    }\n\n        //    return $.when.apply(null, promises).done(function () {\n        //        ko.applyBindings(model);\n        //    });\n        //} else\n        //    ko.applyBindings(model);\n    };\n})(); \n//@ sourceURL=http://Tribe.Composite/Api/api.js");


window.eval("\n(function () {\n    var staticState;\n\n    T.context = function (source) {\n        staticState = staticState || {\n            models: new T.Types.Resources(),\n            sagas: new T.Types.Resources(),\n            loader: new T.Types.Loader(),\n            options: T.options,\n            templates: new T.Types.Templates(),\n            loadedPanes: {}\n        };\n        var perContextState = {\n            renderOperation: new T.Types.Operation(),\n            pubsub: T.options.pubsub\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/context.js");


window.eval("\nT.options.defaultUrlProvider = {\n    urlDataFrom: function(paneOptions) {\n        return paneOptions && { url: '#' + $.param(paneOptions) };\n    },\n    paneOptionsFrom: function(url) {\n        return url && T.Utils.deparam(url.substr(1));\n    }\n};\n//@ sourceURL=http://Tribe.Composite/Api/defaultUrlProvider.js");


window.eval("\n(function () {\n    var utils = T.Utils;\n\n    T.createNode = function (element, paneOptions, parentNode, context) {\n        parentNode = parentNode || T.nodeFor(element);\n        context = context || utils.contextFor(element) || T.context();\n\n        var node = new T.Types.Node(parentNode);\n        utils.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    T.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return T.createNode(element, paneOptions, parentNode, context);\n    };\n\n    T.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return T.createNode(element, paneOptions, parentNode || T.nodeFor(target), context);\n    };\n\n    T.nodeFor = function (element) {\n        return element && T.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n})();\n\n//@ sourceURL=http://Tribe.Composite/Api/nodes.js");


window.eval("\n(function() {\n    ko.bindingHandlers.foreachProperty = {\n        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.init(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        },\n        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            return ko.bindingHandlers.foreach.update(element, makeAccessor(mapToArray(valueAccessor())), allBindingsAccessor, viewModel, bindingContext);\n        }\n    };\n    \n    function makeAccessor(source) {\n        return function() {\n            return source;\n        };\n    }\n\n    function mapToArray(source) {\n        var result = [];\n        for (var property in source)\n            if (source.hasOwnProperty(property))\n                // we don't want to modify the original object, extend it onto a new object\n                result.push($.extend({ $key: property }, source[property]));\n        return result;\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/foreachProperty.js");


window.eval("\nko.bindingHandlers.navigate = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, navigate, allBindingsAccessor, viewModel);\n\n        function navigate() {\n            return function () {\n                node.navigate(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigate.js");


window.eval("\nko.bindingHandlers.navigateBack = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = T.nodeFor(element);\n        if (!node) return;\n\n        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);\n\n        function navigateBack() {\n            return function () {\n                node.navigateBack();\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/navigateBack.js");


window.eval("\n(function() {\n    ko.bindingHandlers.pane = { init: updateBinding };\n\n    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        T.createNode(element, constructPaneOptions(), T.Utils.extractNode(bindingContext), T.Utils.extractContext(bindingContext));\n\n        return { controlsDescendantBindings: true };\n\n        function constructPaneOptions() {\n            return T.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n    }\n})();\n\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/pane.js");


window.eval("\nko.bindingHandlers.publish = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var pubsub = T.nodeFor(element).pane.pubsub;\n        if (!pubsub) return;\n\n        var data = T.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, publishAccessor, allBindingsAccessor, viewModel);\n\n        function publishAccessor() {\n            return function () {\n                pubsub.publish(data.value, T.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=http://Tribe.Composite/BindingHandlers/publish.js");

},{}],"2OrlGQ":[function(require,module,exports){
module.exports = {
    saga: T.registerSaga,
    handler: function () {
        throw new Error("You can't register a static handler on the client (yet)!");
    },
    service: function () {
        throw new Error("You can't register a service on the client!");
    }
};
},{}],"tribe/register":[function(require,module,exports){
module.exports=require('2OrlGQ');
},{}]},{},[8,7,1,2,3,4,5,6])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcUHJvamVjdHNcXFRyaWJlXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1Byb2plY3RzL1RyaWJlL05vZGUvVGVzdEhhcm5lc3MvUGFuZXMvZml4dHVyZS5qcyIsIkM6L1Byb2plY3RzL1RyaWJlL05vZGUvVGVzdEhhcm5lc3MvUGFuZXMvbGF5b3V0LmpzIiwiQzovUHJvamVjdHMvVHJpYmUvTm9kZS9UZXN0SGFybmVzcy9QYW5lcy9saXN0LmpzIiwiQzovUHJvamVjdHMvVHJpYmUvTm9kZS9UZXN0SGFybmVzcy9QYW5lcy90ZXN0LmpzIiwiQzovUHJvamVjdHMvVHJpYmUvTm9kZS9UZXN0SGFybmVzcy9QYW5lcy90b29sYmFyLmpzIiwiQzovUHJvamVjdHMvVHJpYmUvTm9kZS9UZXN0SGFybmVzcy9TYWdhcy9zZXNzaW9uLmpzIiwiYzovUHJvamVjdHMvVHJpYmUvTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L2J1aWxkL1RyaWJlLk5vZGUuQ2xpZW50LmRlYnVnLmpzIiwiYzovUHJvamVjdHMvVHJpYmUvTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L2J1aWxkL1RyaWJlLmRlYnVnLmpzIiwiYzovUHJvamVjdHMvVHJpYmUvTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvcmVnaXN0ZXIuY2xpZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvZml4dHVyZScgfTtcbu+7v1QucmVnaXN0ZXJNb2RlbChmdW5jdGlvbiAocGFuZSkge1xyXG4gICAgdGhpcy5maXh0dXJlID0gcGFuZS5kYXRhO1xyXG59KTsiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvbGF5b3V0JyB9O1xu77u/VC5yZWdpc3Rlck1vZGVsKGZ1bmN0aW9uIChwYW5lKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgc2FnYSxcclxuICAgICAgICBjaGFubmVsID0gcGFuZS5wdWJzdWIuY2hhbm5lbCgnX190ZXN0JykuY29ubmVjdCgpO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gVC5zZXJ2aWNlcygnVGVzdHMnKS5pbnZva2UoKS50aGVuKGZ1bmN0aW9uIChmaXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHNhZ2EgPSBjaGFubmVsLnN0YXJ0U2FnYShudWxsLCAnc2Vzc2lvbicsIGZpeHR1cmUpO1xyXG4gICAgICAgICAgICBzZWxmLmZpeHR1cmUgPSBmaXh0dXJlO1xyXG4gICAgICAgIH0pOyAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIC8vdGhpcy5yZW5kZXJDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vICAgIGNoYW5uZWwucHVibGlzaCgndGVzdC5ydW4nKTtcclxuICAgIC8vfTtcclxufSk7IiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL2xpc3QnIH07XG7vu79ULnJlZ2lzdGVyTW9kZWwoZnVuY3Rpb24gKHBhbmUpIHtcclxuICAgIHRoaXMudGVzdHMgPSBmbGF0dGVuKHBhbmUuZGF0YSk7XHJcblxyXG4gICAgLy8gc2hvdWxkIHdyaXRlIGEgdGVzdCBmb3IgdGhpc1xyXG4gICAgZnVuY3Rpb24gZmxhdHRlbihmaXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIHRlc3RzID0gZml4dHVyZS50ZXN0cyxcclxuICAgICAgICAgICAgZml4dHVyZXMgPSBmaXh0dXJlLmZpeHR1cmVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBmaXh0dXJlTmFtZSBpbiBmaXh0dXJlcylcclxuICAgICAgICAgICAgaWYoZml4dHVyZXMuaGFzT3duUHJvcGVydHkoZml4dHVyZU5hbWUpKVxyXG4gICAgICAgICAgICAgICAgdGVzdHMgPSB0ZXN0cy5jb25jYXQoZmxhdHRlbihmaXh0dXJlc1tmaXh0dXJlTmFtZV0pKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGVzdHM7XHJcbiAgICAgICAgLy9yZXR1cm4gXy5mbGF0dGVuKF8ubWFwKGZpeHR1cmUuZml4dHVyZXMsIGZsYXR0ZW4pLCBmaXh0dXJlLnRlc3RzKTtcclxuICAgIH1cclxufSk7IiwiVC5zY3JpcHRFbnZpcm9ubWVudCA9IHsgcmVzb3VyY2VQYXRoOiAnL3Rlc3QnIH07XG7vu79ULnJlZ2lzdGVyTW9kZWwoZnVuY3Rpb24gKHBhbmUpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICB0ZXN0ID0gcGFuZS5kYXRhO1xyXG5cclxuICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblxyXG4gICAgdGhpcy5lcnJvciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXJyb3IgPSB0ZXN0LmVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZml4dHVyZSA9IHRlc3QuZml4dHVyZSA/XHJcbiAgICAgICAgdGVzdC5maXh0dXJlLmpvaW4oJy4nKSA6XHJcbiAgICAgICAgJ05vIGZpeHR1cmUnO1xyXG5cclxuICAgIHRoaXMuc2hvd0RldGFpbHMgPSBrby5vYnNlcnZhYmxlKHRlc3Quc3RhdGUoKSA9PT0gJ2ZhaWxlZCcpO1xyXG5cclxuICAgIHRoaXMudG9nZ2xlRGV0YWlscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNob3dEZXRhaWxzKCFzZWxmLnNob3dEZXRhaWxzKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwYW5lLnB1YnN1Yi5wdWJsaXNoKHsgdG9waWM6ICd0ZXN0LnJ1bicsIGRhdGE6IFt7IGZpeHR1cmU6IHRlc3QuZml4dHVyZSwgdGl0bGU6IHRlc3QudGl0bGUgfV0sIGNoYW5uZWxJZDogJ19fdGVzdCcgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRlc3Quc2VsZWN0ZWQoIXRlc3Quc2VsZWN0ZWQoKSk7XHJcbiAgICB9O1xyXG59KTsiLCJULnNjcmlwdEVudmlyb25tZW50ID0geyByZXNvdXJjZVBhdGg6ICcvdG9vbGJhcicgfTtcbu+7v1QucmVnaXN0ZXJNb2RlbChmdW5jdGlvbiAocGFuZSkge1xyXG4gICAgdGhpcy5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcGFuZS5wdWJzdWIucHVibGlzaCh7IHRvcGljOiAndGVzdC5ydW4nLCBjaGFubmVsSWQ6ICdfX3Rlc3QnIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlYnVnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWJ1Z1dpbmRvdyA9IHdpbmRvdy5vcGVuKCdodHRwOi8vbG9jYWxob3N0OjgwODAvZGVidWc/cG9ydD01ODU5JywgJ2RlYnVnZ2VyJyk7XHJcbiAgICAgICAgZGVidWdXaW5kb3cuZm9jdXMoKTtcclxuICAgIH07XHJcbn0pOyIsIlQuc2NyaXB0RW52aXJvbm1lbnQgPSB7IHJlc291cmNlUGF0aDogJy9zZXNzaW9uJyB9O1xu77u/cmVxdWlyZSgndHJpYmUvcmVnaXN0ZXInKS5zYWdhKGZ1bmN0aW9uIChzYWdhKSB7XHJcbiAgICB2YXIgZml4dHVyZTtcclxuXHJcbiAgICBzYWdhLmhhbmRsZXMgPSB7XHJcbiAgICAgICAgb25zdGFydDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy9maXh0dXJlID0gZXh0ZW5kRml4dHVyZShkYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICd0ZXN0LmNvbXBsZXRlJzogdXBkYXRlVGVzdCxcclxuICAgICAgICAndGVzdC5sb2FkZWQnOiB1cGRhdGVUZXN0LFxyXG4gICAgICAgIC8vJ3Rlc3QucmVtb3ZlZCc6IHJlbW92ZVRlc3RcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGVzdCh1cGRhdGUpIHtcclxuICAgICAgICB2YXIgdGVzdCA9IGZpbmRUZXN0KHVwZGF0ZSk7XHJcbiAgICAgICAgdGVzdC5zdGFsZSh1cGRhdGUuc3RhdGUgPT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYodXBkYXRlLnN0YXRlKSB0ZXN0LnN0YXRlKHVwZGF0ZS5zdGF0ZSk7XHJcbiAgICAgICAgdGVzdC5lcnJvcih1cGRhdGUuZXJyb3IpO1xyXG4gICAgICAgIHRlc3QuZHVyYXRpb24odXBkYXRlLmR1cmF0aW9uKTtcclxuICAgIH1cclxufSk7XHJcbiIsIlxud2luZG93LmV2YWwoXCJcXG5pZiAodHlwZW9mIChUKSA9PSAndW5kZWZpbmVkJykgVCA9IHt9O1xcblQuVHlwZXMgPSBULlR5cGVzIHx8IHt9O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLk5vZGUvbm9kZV9tb2R1bGVzL3RyaWJlL2NsaWVudC9zZXR1cC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuc3RhcnRTYWdhID0gZnVuY3Rpb24gKGlkLCBwYXRoLCBkYXRhKSB7XFxuICAgICAgICBpZiAocGF0aC5jaGFyQXQoMCkgIT09ICcvJylcXG4gICAgICAgICAgICBwYXRoID0gJy8nICsgcGF0aDtcXG5cXG4gICAgICAgIHZhciBzYWdhID0gbmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHRoaXMsIHNhZ2FEZWZpbml0aW9uKHBhdGgpKTtcXG5cXG4gICAgICAgIGlmIChpZCkge1xcbiAgICAgICAgICAgIHNhZ2EuaWQgPSBpZDtcXG4gICAgICAgICAgICBhdHRhY2hUb0h1YihzYWdhKTtcXG4gICAgICAgICAgICBULmh1Yi5zdGFydFNhZ2EocGF0aCwgaWQsIGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHNhZ2Euc3RhcnQoZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuam9pblNhZ2EgPSBmdW5jdGlvbiAoaWQsIHBhdGgsIGRhdGEpIHtcXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICAgICQud2hlbigkLmdldCgnRGF0YS8nICsgaWQgKyAnLycgKyBpZCkpXFxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHNhZ2EgPSBuZXcgVHJpYmUuUHViU3ViLlNhZ2Eoc2VsZiwgc2FnYURlZmluaXRpb24oZGF0YS5wYXRoKSk7XFxuICAgICAgICAgICAgICAgIHNhZ2EuaWQgPSBpZDtcXG4gICAgICAgICAgICAgICAgc2FnYS5qb2luKFQuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShkYXRhLmRhdGEpKTtcXG4gICAgICAgICAgICAgICAgYXR0YWNoVG9IdWIoc2FnYSk7XFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2FnYSk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAuZmFpbChmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgICAgICAgICAgIGlmIChyZWFzb24uc3RhdHVzID09PSA0MDQgJiYgcGF0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZ2EgPSBzZWxmLnN0YXJ0U2FnYShpZCwgcGF0aCwgZGF0YSk7XFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNhZ2EpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2UgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XFxuXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHNhZ2FEZWZpbml0aW9uKHBhdGgpIHtcXG4gICAgICAgIHJldHVybiBULmNvbnRleHQoKS5zYWdhc1twYXRoXS5jb25zdHJ1Y3RvcjtcXG4gICAgfVxcblxcbiAgICAvLyBuZWVkIHRvIGFsc28gYmUgYWJsZSB0byBkZXRhY2hcXG4gICAgZnVuY3Rpb24gYXR0YWNoVG9IdWIoc2FnYSkge1xcbiAgICAgICAgVC5odWIuam9pbihzYWdhLmlkKTtcXG4gICAgICAgIHNhZ2EucHVic3ViLnN1YnNjcmliZShzYWdhLnRvcGljcywgZnVuY3Rpb24gKG1lc3NhZ2UsIGVudmVsb3BlKSB7XFxuICAgICAgICAgICAgZW52ZWxvcGUuc2FnYUlkID0gc2FnYS5pZDtcXG4gICAgICAgICAgICBULmh1Yi5wdWJsaXNoKGVudmVsb3BlKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIFRyaWJlLlB1YlN1Yi5MaWZldGltZS5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2E7XFxuICAgIFRyaWJlLlB1YlN1Yi5MaWZldGltZS5wcm90b3R5cGUuam9pblNhZ2EgPSBUcmliZS5QdWJTdWIucHJvdG90eXBlLmpvaW5TYWdhO1xcbiAgICBUcmliZS5QdWJTdWIuQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLnByb3RvdHlwZS5zdGFydFNhZ2E7XFxuICAgIFRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5qb2luU2FnYSA9IFRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuam9pblNhZ2E7XFxuXFxuICAgIFRyaWJlLlB1YlN1Yi5DaGFubmVsLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHRvcGljcykge1xcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgICAgVC5odWIuam9pbih0aGlzLmlkKTtcXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRvcGljcyB8fCAnKicsIGZ1bmN0aW9uKGRhdGEsIGVudmVsb3BlKSB7XFxuICAgICAgICAgICAgVC5odWIucHVibGlzaChlbnZlbG9wZSk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcXG4gICAgICAgIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgVC5odWIubGVhdmUoc2VsZi5jaGFubmVsSWQpO1xcbiAgICAgICAgICAgIGVuZCgpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L1B1YlN1Yi5leHRlbnNpb25zLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5zZXJ2aWNlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgICBpbnZva2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJC5nZXQoJ1NlcnZpY2VzJywgeyBuYW1lOiBuYW1lLCBhcmdzOiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSB9KVxcbiAgICAgICAgICAgICAgICAuZmFpbChmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgIFQubG9nZ2VyLmVycm9yKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L3NlcnZpY2VzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5IdWIgPSBmdW5jdGlvbiAoaW8sIHB1YnN1Yiwgb3B0aW9ucykge1xcbiAgICB2YXIgc29ja2V0ID0gaW8uY29ubmVjdChvcHRpb25zLnNvY2tldFVybCk7XFxuXFxuICAgIHNvY2tldC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChlbnZlbG9wZSkge1xcbiAgICAgICAgZW52ZWxvcGUub3JpZ2luID0gJ3NlcnZlcic7XFxuICAgICAgICBwdWJzdWIucHVibGlzaChlbnZlbG9wZSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbihlbnZlbG9wZSkge1xcbiAgICAgICAgaWYgKCFzb2NrZXQpXFxuICAgICAgICAgICAgdGhyb3cgJ0h1YiBtdXN0IGJlIGNvbm5lY3RlZCBiZWZvcmUgY2FsbGluZyBwdWJsaXNoJztcXG4gICAgICAgIGlmKGVudmVsb3BlLm9yaWdpbiAhPT0gJ3NlcnZlcicpXFxuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ21lc3NhZ2UnLCBlbnZlbG9wZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbWVzc2FnZSBhY2tub3dsZWRnZWQnKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5qb2luID0gZnVuY3Rpb24oY2hhbm5lbCkge1xcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW4nLCBjaGFubmVsKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdGFydFNhZ2EgPSBmdW5jdGlvbihwYXRoLCBpZCwgZGF0YSkge1xcbiAgICAgICAgc29ja2V0LmVtaXQoJ3N0YXJ0U2FnYScsIHsgcGF0aDogcGF0aCwgaWQ6IGlkLCBkYXRhOiBkYXRhIH0pO1xcbiAgICB9O1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuTm9kZS9ub2RlX21vZHVsZXMvdHJpYmUvY2xpZW50L3R5cGVzL0h1Yi5qc1wiKTtcbiIsIi8qISBUaGUgVHJpYmUgcGxhdGZvcm0gaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgaHR0cDovL3RyaWJlanMuY29tLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gKi9cclxuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGxldmVsID0gNDtcXG4gICAgdmFyIGxldmVscyA9IHtcXG4gICAgICAgIGRlYnVnOiA0LFxcbiAgICAgICAgaW5mbzogMyxcXG4gICAgICAgIHdhcm46IDIsXFxuICAgICAgICBlcnJvcjogMSxcXG4gICAgICAgIG5vbmU6IDBcXG4gICAgfTtcXG5cXG4gICAgdmFyIGFwaSA9IHtcXG4gICAgICAgIHNldExldmVsOiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcXG4gICAgICAgICAgICBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XFxuICAgICAgICAgICAgaWYgKGxldmVsID09PSB1bmRlZmluZWQpIGxldmVsID0gNDtcXG4gICAgICAgIH0sXFxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcXG4gICAgICAgICAgICBpZiAobGV2ZWwgPj0gNClcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coKCdERUJVRzogJyArIG1lc3NhZ2UpKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbmZvOiBmdW5jdGlvbiAobWVzc2FnZSkge1xcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKVxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oKCdJTkZPOiAnICsgbWVzc2FnZSkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uIChtZXNzYWdlKSB7XFxuICAgICAgICAgICAgaWYgKGxldmVsID49IDIpXFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoJ1dBUk46ICcgKyBtZXNzYWdlKSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvcikge1xcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSAxKVxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCgnRVJST1I6ICcgKyBtZXNzYWdlICsgJ1xcXFxuJyksIGFwaS5lcnJvckRldGFpbHMoZXJyb3IpKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlcnJvckRldGFpbHM6IGZ1bmN0aW9uIChleCkge1xcbiAgICAgICAgICAgIGlmICghZXgpIHJldHVybiAnJztcXG4gICAgICAgICAgICByZXR1cm4gKGV4LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpID8gZXggOlxcbiAgICAgICAgICAgICAgICAoZXguc3RhY2sgfHwgJycpICsgKGV4LmlubmVyID8gJ1xcXFxuXFxcXG4nICsgdGhpcy5lcnJvckRldGFpbHMoZXguaW5uZXIpIDogJ1xcXFxuJyk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIGFwaS5sb2cgPSBhcGkuZGVidWc7XFxuICAgIFxcbiAgICBpZiAodHlwZW9mIChleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIChtb2R1bGUpICE9PSAndW5kZWZpbmVkJylcXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXBpO1xcbiAgICBlbHNlIHtcXG4gICAgICAgIGlmICh0eXBlb2YgKFQpID09PSAndW5kZWZpbmVkJylcXG4gICAgICAgICAgICBUID0ge307XFxuICAgICAgICBULmxvZ2dlciA9IGFwaTtcXG4gICAgfVxcbn0pKCk7XFxuXFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tbW9uL1NvdXJjZS9sb2dnZXIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICAvLyBtYW4uLi4gdGhpcyBjcm9zcy1wbGF0Zm9ybSBzdHVmZiBzdWNrcy4uLlxcbiAgICB2YXIga287XFxuICAgIGlmICh0eXBlb2YgKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAga28gPSB3aW5kb3cua287XFxuICAgIGlmICh0eXBlb2YgKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJylcXG4gICAgICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcXG5cXG4gICAgdmFyIGFwaSA9IHtcXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhY3RNZXRhZGF0YShzb3VyY2UpKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBleHRyYWN0TWV0YWRhdGE6IGZ1bmN0aW9uIChzb3VyY2UpIHtcXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc291cmNlLFxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xcbiAgICAgICAgICAgIHJlbW92ZU9ic2VydmFibGVzKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2YWJsZXMoKSB7XFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLm9ic2VydmFibGVzID0gW107XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRhcmdldClcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIGtvLmlzT2JzZXJ2YWJsZSh0YXJnZXRbcHJvcGVydHldKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSB0YXJnZXRbcHJvcGVydHldKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEub2JzZXJ2YWJsZXMucHVzaChwcm9wZXJ0eSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICAgICAgc291cmNlID0gSlNPTi5wYXJzZShzb3VyY2UpO1xcbiAgICAgICAgICAgIGlmIChzb3VyY2UudGFyZ2V0KVxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1ldGFkYXRhKHNvdXJjZS50YXJnZXQsIHNvdXJjZS5tZXRhZGF0YSk7XFxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcXG4gICAgICAgIH0sXFxuICAgICAgICBhcHBseU1ldGFkYXRhOiBmdW5jdGlvbiAodGFyZ2V0LCBtZXRhZGF0YSkge1xcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSlcXG4gICAgICAgICAgICAgICAgcmVzdG9yZU9ic2VydmFibGVzKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiByZXN0b3JlT2JzZXJ2YWJsZXMoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IG1ldGFkYXRhLm9ic2VydmFibGVzO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9ic2VydmFibGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVQcm9wZXJ0eShvYnNlcnZhYmxlc1tpXSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3RvcmVQcm9wZXJ0eShwcm9wZXJ0eSkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gY3JlYXRlT2JzZXJ2YWJsZSh0YXJnZXRbcHJvcGVydHldKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZSh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5ID9cXG4gICAgICAgICAgICAgICAgICAgIGtvLm9ic2VydmFibGVBcnJheSh2YWx1ZSkgOlxcbiAgICAgICAgICAgICAgICAgICAga28ub2JzZXJ2YWJsZSh2YWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBpZiAodHlwZW9mIChleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIChtb2R1bGUpICE9PSAndW5kZWZpbmVkJylcXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXBpO1xcbiAgICBlbHNlIHtcXG4gICAgICAgIGlmICh0eXBlb2YgKFQpID09PSAndW5kZWZpbmVkJylcXG4gICAgICAgICAgICBUID0ge307XFxuICAgICAgICBULnNlcmlhbGl6ZXIgPSBhcGk7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbW1vbi9Tb3VyY2Uvc2VyaWFsaXplci5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmlmICh0eXBlb2YgKFRyaWJlKSA9PT0gJ3VuZGVmaW5lZCcpXFxuICAgIFRyaWJlID0ge307XFxuXFxuVHJpYmUuUHViU3ViID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgdXRpbHMgPSBUcmliZS5QdWJTdWIudXRpbHM7XFxuXFxuICAgIHRoaXMub3duZXIgPSB0aGlzO1xcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgICB0aGlzLnN5bmMgPSBvcHRpb24oJ3N5bmMnKTtcXG4gICAgIFxcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSBuZXcgVHJpYmUuUHViU3ViLlN1YnNjcmliZXJMaXN0KCk7XFxuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycztcXG5cXG4gICAgZnVuY3Rpb24gcHVibGlzaChlbnZlbG9wZSkge1xcbiAgICAgICAgdmFyIG1lc3NhZ2VTdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmdldChlbnZlbG9wZS50b3BpYyk7XFxuICAgICAgICB2YXIgc3luYyA9IGVudmVsb3BlLnN5bmMgPT09IHRydWUgfHwgc2VsZi5zeW5jID09PSB0cnVlO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtZXNzYWdlU3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKHN5bmMpXFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVTdWJzY3JpYmVyKG1lc3NhZ2VTdWJzY3JpYmVyc1tpXS5oYW5kbGVyKTtcXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlU3Vic2NyaWJlcihzdWJzY3JpYmVyLmhhbmRsZXIpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH0pKG1lc3NhZ2VTdWJzY3JpYmVyc1tpXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZVN1YnNjcmliZXIoZnVuYykge1xcbiAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyID0gb3B0aW9uKCdleGNlcHRpb25IYW5kbGVyJyk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYob3B0aW9uKCdoYW5kbGVFeGNlcHRpb25zJykgICYmIGV4Y2VwdGlvbkhhbmRsZXIpXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBmdW5jKGVudmVsb3BlLmRhdGEsIGVudmVsb3BlKTtcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlLCBlbnZlbG9wZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIGZ1bmMoZW52ZWxvcGUuZGF0YSwgZW52ZWxvcGUpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBwdWJsaXNoKGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnB1Ymxpc2hTeW5jID0gZnVuY3Rpb24gKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgdmFyIGVudmVsb3BlID0gY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKTtcXG4gICAgICAgIGVudmVsb3BlLnN5bmMgPSB0cnVlO1xcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2goZW52ZWxvcGUpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSB7XFxuICAgICAgICByZXR1cm4gdG9waWNPckVudmVsb3BlICYmIHRvcGljT3JFbnZlbG9wZS50b3BpY1xcbiAgICAgICAgICAgID8gdG9waWNPckVudmVsb3BlXFxuICAgICAgICAgICAgOiB7IHRvcGljOiB0b3BpY09yRW52ZWxvcGUsIGRhdGE6IGRhdGEgfTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0b3BpYywgZnVuYykge1xcbiAgICAgICAgaWYgKHR5cGVvZiAodG9waWMpID09PSBcXFwic3RyaW5nXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljLCBmdW5jKTtcXG4gICAgICAgIGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkodG9waWMpKVxcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5tYXAodG9waWMsIGZ1bmN0aW9uKHRvcGljTmFtZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHRvcGljTmFtZSwgZnVuYyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh0b3BpYywgZnVuY3Rpb24gKGluZGl2aWR1YWxGdW5jLCB0b3BpY05hbWUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXJzLmFkZCh0b3BpY05hbWUsIGluZGl2aWR1YWxGdW5jKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcXG4gICAgICAgIGlmIChUcmliZS5QdWJTdWIudXRpbHMuaXNBcnJheSh0b2tlbnMpKSB7XFxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspXFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzdWJzY3JpYmVycy5yZW1vdmUodG9rZW5zW2ldKSk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMucmVtb3ZlKHRva2Vucyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY3JlYXRlTGlmZXRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkxpZmV0aW1lKHNlbGYsIHNlbGYpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsSWQpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVHJpYmUuUHViU3ViLkNoYW5uZWwoc2VsZiwgY2hhbm5lbElkKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIG9wdGlvbihuYW1lKSB7XFxuICAgICAgICByZXR1cm4gKHNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgPyBzZWxmLm9wdGlvbnNbbmFtZV0gOiBUcmliZS5QdWJTdWIub3B0aW9uc1tuYW1lXTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL1B1YlN1Yi5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5DaGFubmVsID0gZnVuY3Rpb24gKHB1YnN1YiwgY2hhbm5lbElkKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgcHVic3ViID0gcHVic3ViLmNyZWF0ZUxpZmV0aW1lKCk7XFxuXFxuICAgIHRoaXMuaWQgPSBjaGFubmVsSWQ7XFxuICAgIHRoaXMub3duZXIgPSBwdWJzdWIub3duZXI7XFxuXFxuICAgIHRoaXMucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIucHVibGlzaChjcmVhdGVFbnZlbG9wZSh0b3BpY09yRW52ZWxvcGUsIGRhdGEpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5wdWJsaXNoU3luYyA9IGZ1bmN0aW9uICh0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIucHVibGlzaFN5bmMoY3JlYXRlRW52ZWxvcGUodG9waWNPckVudmVsb3BlLCBkYXRhKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9waWMsIGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBwdWJzdWIuc3Vic2NyaWJlKHRvcGljLCBmaWx0ZXJNZXNzYWdlcyhmdW5jKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlT25jZSA9IGZ1bmN0aW9uKHRvcGljLCBmdW5jKSB7XFxuICAgICAgICByZXR1cm4gcHVic3ViLnN1YnNjcmliZU9uY2UodG9waWMsIGZpbHRlck1lc3NhZ2VzKGZ1bmMpKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBmdW5jdGlvbih0b2tlbikge1xcbiAgICAgICAgcmV0dXJuIHB1YnN1Yi51bnN1YnNjcmliZSh0b2tlbik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gcHVic3ViLmVuZCgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNyZWF0ZUxpZmV0aW1lID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuTGlmZXRpbWUoc2VsZiwgc2VsZi5vd25lcik7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVudmVsb3BlKHRvcGljT3JFbnZlbG9wZSwgZGF0YSkge1xcbiAgICAgICAgdmFyIGVudmVsb3BlID0gdG9waWNPckVudmVsb3BlICYmIHRvcGljT3JFbnZlbG9wZS50b3BpY1xcbiAgICAgICAgICA/IHRvcGljT3JFbnZlbG9wZVxcbiAgICAgICAgICA6IHsgdG9waWM6IHRvcGljT3JFbnZlbG9wZSwgZGF0YTogZGF0YSB9O1xcbiAgICAgICAgZW52ZWxvcGUuY2hhbm5lbElkID0gY2hhbm5lbElkO1xcbiAgICAgICAgcmV0dXJuIGVudmVsb3BlO1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBmaWx0ZXJNZXNzYWdlcyhmdW5jKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZW52ZWxvcGUpIHtcXG4gICAgICAgICAgICBpZiAoZW52ZWxvcGUuY2hhbm5lbElkID09PSBjaGFubmVsSWQpXFxuICAgICAgICAgICAgICAgIGZ1bmMoZGF0YSwgZW52ZWxvcGUpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL0NoYW5uZWwuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIuTGlmZXRpbWUgPSBmdW5jdGlvbiAocGFyZW50LCBvd25lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciB0b2tlbnMgPSBbXTtcXG5cXG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xcblxcbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbih0b3BpY09yRW52ZWxvcGUsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBwYXJlbnQucHVibGlzaCh0b3BpY09yRW52ZWxvcGUsIGRhdGEpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnB1Ymxpc2hTeW5jID0gZnVuY3Rpb24odG9waWMsIGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBwYXJlbnQucHVibGlzaFN5bmModG9waWMsIGRhdGEpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRvcGljLCBmdW5jKSB7XFxuICAgICAgICB2YXIgdG9rZW4gPSBwYXJlbnQuc3Vic2NyaWJlKHRvcGljLCBmdW5jKTtcXG4gICAgICAgIHJldHVybiByZWNvcmRUb2tlbih0b2tlbik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3Vic2NyaWJlT25jZSA9IGZ1bmN0aW9uKHRvcGljLCBmdW5jKSB7XFxuICAgICAgICB2YXIgdG9rZW4gPSBwYXJlbnQuc3Vic2NyaWJlT25jZSh0b3BpYywgZnVuYyk7XFxuICAgICAgICByZXR1cm4gcmVjb3JkVG9rZW4odG9rZW4pO1xcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICAvLyB3ZSBzaG91bGQgcmVhbGx5IHJlbW92ZSB0aGUgdG9rZW4ocykgZnJvbSBvdXIgdG9rZW4gbGlzdCwgYnV0IGl0IGhhcyB0cml2aWFsIGltcGFjdCBpZiB3ZSBkb24ndFxcbiAgICAgICAgcmV0dXJuIHBhcmVudC51bnN1YnNjcmliZSh0b2tlbik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxJZCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuQ2hhbm5lbChzZWxmLCBjaGFubmVsSWQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC51bnN1YnNjcmliZSh0b2tlbnMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNyZWF0ZUxpZmV0aW1lID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFRyaWJlLlB1YlN1Yi5MaWZldGltZShzZWxmLCBzZWxmLm93bmVyKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIHJlY29yZFRva2VuKHRva2VuKSB7XFxuICAgICAgICBpZiAoVHJpYmUuUHViU3ViLnV0aWxzLmlzQXJyYXkodG9rZW4pKVxcbiAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodG9rZW4pO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcXG4gICAgICAgIHJldHVybiB0b2tlbjtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL0xpZmV0aW1lLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVHJpYmUuUHViU3ViLm9wdGlvbnMgPSB7XFxuICAgIHN5bmM6IGZhbHNlLFxcbiAgICBoYW5kbGVFeGNlcHRpb25zOiB0cnVlLFxcbiAgICBleGNlcHRpb25IYW5kbGVyOiBmdW5jdGlvbihlLCBlbnZlbG9wZSkge1xcbiAgICAgICAgdHlwZW9mKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmxvZyhcXFwiRXhjZXB0aW9uIG9jY3VycmVkIGluIHN1YnNjcmliZXIgdG8gJ1xcXCIgKyBlbnZlbG9wZS50b3BpYyArIFxcXCInOiBcXFwiICsgZS5tZXNzYWdlKTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL29wdGlvbnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIuU2FnYSA9IGZ1bmN0aW9uIChwdWJzdWIsIGRlZmluaXRpb24pIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgdXRpbHMgPSBUcmliZS5QdWJTdWIudXRpbHM7XFxuXFxuICAgIHB1YnN1YiA9IHB1YnN1Yi5jcmVhdGVMaWZldGltZSgpO1xcbiAgICB0aGlzLnB1YnN1YiA9IHB1YnN1YjtcXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xcblxcbiAgICBjb25maWd1cmVTYWdhKCk7XFxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcyB8fCB7fTtcXG5cXG4gICAgLy8gdGhpcyBpcyBub3QgaWU8OSBjb21wYXRpYmxlIGFuZCBpbmNsdWRlcyBvbnN0YXJ0IC8gb25lbmRcXG4gICAgdGhpcy50b3BpY3MgPSBPYmplY3Qua2V5cyhoYW5kbGVycyk7XFxuXFxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnREYXRhKSB7XFxuICAgICAgICB1dGlscy5lYWNoKGhhbmRsZXJzLCBzZWxmLmFkZEhhbmRsZXIsIHNlbGYpO1xcbiAgICAgICAgaWYgKGhhbmRsZXJzLm9uc3RhcnQpIGhhbmRsZXJzLm9uc3RhcnQoc3RhcnREYXRhLCBzZWxmKTtcXG4gICAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0YXJ0Q2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIG9uc3RhcnREYXRhKSB7XFxuICAgICAgICBzZWxmLmNoaWxkcmVuLnB1c2gobmV3IFRyaWJlLlB1YlN1Yi5TYWdhKHB1YnN1YiwgY2hpbGQpXFxuICAgICAgICAgICAgLnN0YXJ0KG9uc3RhcnREYXRhKSk7XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5qb2luID0gZnVuY3Rpb24gKGRhdGEsIG9uam9pbkRhdGEpIHtcXG4gICAgICAgIHV0aWxzLmVhY2goaGFuZGxlcnMsIHNlbGYuYWRkSGFuZGxlciwgc2VsZik7XFxuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xcbiAgICAgICAgaWYgKGhhbmRsZXJzLm9uam9pbikgaGFuZGxlcnMub25qb2luKG9uam9pbkRhdGEsIHNlbGYpO1xcbiAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZW5kID0gZnVuY3Rpb24gKG9uZW5kRGF0YSkge1xcbiAgICAgICAgaWYgKGhhbmRsZXJzLm9uZW5kKSBoYW5kbGVycy5vbmVuZChvbmVuZERhdGEsIHNlbGYpO1xcbiAgICAgICAgcHVic3ViLmVuZCgpO1xcbiAgICAgICAgc2VsZi5lbmRDaGlsZHJlbihvbmVuZERhdGEpO1xcbiAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZW5kQ2hpbGRyZW4gPSBmdW5jdGlvbihkYXRhKSB7XFxuICAgICAgICBUcmliZS5QdWJTdWIudXRpbHMuZWFjaChzZWxmLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xcbiAgICAgICAgICAgICBjaGlsZC5lbmQoZGF0YSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBcXG4gICAgZnVuY3Rpb24gY29uZmlndXJlU2FnYSgpIHtcXG4gICAgICAgIGlmIChkZWZpbml0aW9uKVxcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbihzZWxmKTtcXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIFRyaWJlLlB1YlN1Yi51dGlscy5jb3B5UHJvcGVydGllcyhkZWZpbml0aW9uLCBzZWxmLCBbJ2hhbmRsZXMnLCAnZW5kc0NoaWxkcmVuRXhwbGljaXRseSddKTtcXG4gICAgfVxcbn07XFxuXFxuVHJpYmUuUHViU3ViLlNhZ2Euc3RhcnRTYWdhID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGRhdGEpIHtcXG4gICAgcmV0dXJuIG5ldyBUcmliZS5QdWJTdWIuU2FnYSh0aGlzLCBkZWZpbml0aW9uKS5zdGFydChkYXRhKTtcXG59O1xcblxcblRyaWJlLlB1YlN1Yi5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLlNhZ2Euc3RhcnRTYWdhO1xcblRyaWJlLlB1YlN1Yi5MaWZldGltZS5wcm90b3R5cGUuc3RhcnRTYWdhID0gVHJpYmUuUHViU3ViLlNhZ2Euc3RhcnRTYWdhO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLlB1YlN1Yi9TYWdhLmNvcmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIuU2FnYS5wcm90b3R5cGUuYWRkSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCB0b3BpYykge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGlmICh0b3BpYyAhPT0gJ29uc3RhcnQnICYmIHRvcGljICE9PSAnb25lbmQnICYmIHRvcGljICE9PSAnb25qb2luJylcXG4gICAgICAgIGlmICghaGFuZGxlcilcXG4gICAgICAgICAgICB0aGlzLnB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGVuZEhhbmRsZXIoKSk7XFxuICAgICAgICBlbHNlIGlmIChoYW5kbGVyLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICB0aGlzLnB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIG1lc3NhZ2VIYW5kbGVyRm9yKGhhbmRsZXIpKTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICB0aGlzLnB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIGNoaWxkSGFuZGxlckZvcihoYW5kbGVyKSk7XFxuXFxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyRm9yKGhhbmRsZXIpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEsIGVudmVsb3BlKSB7XFxuICAgICAgICAgICAgaWYgKCFzZWxmLmVuZHNDaGlsZHJlbkV4cGxpY2l0bHkpXFxuICAgICAgICAgICAgICAgIHNlbGYuZW5kQ2hpbGRyZW4obWVzc2FnZURhdGEpO1xcbiAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZURhdGEsIGVudmVsb3BlLCBzZWxmKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2hpbGRIYW5kbGVyRm9yKGNoaWxkSGFuZGxlcnMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZURhdGEsIGVudmVsb3BlKSB7XFxuICAgICAgICAgICAgc2VsZi5zdGFydENoaWxkKHsgaGFuZGxlczogY2hpbGRIYW5kbGVycyB9LCBtZXNzYWdlRGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGVuZEhhbmRsZXIoKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2VEYXRhKSB7XFxuICAgICAgICAgICAgc2VsZi5lbmQobWVzc2FnZURhdGEpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcbn07XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuUHViU3ViL1NhZ2EuaGFuZGxlcnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIucHJvdG90eXBlLnN1YnNjcmliZU9uY2UgPSBmdW5jdGlvbiAodG9waWMsIGhhbmRsZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgdXRpbHMgPSBUcmliZS5QdWJTdWIudXRpbHM7XFxuICAgIHZhciBsaWZldGltZSA9IHRoaXMuY3JlYXRlTGlmZXRpbWUoKTtcXG5cXG4gICAgaWYgKHR5cGVvZiAodG9waWMpID09PSBcXFwic3RyaW5nXFxcIilcXG4gICAgICAgIHJldHVybiBsaWZldGltZS5zdWJzY3JpYmUodG9waWMsIHdyYXBIYW5kbGVyKGhhbmRsZXIpKTtcXG4gICAgZWxzZSBpZiAodXRpbHMuaXNBcnJheSh0b3BpYykpXFxuICAgICAgICByZXR1cm4gbGlmZXRpbWUuc3Vic2NyaWJlKHdyYXBUb3BpY0FycmF5KCkpO1xcbiAgICBlbHNlXFxuICAgICAgICByZXR1cm4gbGlmZXRpbWUuc3Vic2NyaWJlKHdyYXBUb3BpY09iamVjdCgpKTtcXG5cXG4gICAgZnVuY3Rpb24gd3JhcFRvcGljQXJyYXkoKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XFxuICAgICAgICB1dGlscy5lYWNoKHRvcGljLCBmdW5jdGlvbih0b3BpY05hbWUpIHtcXG4gICAgICAgICAgICByZXN1bHRbdG9waWNOYW1lXSA9IHdyYXBIYW5kbGVyKGhhbmRsZXIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiB3cmFwVG9waWNPYmplY3QoKSB7XFxuICAgICAgICByZXR1cm4gdXRpbHMubWFwKHRvcGljLCBmdW5jdGlvbiAoZnVuYywgdG9waWNOYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGxpZmV0aW1lLnN1YnNjcmliZSh0b3BpY05hbWUsIHdyYXBIYW5kbGVyKGZ1bmMpKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHdyYXBIYW5kbGVyKGZ1bmMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICBsaWZldGltZS5lbmQoKTtcXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9O1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvc3Vic2NyaWJlT25jZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblRyaWJlLlB1YlN1Yi5TdWJzY3JpYmVyTGlzdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB7fTtcXG4gICAgdmFyIGxhc3RVaWQgPSAtMTtcXG5cXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAocHVibGlzaGVkVG9waWMpIHtcXG4gICAgICAgIHZhciBtYXRjaGluZyA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgcmVnaXN0ZXJlZFRvcGljIGluIHN1YnNjcmliZXJzKVxcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RlcmVkVG9waWMpICYmIHRvcGljTWF0Y2hlcyhwdWJsaXNoZWRUb3BpYywgcmVnaXN0ZXJlZFRvcGljKSlcXG4gICAgICAgICAgICAgICAgbWF0Y2hpbmcgPSBtYXRjaGluZy5jb25jYXQoc3Vic2NyaWJlcnNbcmVnaXN0ZXJlZFRvcGljXSk7XFxuICAgICAgICByZXR1cm4gbWF0Y2hpbmc7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKHRvcGljLCBoYW5kbGVyKSB7XFxuICAgICAgICB2YXIgdG9rZW4gPSAoKytsYXN0VWlkKS50b1N0cmluZygpO1xcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVycy5oYXNPd25Qcm9wZXJ0eSh0b3BpYykpXFxuICAgICAgICAgICAgc3Vic2NyaWJlcnNbdG9waWNdID0gW107XFxuICAgICAgICBzdWJzY3JpYmVyc1t0b3BpY10ucHVzaCh7IHRvcGljOiB0b3BpYywgaGFuZGxlcjogaGFuZGxlciwgdG9rZW46IHRva2VuIH0pO1xcbiAgICAgICAgcmV0dXJuIHRva2VuO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICBmb3IgKHZhciBtIGluIHN1YnNjcmliZXJzKVxcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5oYXNPd25Qcm9wZXJ0eShtKSlcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzY3JpYmVyc1ttXS5sZW5ndGg7IGkgPCBsOyBpKyspXFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnNbbV1baV0udG9rZW4gPT09IHRva2VuKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbbV0uc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gdG9waWNNYXRjaGVzKHB1Ymxpc2hlZCwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgPT09ICcqJylcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIFxcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBcXFwiXlxcXCIgKyBzdWJzY3JpYmVyXFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwuL2csIFxcXCJcXFxcXFxcXC5cXFwiKVxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKi9nLCBcXFwiW15cXFxcLl0qXFxcIikgKyBcXFwiJFxcXCI7XFxuICAgICAgICByZXR1cm4gcHVibGlzaGVkLm1hdGNoKGV4cHJlc3Npb24pO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvU3Vic2NyaWJlckxpc3QuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5UcmliZS5QdWJTdWIudXRpbHMgPSB7fTtcXG4oZnVuY3Rpb24odXRpbHMpIHtcXG4gICAgdXRpbHMuaXNBcnJheSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcXG4gICAgICAgIHJldHVybiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5O1xcbiAgICB9O1xcblxcbiAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgdGFrZW4gZnJvbSB0aGUgdW5kZXJzY29yZSBsaWJyYXJ5LCBkdXBsaWNhdGVkIHRvIGF2b2lkIGRlcGVuZGVuY3kuIExpY2Vuc2UgYXQgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcuXFxuICAgIHZhciBuYXRpdmVGb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XFxuICAgIHZhciBuYXRpdmVNYXAgPSBBcnJheS5wcm90b3R5cGUubWFwO1xcbiAgICB2YXIgYnJlYWtlciA9IHt9O1xcblxcbiAgICB1dGlscy5lYWNoID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xcbiAgICAgICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcXG4gICAgICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XFxuICAgICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdXRpbHMubWFwID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XFxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xcbiAgICAgICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcXG4gICAgICAgIHV0aWxzLmVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XFxuICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5jb3B5UHJvcGVydGllcyA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgcHJvcGVydGllcykge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XFxuICAgICAgICAgICAgaWYoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XFxuICAgICAgICB9XFxuICAgIH07XFxufSkoVHJpYmUuUHViU3ViLnV0aWxzKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvdXRpbHMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKVxcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5ldyBUcmliZS5QdWJTdWIoKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5QdWJTdWIvZXhwb3J0cy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoZ2xvYmFsKSB7XFxuICAgIGlmICh0eXBlb2YgKGpRdWVyeSkgPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgdGhyb3cgJ2pRdWVyeSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUga25vY2tvdXQuY29tcG9zaXRlIGNhbiBpbml0aWFsaXNlJztcXG4gICAgaWYgKHR5cGVvZiAoa28pID09PSAndW5kZWZpbmVkJylcXG4gICAgICAgIHRocm93ICdrbm9ja291dC5qcyBtdXN0IGJlIGxvYWRlZCBiZWZvcmUga25vY2tvdXQuY29tcG9zaXRlIGNhbiBpbml0aWFsaXNlJztcXG4gICAgaWYgKHR5cGVvZihUKSA9PT0gJ3VuZGVmaW5lZCcpXFxuICAgICAgICB0aHJvdyAnVHJpYmUuQ29tbW9uIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBrbm9ja291dC5jb21wb3NpdGUgY2FuIGluaXRpYWxpc2UnO1xcblxcbiAgICBnbG9iYWwuVCA9IFQgfHwge307XFxuICAgIGdsb2JhbC5ULkV2ZW50cyA9IHt9O1xcbiAgICBnbG9iYWwuVC5GYWN0b3JpZXMgPSB7fTtcXG4gICAgZ2xvYmFsLlQuTG9hZEhhbmRsZXJzID0ge307XFxuICAgIGdsb2JhbC5ULkxvYWRTdHJhdGVnaWVzID0ge307XFxuICAgIGdsb2JhbC5ULlRyYW5zaXRpb25zID0ge307XFxuICAgIGdsb2JhbC5ULlR5cGVzID0ge307XFxuICAgIGdsb2JhbC5ULlV0aWxzID0ge307XFxuICAgIGdsb2JhbC5ULmxvZ2dlciA9IFQubG9nZ2VyO1xcbiAgICBnbG9iYWwuVC5wdWJzdWIgPSBuZXcgVHJpYmUuUHViU3ViKCk7XFxuXFxuICAgICQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAkKCdoZWFkJykuYXBwZW5kKCc8c3R5bGUgY2xhc3M9XFxcIl9fdHJpYmVcXFwiPi5fX3JlbmRlcmluZyB7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAtMTAwMDBweDsgbGVmdDogLTEwMDAwcHg7IH08L3N0eWxlPicpO1xcbiAgICB9KTtcXG59KSh3aW5kb3cgfHwgdGhpcyk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL3NldHVwLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgc3luY2hyb25vdXM6IGZhbHNlLFxcbiAgICAgICAgaGFuZGxlRXhjZXB0aW9uczogdHJ1ZSxcXG4gICAgICAgIGJhc2VQYXRoOiAnJyxcXG4gICAgICAgIGxvYWRTdHJhdGVneTogJ2FkaG9jJyxcXG4gICAgICAgIGV2ZW50czogWydsb2FkUmVzb3VyY2VzJywgJ2NyZWF0ZVB1YlN1YicsICdjcmVhdGVNb2RlbCcsICdpbml0aWFsaXNlTW9kZWwnLCAncmVuZGVyUGFuZScsICdyZW5kZXJDb21wbGV0ZScsICdhY3RpdmUnLCAnZGlzcG9zZSddXFxuICAgIH07XFxufTtcXG5ULm9wdGlvbnMgPSBULmRlZmF1bHRPcHRpb25zKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL29wdGlvbnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuY3NzQ2xhc3MgPSB7XFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlKSk7XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5lbnRlclByZXNzZWQgPSBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIoMTMpO1xcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZXNjYXBlUHJlc3NlZCA9IGtleVByZXNzZWRCaW5kaW5nSGFuZGxlcigyNyk7XFxuICAgIFxcbiAgICBmdW5jdGlvbiBrZXlQcmVzc2VkQmluZGluZ0hhbmRsZXIod2hpY2gpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdmFsdWVBY2Nlc3NvcigpO1xcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSlcXG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmtleXVwKHRlc3RLZXkpO1xcblxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXN0S2V5KGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IHdoaWNoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8kZWxlbWVudC5ibHVyKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJGVsZW1lbnQudmFsKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9iaW5kaW5nSGFuZGxlcnMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKHV0aWxzKSB7ICAgIFxcbiAgICB1dGlscy5lYWNoID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XFxuICAgICAgICByZXR1cm4gJC5lYWNoKGNvbGxlY3Rpb24gfHwgW10sIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IodmFsdWUsIGluZGV4KTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvLyBqUXVlcnkgbWFwIGZsYXR0ZW5zIHJldHVybmVkIGFycmF5cyAtIHdlIGRvbid0IHdhbnQgdGhpcyBmb3IgZ3JpZHNcXG4gICAgdXRpbHMubWFwID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICB1dGlscy5lYWNoKGNvbGxlY3Rpb24gfHwgW10sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yKHZhbHVlLCBpbmRleCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5maWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgaXRlcmF0b3IpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgICQuZWFjaChhcnJheSB8fCBbXSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XFxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKHZhbHVlLCBpbmRleCkpXFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfTtcXG5cXG4gICAgdXRpbHMucGx1Y2sgPSBmdW5jdGlvbihhcnJheSwgcHJvcGVydHkpIHtcXG4gICAgICAgIHJldHVybiB1dGlscy5tYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlW3Byb3BlcnR5XTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB1dGlscy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyYXksIGluaXRpYWxWYWx1ZSwgcmVkdWNlRnVuY3Rpb24pIHtcXG4gICAgICAgIHV0aWxzLmVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHJlZHVjZUZ1bmN0aW9uKGluaXRpYWxWYWx1ZSwgdmFsdWUsIGluZGV4LCBhcnJheSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XFxuICAgIH07XFxufSkoVC5VdGlscyk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9jb2xsZWN0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbi8vIHRoaXMgaXMgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1iYnEvLCBDb3B5cmlnaHQgKGMpIDIwMTAgXFxcIkNvd2JveVxcXCIgQmVuIEFsbWFuIGFuZCBhbHNvIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcblxcbi8vIERlc2VyaWFsaXplIGEgcGFyYW1zIHN0cmluZyBpbnRvIGFuIG9iamVjdCwgb3B0aW9uYWxseSBjb2VyY2luZyBudW1iZXJzLFxcbi8vIGJvb2xlYW5zLCBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzOyB0aGlzIG1ldGhvZCBpcyB0aGUgY291bnRlcnBhcnQgdG8gdGhlXFxuLy8gaW50ZXJuYWwgalF1ZXJ5LnBhcmFtIG1ldGhvZC5cXG5ULlV0aWxzLmRlcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1zLCBjb2VyY2UpIHtcXG4gICAgdmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcXG4gICAgdmFyIG9iaiA9IHt9LFxcbiAgICAgIGNvZXJjZV90eXBlcyA9IHsgJ3RydWUnOiAhMCwgJ2ZhbHNlJzogITEsICdudWxsJzogbnVsbCB9O1xcblxcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5hbWU9dmFsdWUgcGFpcnMuXFxuICAgICQuZWFjaChwYXJhbXMucmVwbGFjZSgvXFxcXCsvZywgJyAnKS5zcGxpdCgnJicpLCBmdW5jdGlvbiAoaiwgdikge1xcbiAgICAgICAgdmFyIHBhcmFtID0gdi5zcGxpdCgnPScpLFxcbiAgICAgICAgICBrZXkgPSBkZWNvZGUocGFyYW1bMF0pLFxcbiAgICAgICAgICB2YWwsXFxuICAgICAgICAgIGN1ciA9IG9iaixcXG4gICAgICAgICAgaSA9IDAsXFxuXFxuICAgICAgICAgIC8vIElmIGtleSBpcyBtb3JlIGNvbXBsZXggdGhhbiAnZm9vJywgbGlrZSAnYVtdJyBvciAnYVtiXVtjXScsIHNwbGl0IGl0XFxuICAgICAgICAgIC8vIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cXG4gICAgICAgICAga2V5cyA9IGtleS5zcGxpdCgnXVsnKSxcXG4gICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xcblxcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGtleXMgcGFydCBjb250YWlucyBbIGFuZCB0aGUgbGFzdCBlbmRzIHdpdGggXSwgdGhlbiBbXVxcbiAgICAgICAgLy8gYXJlIGNvcnJlY3RseSBiYWxhbmNlZC5cXG4gICAgICAgIGlmICgvXFxcXFsvLnRlc3Qoa2V5c1swXSkgJiYgL1xcXFxdJC8udGVzdChrZXlzW2tleXNfbGFzdF0pKSB7XFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyBdIGZyb20gdGhlIGxhc3Qga2V5cyBwYXJ0LlxcbiAgICAgICAgICAgIGtleXNba2V5c19sYXN0XSA9IGtleXNba2V5c19sYXN0XS5yZXBsYWNlKC9cXFxcXSQvLCAnJyk7XFxuXFxuICAgICAgICAgICAgLy8gU3BsaXQgZmlyc3Qga2V5cyBwYXJ0IGludG8gdHdvIHBhcnRzIG9uIHRoZSBbIGFuZCBhZGQgdGhlbSBiYWNrIG9udG9cXG4gICAgICAgICAgICAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBrZXlzIGFycmF5LlxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLnNoaWZ0KCkuc3BsaXQoJ1snKS5jb25jYXQoa2V5cyk7XFxuXFxuICAgICAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBCYXNpYyAnZm9vJyBzdHlsZSBrZXkuXFxuICAgICAgICAgICAga2V5c19sYXN0ID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lPXZhbHVlIHBhaXIsIG9yIGp1c3QgYSBuYW1lP1xcbiAgICAgICAgaWYgKHBhcmFtLmxlbmd0aCA9PT0gMikge1xcbiAgICAgICAgICAgIHZhbCA9IGRlY29kZShwYXJhbVsxXSk7XFxuXFxuICAgICAgICAgICAgLy8gQ29lcmNlIHZhbHVlcy5cXG4gICAgICAgICAgICBpZiAoY29lcmNlKSB7XFxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbCAmJiAhaXNOYU4odmFsKSA/ICt2YWwgICAgICAgICAgICAgIC8vIG51bWJlclxcbiAgICAgICAgICAgICAgICAgIDogdmFsID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCAgICAgICAgIC8vIHVuZGVmaW5lZFxcbiAgICAgICAgICAgICAgICAgIDogY29lcmNlX3R5cGVzW3ZhbF0gIT09IHVuZGVmaW5lZCA/IGNvZXJjZV90eXBlc1t2YWxdIC8vIHRydWUsIGZhbHNlLCBudWxsXFxuICAgICAgICAgICAgICAgICAgOiB2YWw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChrZXlzX2xhc3QpIHtcXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxleCBrZXksIGJ1aWxkIGRlZXAgb2JqZWN0IHN0cnVjdHVyZSBiYXNlZCBvbiBhIGZldyBydWxlczpcXG4gICAgICAgICAgICAgICAgLy8gKiBUaGUgJ2N1cicgcG9pbnRlciBzdGFydHMgYXQgdGhlIG9iamVjdCB0b3AtbGV2ZWwuXFxuICAgICAgICAgICAgICAgIC8vICogW10gPSBhcnJheSBwdXNoIChuIGlzIHNldCB0byBhcnJheSBsZW5ndGgpLCBbbl0gPSBhcnJheSBpZiBuIGlzIFxcbiAgICAgICAgICAgICAgICAvLyAgIG51bWVyaWMsIG90aGVyd2lzZSBvYmplY3QuXFxuICAgICAgICAgICAgICAgIC8vICogSWYgYXQgdGhlIGxhc3Qga2V5cyBwYXJ0LCBzZXQgdGhlIHZhbHVlLlxcbiAgICAgICAgICAgICAgICAvLyAqIEZvciBlYWNoIGtleXMgcGFydCwgaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgdW5kZWZpbmVkIGNyZWF0ZSBhblxcbiAgICAgICAgICAgICAgICAvLyAgIG9iamVjdCBvciBhcnJheSBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgbmV4dCBrZXlzIHBhcnQuXFxuICAgICAgICAgICAgICAgIC8vICogTW92ZSB0aGUgJ2N1cicgcG9pbnRlciB0byB0aGUgbmV4dCBsZXZlbC5cXG4gICAgICAgICAgICAgICAgLy8gKiBSaW5zZSAmIHJlcGVhdC5cXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPD0ga2V5c19sYXN0OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV0gPT09ICcnID8gY3VyLmxlbmd0aCA6IGtleXNbaV07XFxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXJba2V5XSA9IGkgPCBrZXlzX2xhc3RcXG4gICAgICAgICAgICAgICAgICAgICAgPyBjdXJba2V5XSB8fCAoa2V5c1tpICsgMV0gJiYgaXNOYU4oa2V5c1tpICsgMV0pID8ge30gOiBbXSlcXG4gICAgICAgICAgICAgICAgICAgICAgOiB2YWw7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUga2V5LCBldmVuIHNpbXBsZXIgcnVsZXMsIHNpbmNlIG9ubHkgc2NhbGFycyBhbmQgc2hhbGxvd1xcbiAgICAgICAgICAgICAgICAvLyBhcnJheXMgYXJlIGFsbG93ZWQuXFxuXFxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkob2JqW2tleV0pKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXMgYWxyZWFkeSBhbiBhcnJheSwgc28gcHVzaCBvbiB0aGUgbmV4dCB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcXG5cXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXNuJ3QgYW4gYXJyYXksIGJ1dCBzaW5jZSBhIHNlY29uZCB2YWx1ZSBoYXMgYmVlbiBzcGVjaWZpZWQsXFxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHZhbCBpbnRvIGFuIGFycmF5LlxcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV0sIHZhbF07XFxuXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWwgaXMgYSBzY2FsYXIuXFxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XFxuICAgICAgICAgICAgLy8gTm8gdmFsdWUgd2FzIGRlZmluZWQsIHNvIHNldCBzb21ldGhpbmcgbWVhbmluZ2Z1bC5cXG4gICAgICAgICAgICBvYmpba2V5XSA9IGNvZXJjZVxcbiAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgIDogJyc7XFxuICAgICAgICB9XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gb2JqO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9kZXBhcmFtLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uKCkge1xcbiAgICBULlV0aWxzLmVtYmVkU3RhdGUgPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRleHQsIG5vZGUpIHtcXG4gICAgICAgIGVtYmVkUHJvcGVydHkobW9kZWwsICdjb250ZXh0JywgY29udGV4dCk7XFxuICAgICAgICBlbWJlZFByb3BlcnR5KG1vZGVsLCAnbm9kZScsIG5vZGUpO1xcbiAgICB9O1xcblxcbiAgICBULlV0aWxzLmNvbnRleHRGb3IgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgVC5VdGlscy5leHRyYWN0Q29udGV4dChrby5jb250ZXh0Rm9yKCQoZWxlbWVudClbMF0pKTtcXG4gICAgfTtcXG5cXG4gICAgVC5VdGlscy5leHRyYWN0Q29udGV4dCA9IGZ1bmN0aW9uIChrb0JpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICByZXR1cm4ga29CaW5kaW5nQ29udGV4dCAmJiBlbWJlZGRlZFByb3BlcnR5KGtvQmluZGluZ0NvbnRleHQuJHJvb3QsICdjb250ZXh0Jyk7XFxuICAgIH07XFxuXFxuICAgIFQuVXRpbHMuZXh0cmFjdE5vZGUgPSBmdW5jdGlvbiAoa29CaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuIGtvQmluZGluZ0NvbnRleHQgJiYgZW1iZWRkZWRQcm9wZXJ0eShrb0JpbmRpbmdDb250ZXh0LiRyb290LCAnbm9kZScpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBlbWJlZFByb3BlcnR5KHRhcmdldCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKCF0YXJnZXQpXFxuICAgICAgICAgICAgdGhyb3cgXFxcIkNhbid0IGVtYmVkIHByb3BlcnR5IGluIGZhbHN5IHZhbHVlXFxcIjtcXG4gICAgICAgIHRhcmdldFsnX18nICsga2V5XSA9IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGVtYmVkZGVkUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcXG4gICAgICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0WydfXycgKyBrZXldO1xcbiAgICB9XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2VtYmVkZGVkQ29udGV4dC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQuVXRpbHMuZWxlbWVudERlc3Ryb3llZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgICAgICBpZiAoZWxlbWVudC5jb25zdHJ1Y3RvciA9PT0galF1ZXJ5KVxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50WzBdO1xcblxcbiAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuXFxuICAgICAgICAvLyBSZXNvbHZlIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIHVzaW5nIGpRdWVyeS4gVGhpcyBpcyBhIGZhbGxiYWNrIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBET01Ob2RlUmVtb3ZlZCBhbmQgYWxzbyBleGVjdXRlcyBzeW5jaHJvbm91c2x5LlxcbiAgICAgICAgJChlbGVtZW50KS5vbignZGVzdHJveWVkJywgcmVzb2x2ZSk7XFxuXFxuICAgICAgICAvLyBSZXNvbHZlIHVzaW5nIHRoZSBET01Ob2RlUmVtb3ZlZCBldmVudC4gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHRoaXMuXFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwiRE9NTm9kZVJlbW92ZWRcXFwiLCBtYXRjaEVsZW1lbnQpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hFbGVtZW50KGV2ZW50KSB7XFxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudClcXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcXG4gICAgICAgICAgICAkKGVsZW1lbnQpLm9mZignZGVzdHJveWVkJywgcmVzb2x2ZSk7XFxuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdET01Ob2RlUmVtb3ZlZCcsIG1hdGNoRWxlbWVudCk7XFxuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgfTtcXG5cXG4gICAgLy8gdGhpcyB1c2VkIHRvIHVzZSBET00gZnVuY3Rpb25zIHRvIHJhaXNlIGV2ZW50cywgYnV0IElFOCBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tIGV2ZW50c1xcbiAgICAvLyB3ZSdsbCB1c2UgalF1ZXJ5LCBidXQgZXhwb3NlIHRoZSBvcmlnaW5hbEV2ZW50IGZvciBET00gZXZlbnRzIGFuZCB0aGUgalF1ZXJ5IGV2ZW50XFxuICAgIC8vIGZvciBjdXN0b20gZXZlbnRzIChvcmlnaW5hbEV2ZW50IGlzIG51bGwgZm9yIGN1c3RvbSBldmVudHMpLlxcbiAgICBULlV0aWxzLnJhaXNlRG9jdW1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudERhdGEpIHtcXG4gICAgICAgIHZhciBlID0gJC5FdmVudChuYW1lKTtcXG4gICAgICAgIGUuZXZlbnREYXRhID0gZXZlbnREYXRhO1xcbiAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcihlKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGhhbmRsZXJzID0ge307XFxuXFxuICAgIC8vIGlmIGEgaGFuZGxlciBpcyB1c2VkIGZvciBtb3JlIHRoYW4gb25lIGV2ZW50LCBhIGxlYWsgd2lsbCBvY2N1clxcbiAgICBULlV0aWxzLmhhbmRsZURvY3VtZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xcbiAgICAgICAgJChkb2N1bWVudCkub24obmFtZSwgaW50ZXJuYWxIYW5kbGVyKTtcXG4gICAgICAgIGhhbmRsZXJzW2hhbmRsZXJdID0gaW50ZXJuYWxIYW5kbGVyO1xcbiAgICAgICAgXFxuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEhhbmRsZXIoZSkge1xcbiAgICAgICAgICAgIGhhbmRsZXIoZS5vcmlnaW5hbEV2ZW50IHx8IGUpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBULlV0aWxzLmRldGFjaERvY3VtZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKG5hbWUsIGhhbmRsZXJzW2hhbmRsZXJdKTtcXG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1toYW5kbGVyXTtcXG4gICAgfTtcXG59KSgpO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvZXZlbnRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy50cnlDYXRjaCA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGhhbmRsZUV4Y2VwdGlvbnMsIG1lc3NhZ2UpIHtcXG4gICAgaWYgKGhhbmRsZUV4Y2VwdGlvbnMpXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XFxuICAgICAgICB9IGNhdGNoIChleCkge1xcbiAgICAgICAgICAgIFQubG9nZ2VyLmVycm9yKG1lc3NhZ2UsIGV4KTtcXG4gICAgICAgIH1cXG4gICAgZWxzZVxcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvZXhjZXB0aW9ucy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIFQuVXRpbHMuaWRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG5leHQ6IChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpZCA9IDA7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQrKztcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9KSgpXFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB2YXIgZ2VuZXJhdG9yID0gVC5VdGlscy5pZEdlbmVyYXRvcigpO1xcbiAgICBULlV0aWxzLmdldFVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvci5uZXh0KCk7XFxuICAgIH07XFxufSkoKTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2lkR2VuZXJhdG9yLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pIHtcXG4gICAgICAgICd1c2Ugc3RyaWN0JztcXG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbiwgaywgdCA9IE9iamVjdCh0aGlzKSxcXG4gICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcXG5cXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBuID0gMDtcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcXG4gICAgICAgICAgICBpZiAobiAhPSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cXG4gICAgICAgICAgICAgICAgbiA9IDA7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9IDAgJiYgbiAhPSBJbmZpbml0eSAmJiBuICE9IC1JbmZpbml0eSkge1xcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChuID49IGxlbikge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCkgOyBrIDwgbGVuOyBrKyspIHtcXG4gICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9O1xcbn1cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2luZGV4T2YuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCQpIHtcXG4gICAgJC5jb21wbGV0ZSA9IGZ1bmN0aW9uIChkZWZlcnJlZHMpIHtcXG4gICAgICAgIHZhciB3cmFwcGVycyA9IFtdO1xcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xcbiAgICAgICAgdmFyIHJlc29sdmUgPSBmYWxzZTtcXG5cXG4gICAgICAgIGlmICgkLmlzQXJyYXkoZGVmZXJyZWRzKSlcXG4gICAgICAgICAgICAkLmVhY2goZGVmZXJyZWRzLCB3cmFwRGVmZXJyZWQpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHdyYXBEZWZlcnJlZCgwLCBkZWZlcnJlZHMpO1xcblxcbiAgICAgICAgJC53aGVuLmFwcGx5KCQsIHdyYXBwZXJzKS5kb25lKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJlc29sdmUgP1xcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCkgOlxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcblxcbiAgICAgICAgZnVuY3Rpb24gd3JhcERlZmVycmVkKGluZGV4LCBvcmlnaW5hbCkge1xcbiAgICAgICAgICAgIHdyYXBwZXJzLnB1c2goJC5EZWZlcnJlZChmdW5jdGlvbiAodGhpc0RlZmVycmVkKSB7XFxuICAgICAgICAgICAgICAgICQud2hlbihvcmlnaW5hbClcXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEZWZlcnJlZC5yZXNvbHZlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgIH07XFxufSkoalF1ZXJ5KTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2pxdWVyeS5jb21wbGV0ZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoJCkge1xcbiAgICB2YXIgb2xkQ2xlYW4gPSBqUXVlcnkuY2xlYW5EYXRhO1xcblxcbiAgICAvLyBrbm9ja291dCBhbHNvIGNhbGxzIGNsZWFuRGF0YSBmcm9tIGl0J3MgY2xlYW5Ob2RlIG1ldGhvZCAtIGF2b2lkIGFueSBsb29wc1xcbiAgICAvL3ZhciBjbGVhbmluZyA9IHt9O1xcblxcbiAgICAkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IChlbGVtZW50ID0gZWxlbWVudHNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xcbiAgICAgICAgICAgIC8vaWYgKCFjbGVhbmluZ1tlbGVtZW50XSkge1xcbiAgICAgICAgICAgICAgICAvL2NsZWFuaW5nW2VsZW1lbnRdID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiZGVzdHJveWVkXFxcIik7XFxuICAgICAgICAgICAgICAgIC8vZGVsZXRlIGNsZWFuaW5nW2VsZW1lbnRdO1xcbiAgICAgICAgICAgIC8vfVxcbiAgICAgICAgfVxcbiAgICAgICAgb2xkQ2xlYW4oZWxlbWVudHMpO1xcbiAgICB9O1xcbn0pKGpRdWVyeSk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9qcXVlcnkuZGVzdHJveWVkLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy5jbGVhbkVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAvLyBwcmV2ZW50IGtub2Nrb3V0IGZyb20gY2FsbGluZyBjbGVhbkRhdGEgXFxuICAgIC8vIC0gY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiB1bHRpbWF0ZWx5IHJlc3VsdCBmcm9tIGNsZWFuRGF0YSBiZWluZyBjYWxsZWQgYnkgalF1ZXJ5LCBzbyBhIGxvb3Agd2lsbCBvY2N1clxcbiAgICB2YXIgZnVuYyA9ICQuY2xlYW5EYXRhO1xcbiAgICAkLmNsZWFuRGF0YSA9IHVuZGVmaW5lZDtcXG4gICAga28uY2xlYW5Ob2RlKGVsZW1lbnQpO1xcbiAgICAkLmNsZWFuRGF0YSA9IGZ1bmM7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL2tub2Nrb3V0LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5VdGlscy5hcmd1bWVudHMgPSBmdW5jdGlvbiAoYXJncykge1xcbiAgICB2YXIgYnlDb25zdHJ1Y3RvciA9IHt9O1xcbiAgICAkLmVhY2goYXJncywgZnVuY3Rpb24gKGluZGV4LCBhcmcpIHtcXG4gICAgICAgIGJ5Q29uc3RydWN0b3JbYXJnLmNvbnN0cnVjdG9yXSA9IGFyZztcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgICBieUNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gYnlDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvcik7XFxuICAgICAgICB9LFxcbiAgICAgICAgb2JqZWN0OiBieUNvbnN0cnVjdG9yW09iamVjdF0sXFxuICAgICAgICBzdHJpbmc6IGJ5Q29uc3RydWN0b3JbU3RyaW5nXSxcXG4gICAgICAgIGZ1bmM6IGJ5Q29uc3RydWN0b3JbRnVuY3Rpb25dLFxcbiAgICAgICAgYXJyYXk6IGJ5Q29uc3RydWN0b3JbQXJyYXldLFxcbiAgICAgICAgbnVtYmVyOiBieUNvbnN0cnVjdG9yW051bWJlcl1cXG4gICAgfTtcXG59O1xcblxcblQuVXRpbHMucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xcbiAgICB2YXIgaW5kZXggPSAkLmluQXJyYXkoaXRlbSwgYXJyYXkpO1xcbiAgICBpZiAoaW5kZXggPiAtMSlcXG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XFxufTtcXG5cXG5ULlV0aWxzLmluaGVyaXRPcHRpb25zID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspXFxuICAgICAgICB0b1tvcHRpb25zW2ldXSA9IGZyb21bb3B0aW9uc1tpXV07XFxuICAgIHJldHVybiB0bztcXG59O1xcblxcblQuVXRpbHMuY2xvbmVEYXRhID0gZnVuY3Rpb24gKGZyb20sIGV4Y2VwdCkge1xcbiAgICBpZiAoIWZyb20pIHJldHVybjtcXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmcm9tKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSBmcm9tW3Byb3BlcnR5XTtcXG4gICAgICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxcbiAgICAgICAgICAgICghZXhjZXB0IHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJndW1lbnRzLCBwcm9wZXJ0eSkgPT09IC0xKSAmJlxcbiAgICAgICAgICAgICghdmFsdWUgfHwgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbiB8fCBrby5pc09ic2VydmFibGUodmFsdWUpKSkpXFxuXFxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5ULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzID0gZnVuY3Rpb24gKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpIHtcXG4gICAgdmFyIGRhdGEgPSBhbGxCaW5kaW5nc0FjY2Vzc29yKCk7XFxuICAgIGRhdGEudmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XFxuICAgIGlmICgha28uaXNPYnNlcnZhYmxlKGRhdGEudmFsdWUpICYmICQuaXNGdW5jdGlvbihkYXRhLnZhbHVlKSlcXG4gICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLnZhbHVlKCk7XFxuICAgIHJldHVybiBkYXRhO1xcbn07XFxuXFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9vYmplY3RzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHV0aWxzID0gVC5VdGlscztcXG5cXG4gICAgdXRpbHMuZ2V0UGFuZU9wdGlvbnMgPSBmdW5jdGlvbih2YWx1ZSwgb3RoZXJPcHRpb25zKSB7XFxuICAgICAgICB2YXIgb3B0aW9ucyA9IHZhbHVlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyB7IHBhdGg6IHZhbHVlIH0gOiB2YWx1ZTtcXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb3RoZXJPcHRpb25zLCBvcHRpb25zKTtcXG4gICAgfTtcXG5cXG4gICAgdXRpbHMuYmluZFBhbmUgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpIHtcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHV0aWxzLmNvbnRleHRGb3IoZWxlbWVudCkgfHwgVC5jb250ZXh0KCk7XFxuICAgICAgICB2YXIgcGFuZSA9IG5ldyBULlR5cGVzLlBhbmUoJC5leHRlbmQoeyBlbGVtZW50OiAkKGVsZW1lbnQpWzBdIH0sIHBhbmVPcHRpb25zKSk7XFxuICAgICAgICBub2RlLnNldFBhbmUocGFuZSk7XFxuXFxuICAgICAgICBjb250ZXh0LnJlbmRlck9wZXJhdGlvbi5hZGQocGFuZSk7XFxuXFxuICAgICAgICB2YXIgcGlwZWxpbmUgPSBuZXcgVC5UeXBlcy5QaXBlbGluZShULkV2ZW50cywgY29udGV4dCk7XFxuICAgICAgICBwaXBlbGluZS5leGVjdXRlKGNvbnRleHQub3B0aW9ucy5ldmVudHMsIHBhbmUpO1xcblxcbiAgICAgICAgcmV0dXJuIHBhbmU7XFxuICAgIH07XFxuXFxuICAgIHV0aWxzLmluc2VydFBhbmVBZnRlciA9IGZ1bmN0aW9uIChub2RlLCB0YXJnZXQsIHBhbmVPcHRpb25zLCBjb250ZXh0KSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoJzxkaXYvPicpLmluc2VydEFmdGVyKHRhcmdldCk7XFxuICAgICAgICByZXR1cm4gdXRpbHMuYmluZFBhbmUobm9kZSwgZWxlbWVudCwgcGFuZU9wdGlvbnMsIGNvbnRleHQpO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9wYW5lcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbigpIHtcXG4gICAgVC5QYXRoID0gUGF0aDtcXG5cXG4gICAgZnVuY3Rpb24gUGF0aChwYXRoKSB7XFxuICAgICAgICBwYXRoID0gcGF0aCA/IG5vcm1hbGlzZShwYXRoLnRvU3RyaW5nKCkpIDogJyc7XFxuICAgICAgICB2YXIgZmlsZW5hbWVJbmRleCA9IHBhdGgubGFzdEluZGV4T2YoXFxcIi9cXFwiKSArIDE7XFxuICAgICAgICB2YXIgZXh0ZW5zaW9uSW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFxcXCIuXFxcIik7XFxuXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHdpdGhvdXRGaWxlbmFtZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBQYXRoKHBhdGguc3Vic3RyaW5nKDAsIGZpbGVuYW1lSW5kZXgpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgocGF0aC5zdWJzdHJpbmcoZmlsZW5hbWVJbmRleCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbkluZGV4ID09PSAtMSA/ICcnIDogcGF0aC5zdWJzdHJpbmcoZXh0ZW5zaW9uSW5kZXggKyAxKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHdpdGhvdXRFeHRlbnNpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChleHRlbnNpb25JbmRleCA9PT0gLTEgPyBwYXRoIDogcGF0aC5zdWJzdHJpbmcoMCwgZXh0ZW5zaW9uSW5kZXgpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvbWJpbmU6IGZ1bmN0aW9uIChhZGRpdGlvbmFsUGF0aCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aCgocGF0aCA/IHBhdGggKyAnLycgOiAnJykgKyBhZGRpdGlvbmFsUGF0aC50b1N0cmluZygpKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fFxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5pbmRleE9mKCc6Ly8nKSA+IC0xO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgbWFrZUFic29sdXRlOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgoJy8nICsgcGF0aCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBtYWtlUmVsYXRpdmU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUGF0aChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGFzTWFya3VwSWRlbnRpZmllcjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhvdXRFeHRlbnNpb24oKS50b1N0cmluZygpLnJlcGxhY2UoL1xcXFwvL2csICctJykucmVwbGFjZSgvXFxcXC4vZywgJycpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgc2V0RXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhdGgodGhpcy53aXRob3V0RXh0ZW5zaW9uKCkgKyAnLicgKyBleHRlbnNpb24pO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpc2UoaW5wdXQpIHtcXG4gICAgICAgICAgICBpbnB1dCA9IHJlbW92ZURvdWJsZVNsYXNoZXMoaW5wdXQpO1xcbiAgICAgICAgICAgIGlucHV0ID0gcmVtb3ZlUGFyZW50UGF0aHMoaW5wdXQpO1xcbiAgICAgICAgICAgIGlucHV0ID0gcmVtb3ZlQ3VycmVudFBhdGhzKGlucHV0KTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiByZW1vdmVEb3VibGVTbGFzaGVzKGlucHV0KSB7XFxuICAgICAgICAgICAgdmFyIHByZWZpeEVuZCA9IGlucHV0LmluZGV4T2YoJzovLycpID4gLTEgPyBpbnB1dC5pbmRleE9mKCc6Ly8nKSArIDMgOiAwO1xcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4RW5kKTtcXG4gICAgICAgICAgICB2YXIgaW5wdXRQYXRoID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeEVuZCk7XFxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGlucHV0UGF0aC5yZXBsYWNlKC9cXFxcL3syLH0vZywgJy8nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBhcmVudFBhdGhzKGlucHV0KSB7XFxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL1teXFxcXC9cXFxcLl0rXFxcXC9cXFxcLlxcXFwuXFxcXC8vO1xcblxcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dC5tYXRjaChyZWdleCkpXFxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShyZWdleCwgJycpO1xcblxcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUN1cnJlbnRQYXRocyhpbnB1dCkge1xcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9cXFxcLlxcXFwvL2c7XFxuICAgICAgICAgICAgLy8gSWdub3JlIGxlYWRpbmcgcGFyZW50IHBhdGhzIC0gdGhlIHJlc3Qgd2lsbCBoYXZlIGJlZW4gc3RyaXBwZWRcXG4gICAgICAgICAgICAvLyBJIGNhbid0IGZpZ3VyZSBvdXQgYSByZWdleCB0aGF0IHdvbid0IHN0cmlwIHRoZSAuLyBvdXQgb2YgLi4vXFxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBpbnB1dC5sYXN0SW5kZXhPZignLi4vJyk7XFxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gLTEgPyAwIDogc3RhcnRJbmRleCArIDM7XFxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZygwLCBzdGFydEluZGV4KSArIGlucHV0LnN1YnN0cmluZyhzdGFydEluZGV4KS5yZXBsYWNlKHJlZ2V4LCAnJyk7XFxuICAgICAgICB9XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVXRpbGl0aWVzL1BhdGguanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICAvLyBUaGlzIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBtb2R1bGVzIGZyb20gdGhlIFlVSSBMaWJyYXJ5IC0gXFxuICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9hcGkvZmlsZXMvcXVlcnlzdHJpbmdfanNfcXVlcnlzdHJpbmctcGFyc2UuanMuaHRtbFxcbiAgICAvLyBFaXRoZXIgaXQgc2hvdWxkIGJlIHJld3JpdHRlbiBvciBhdHRyaWJ1dGlvbiBhbmQgbGljZW5zaW5nIGJlIGF2YWlsYWJsZSBoZXJlIGFuZCBvbiB0aGUgd2Vic2l0ZSBsaWtlIGluIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xcblxcbiAgICBULlV0aWxzLlF1ZXJ5c3RyaW5nID0gVC5VdGlscy5RdWVyeXN0cmluZyB8fCB7fTtcXG5cXG4gICAgVC5VdGlscy5RdWVyeXN0cmluZy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHNlcGVyYXRvciwgZXFTeW1ib2wpIHtcXG4gICAgICAgIHN0cmlwTGVhZEluKCk7XFxuICAgICAgICBcXG4gICAgICAgIHJldHVybiBULlV0aWxzLnJlZHVjZShcXG4gICAgICAgICAgICBULlV0aWxzLm1hcChcXG4gICAgICAgICAgICAgICAgc291cmNlLnNwbGl0KHNlcGVyYXRvciB8fCBcXFwiJlxcXCIpLFxcbiAgICAgICAgICAgICAgICBwaWVjZVBhcnNlcihlcVN5bWJvbCB8fCBcXFwiPVxcXCIpXFxuICAgICAgICAgICAgKSxcXG4gICAgICAgICAgICB7fSxcXG4gICAgICAgICAgICBtZXJnZVBhcmFtc1xcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIHN0cmlwTGVhZEluKCkge1xcbiAgICAgICAgICAgIGlmKHNvdXJjZS5sZW5ndGggPiAwICYmIHNvdXJjZS5jaGFyQXQoMCkgPT09ICc/JylcXG4gICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygxKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHMpIHtcXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocy5yZXBsYWNlKC9cXFxcKy9nLCAnICcpKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcGllY2VQYXJzZXIoZXEpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZVBpZWNlKGtleSwgdmFsKSB7XFxuXFxuICAgICAgICAgICAgdmFyIHNsaWNlZCwgbnVtVmFsLCBoZWFkLCB0YWlsLCByZXQ7XFxuXFxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgLy8ga2V5PXZhbCwgY2FsbGVkIGZyb20gdGhlIG1hcC9yZWR1Y2VcXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnNwbGl0KGVxKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGllY2UoXFxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZShrZXkuc2hpZnQoKSksXFxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZShrZXkuam9pbihlcSkpLFxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKTtcXG4gICAgICAgICAgICBpZiAodmFsLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJyk7XFxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbnVtZXJhbHMgdG8gbnVtYmVyc1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIG51bVZhbCA9ICt2YWw7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudW1WYWwudG9TdHJpbmcoMTApKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVtVmFsO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHNsaWNlZCA9IC8oLiopXFxcXFsoW15cXFxcXV0qKVxcXFxdJC8uZXhlYyhrZXkpO1xcbiAgICAgICAgICAgIGlmICghc2xpY2VkKSB7XFxuICAgICAgICAgICAgICAgIHJldCA9IHt9O1xcbiAgICAgICAgICAgICAgICBpZiAoa2V5KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSB2YWw7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIFtcXFwiZm9vW11bYmFyXVtdW2Jhel1cXFwiLCBcXFwiZm9vW11bYmFyXVtdXFxcIiwgXFxcImJhelxcXCJdXFxuICAgICAgICAgICAgdGFpbCA9IHNsaWNlZFsyXTtcXG4gICAgICAgICAgICBoZWFkID0gc2xpY2VkWzFdO1xcblxcbiAgICAgICAgICAgIC8vIGFycmF5OiBrZXlbXT12YWxcXG4gICAgICAgICAgICBpZiAoIXRhaWwpXFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBpZWNlKGhlYWQsIFt2YWxdLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAvLyBvYmplY3Q6IGtleVtzdWJrZXldPXZhbFxcbiAgICAgICAgICAgIHJldCA9IHt9O1xcbiAgICAgICAgICAgIHJldFt0YWlsXSA9IHZhbDtcXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VQaWVjZShoZWFkLCByZXQsIHRydWUpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAvLyB0aGUgcmVkdWNlciBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIHF1ZXJ5IHBpZWNlIHRvZ2V0aGVyIGludG8gb25lIHNldCBvZiBwYXJhbXNcXG4gICAgZnVuY3Rpb24gbWVyZ2VQYXJhbXMocGFyYW1zLCBhZGRpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIChcXG4gICAgICAgICAgICAvLyBpZiBpdCdzIHVuY29udGVzdGVkLCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBhZGRpdGlvbi5cXG4gICAgICAgICAgICAoIXBhcmFtcykgPyBhZGRpdGlvblxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiBjb25jYXQgaXQuXFxuICAgICAgICAgICAgOiAoJC5pc0FycmF5KHBhcmFtcykpID8gcGFyYW1zLmNvbmNhdChhZGRpdGlvbilcXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGFuIGFycmF5LCBhbmQgZWl0aGVyIGFyZSBub3Qgb2JqZWN0cywgYXJyYXlpZnkgaXQuXFxuICAgICAgICAgICAgOiAoISQuaXNQbGFpbk9iamVjdChwYXJhbXMpIHx8ICEkLmlzUGxhaW5PYmplY3QoYWRkaXRpb24pKSA/IFtwYXJhbXNdLmNvbmNhdChhZGRpdGlvbilcXG4gICAgICAgICAgICAvLyBlbHNlIG1lcmdlIHRoZW0gYXMgb2JqZWN0cywgd2hpY2ggaXMgYSBsaXR0bGUgbW9yZSBjb21wbGV4XFxuICAgICAgICAgICAgOiBtZXJnZU9iamVjdHMocGFyYW1zLCBhZGRpdGlvbilcXG4gICAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgLy8gTWVyZ2UgdHdvICpvYmplY3RzKiB0b2dldGhlci4gSWYgdGhpcyBpcyBjYWxsZWQsIHdlJ3ZlIGFscmVhZHkgcnVsZWRcXG4gICAgLy8gb3V0IHRoZSBzaW1wbGUgY2FzZXMsIGFuZCBuZWVkIHRvIGRvIHRoZSBmb3ItaW4gYnVzaW5lc3MuXFxuICAgIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhwYXJhbXMsIGFkZGl0aW9uKSB7XFxuICAgICAgICBmb3IgKHZhciBpIGluIGFkZGl0aW9uKVxcbiAgICAgICAgICAgIGlmIChpICYmIGFkZGl0aW9uLmhhc093blByb3BlcnR5KGkpKVxcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBtZXJnZVBhcmFtcyhwYXJhbXNbaV0sIGFkZGl0aW9uW2ldKTtcXG5cXG4gICAgICAgIHJldHVybiBwYXJhbXM7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9VdGlsaXRpZXMvcXVlcnlzdHJpbmcucGFyc2UuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICAvLyBUaGlzIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBtb2R1bGVzIGZyb20gdGhlIFlVSSBMaWJyYXJ5IC0gXFxuICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9hcGkvZmlsZXMvcXVlcnlzdHJpbmdfanNfcXVlcnlzdHJpbmctc3RyaW5naWZ5LmpzLmh0bWxcXG4gICAgLy8gRWl0aGVyIGl0IHNob3VsZCBiZSByZXdyaXR0ZW4gb3IgYXR0cmlidXRpb24gYW5kIGxpY2Vuc2luZyBiZSBhdmFpbGFibGUgaGVyZSBhbmQgb24gdGhlIHdlYnNpdGUgbGlrZSBpbiBodHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cXG5cXG4gICAgVC5VdGlscy5RdWVyeXN0cmluZyA9IFQuVXRpbHMuUXVlcnlzdHJpbmcgfHwge307XFxuXFxuICAgIHZhciBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XFxuXFxuICAgIFQuVXRpbHMuUXVlcnlzdHJpbmcuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShzb3VyY2UsIG9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoc291cmNlLCBvcHRpb25zLCBuYW1lLCBzdGFjaykge1xcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgICAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcbiAgICAgICAgdmFyIGJlZ2luLCBlbmQsIGksIGwsIG4sIHM7XFxuICAgICAgICB2YXIgc2VwID0gb3B0aW9ucy5zZXBlcmF0b3IgfHwgXFxcIiZcXFwiO1xcbiAgICAgICAgdmFyIGVxID0gb3B0aW9ucy5lcVN5bWJvbCB8fCBcXFwiPVxcXCI7XFxuICAgICAgICB2YXIgYXJyYXlLZXkgPSBvcHRpb25zLmFycmF5S2V5ICE9PSBmYWxzZTtcXG5cXG4gICAgICAgIGlmIChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgc291cmNlLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICByZXR1cm4gbmFtZSA/IGVzY2FwZShuYW1lKSArIGVxIDogJyc7XFxuXFxuICAgICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yID09PSBCb29sZWFuIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzb3VyY2UpID09PSAnW29iamVjdCBCb29sZWFuXScpXFxuICAgICAgICAgICAgc291cmNlID0gK3NvdXJjZTtcXG5cXG4gICAgICAgIGlmICghaXNOYU4oc291cmNlKSB8fCBzb3VyY2UuY29uc3RydWN0b3IgPT09IFN0cmluZylcXG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlKG5hbWUpICsgZXEgKyBlc2NhcGUoc291cmNlKTtcXG5cXG4gICAgICAgIGlmICgkLmlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgICAgICAgIHMgPSBbXTtcXG4gICAgICAgICAgICBuYW1lID0gYXJyYXlLZXkgPyBuYW1lICsgJ1tdJyA6IG5hbWU7XFxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcy5wdXNoKHN0cmluZ2lmeShzb3VyY2VbaV0sIG9wdGlvbnMsIG5hbWUsIHN0YWNrKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBzLmpvaW4oc2VwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgLy8gbm93IHdlIGtub3cgaXQncyBhbiBvYmplY3QuXFxuICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljYWwgcmVmZXJlbmNlcyBpbiBuZXN0ZWQgb2JqZWN0c1xcbiAgICAgICAgZm9yIChpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXFxuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSBzb3VyY2UpXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVC5VdGlscy5RdWVyeXN0cmluZy5zdHJpbmdpZnk6IGN5Y2xpY2FsIHJlZmVyZW5jZVxcXCIpO1xcblxcbiAgICAgICAgc3RhY2sucHVzaChzb3VyY2UpO1xcbiAgICAgICAgcyA9IFtdO1xcbiAgICAgICAgYmVnaW4gPSBuYW1lID8gbmFtZSArICdbJyA6ICcnO1xcbiAgICAgICAgZW5kID0gbmFtZSA/ICddJyA6ICcnO1xcbiAgICAgICAgZm9yIChpIGluIHNvdXJjZSkge1xcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgbiA9IGJlZ2luICsgaSArIGVuZDtcXG4gICAgICAgICAgICAgICAgcy5wdXNoKHN0cmluZ2lmeShzb3VyY2VbaV0sIG9wdGlvbnMsIG4sIHN0YWNrKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhY2sucG9wKCk7XFxuICAgICAgICBzID0gcy5qb2luKHNlcCk7XFxuICAgICAgICBpZiAoIXMgJiYgbmFtZSlcXG4gICAgICAgICAgICByZXR1cm4gbmFtZSArIFxcXCI9XFxcIjtcXG5cXG4gICAgICAgIHJldHVybiBzO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1V0aWxpdGllcy9xdWVyeXN0cmluZy5zdHJpbmdpZnkuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBULlR5cGVzLkZsb3cgPSBmdW5jdGlvbiAobmF2aWdhdGlvblNvdXJjZSwgZGVmaW5pdGlvbikge1xcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgICAgdGhpcy5ub2RlID0gbmF2aWdhdGlvbk5vZGUoKTtcXG4gICAgICAgIHRoaXMucHVic3ViID0gdGhpcy5ub2RlLnBhbmUucHVic3ViLm93bmVyO1xcbiAgICAgICAgdGhpcy5zYWdhcyA9IFtdO1xcblxcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24oc2VsZiwgZGVmaW5pdGlvbik7XFxuICAgICAgICB0aGlzLnNhZ2EgPSBuZXcgVHJpYmUuUHViU3ViLlNhZ2EodGhpcy5wdWJzdWIsIGRlZmluaXRpb24pO1xcblxcbiAgICAgICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgICAgICBzZWxmLnNhZ2Euc3RhcnQoZGF0YSk7XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgdGhpcy5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgc2VsZi5zYWdhLmVuZChkYXRhKTtcXG4gICAgICAgICAgICBULlV0aWxzLmVhY2goc2VsZi5zYWdhcywgZnVuY3Rpb24oc2FnYSkge1xcbiAgICAgICAgICAgICAgICBzYWdhLmVuZChkYXRhKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiBuYXZpZ2F0aW9uTm9kZSgpIHtcXG4gICAgICAgICAgICBpZiAobmF2aWdhdGlvblNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5Ob2RlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvblNvdXJjZS5maW5kTmF2aWdhdGlvbigpLm5vZGU7XFxuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25Tb3VyY2UuY29uc3RydWN0b3IgPT09IFQuVHlwZXMuUGFuZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRpb25Tb3VyY2Uubm9kZS5maW5kTmF2aWdhdGlvbigpLm5vZGU7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJuYXZpZ2F0aW9uU291cmNlIG11c3QgYmUgZWl0aGVyIFQuVHlwZXMuUGFuZSBvciBULlR5cGVzLk5vZGVcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5zdGFydENoaWxkID0gZnVuY3Rpb24oZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNyZWF0ZURlZmluaXRpb24odGhpcywgZGVmaW5pdGlvbik7XFxuICAgICAgICB0aGlzLnNhZ2Euc3RhcnRDaGlsZChkZWZpbml0aW9uLCBkYXRhKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHBhdGhPck9wdGlvbnMsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMubm9kZS5uYXZpZ2F0ZShwYXRoT3JPcHRpb25zLCBkYXRhKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIC8vIFRoaXMga2VlcHMgYSBzZXBhcmF0ZSBjb2xsZWN0aW9uIG9mIHNhZ2FzIGJvdW5kIHRvIHRoaXMgZmxvdydzIGxpZmV0aW1lXFxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgdG8gbWFrZSB0aGVtIGNoaWxkcmVuIG9mIHRoZSB1bmRlcmx5aW5nIHNhZ2EsIGJ1dFxcbiAgICAvLyB0aGVuIHRoZXkgd291bGQgZW5kIGFueSB0aW1lIGEgbWVzc2FnZSB3YXMgZXhlY3V0ZWQuXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUuc3RhcnRTYWdhID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGRhdGEpIHtcXG4gICAgICAgIHZhciBzYWdhID0gdGhpcy5wdWJzdWIuc3RhcnRTYWdhKGRlZmluaXRpb24sIGRhdGEpO1xcbiAgICAgICAgdGhpcy5zYWdhcy5wdXNoKHNhZ2EpO1xcbiAgICAgICAgcmV0dXJuIHNhZ2E7XFxuICAgIH07XFxuXFxuICAgIC8vIGZsb3cgaGVscGVyc1xcbiAgICBULlR5cGVzLkZsb3cucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBhdGhPck9wdGlvbnMsIGRhdGEpIHtcXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBub2RlLm5hdmlnYXRlKHBhdGhPck9wdGlvbnMsIGRhdGEpO1xcbiAgICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgVC5UeXBlcy5GbG93LnByb3RvdHlwZS5lbmRzQXQgPSBmdW5jdGlvbiAocGF0aE9yT3B0aW9ucywgZGF0YSkge1xcbiAgICAgICAgdmFyIGZsb3cgPSB0aGlzO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBmbG93Lm5vZGUubmF2aWdhdGUocGF0aE9yT3B0aW9ucywgZGF0YSk7XFxuICAgICAgICAgICAgZmxvdy5lbmQoKTtcXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIFQuVHlwZXMuRmxvdy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbG93LCBkYXRhKSB7XFxuICAgICAgICB2YXIgdGhpc0Zsb3cgPSB0aGlzO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHRoaXNGbG93LnN0YXJ0Q2hpbGQoZmxvdywgZGF0YSk7XFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcblxcbiAgICAvLyBUaGlzIGlzIHJldXNlZCBieSBOb2RlIGFuZCBQYW5lXFxuICAgIFQuVHlwZXMuRmxvdy5zdGFydEZsb3cgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZGF0YSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBULlR5cGVzLkZsb3codGhpcywgZGVmaW5pdGlvbikuc3RhcnQoZGF0YSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKGZsb3csIGRlZmluaXRpb24pIHtcXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcXG4gICAgICAgICAgICBkZWZpbml0aW9uID0gbmV3IGRlZmluaXRpb24oZmxvdyk7XFxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcXG4gICAgfVxcbn0pKCk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL0Zsb3cuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLkhpc3RvcnkgPSBmdW5jdGlvbiAoaGlzdG9yeSkge1xcbiAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCB3aW5kb3cudGl0bGUpO1xcblxcbiAgICB2YXIgcG9wQWN0aW9ucyA9IHtcXG4gICAgICAgIHJhaXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgVC5VdGlscy5yYWlzZURvY3VtZW50RXZlbnQoJ2Jyb3dzZXIuZ28nLCB7IGNvdW50OiAoZS5zdGF0ZSAtIGN1cnJlbnRTdGF0ZSkgfSk7XFxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZS5zdGF0ZTtcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGVTdGFjazogZnVuY3Rpb24oZSkge1xcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGUuc3RhdGU7XFxuICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHBvcEFjdGlvbnMucmFpc2VFdmVudDtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdmFyIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnJhaXNlRXZlbnQ7XFxuXFxuICAgIC8vIHRoaXMgbGVhdmVzIElFNyAmIDggaGlnaCBhbmQgZHJ5LiBXZSdsbCBwcm9iYWJseSByZXF1aXJlIGEgcG9seWZpbGwgYW5kIGNyZWF0ZSBhIGdlbmVyaWMgZXZlbnQgc3Vic2NyaXB0aW9uIG1ldGhvZFxcbiAgICBpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcilcXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGV4ZWN1dGVDdXJyZW50QWN0aW9uKTtcXG5cXG4gICAgZnVuY3Rpb24gZXhlY3V0ZUN1cnJlbnRBY3Rpb24oZSkge1xcbiAgICAgICAgaWYgKGUuc3RhdGUgIT09IG51bGwpIGN1cnJlbnRBY3Rpb24oZSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICh1cmxPcHRpb25zKSB7XFxuICAgICAgICB1cmxPcHRpb25zID0gdXJsT3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKCsrY3VycmVudFN0YXRlLCB1cmxPcHRpb25zLnRpdGxlLCB1cmxPcHRpb25zLnVybCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbihmcmFtZUNvdW50KSB7XFxuICAgICAgICBoaXN0b3J5LmdvKGZyYW1lQ291bnQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGZyYW1lQ291bnQpIHtcXG4gICAgICAgIGN1cnJlbnRBY3Rpb24gPSBwb3BBY3Rpb25zLnVwZGF0ZVN0YWNrO1xcbiAgICAgICAgaGlzdG9yeS5nbyhmcmFtZUNvdW50KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZXhlY3V0ZUN1cnJlbnRBY3Rpb24pO1xcbiAgICB9O1xcbn07XFxuXFxuaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSlcXG4gICAgVC5oaXN0b3J5ID0gbmV3IFQuVHlwZXMuSGlzdG9yeSh3aW5kb3cuaGlzdG9yeSk7XFxuZWxzZVxcbiAgICBULmhpc3RvcnkgPSBuZXcgVC5UeXBlcy5IaXN0b3J5KHtcXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgICAgICBnbzogZnVuY3Rpb24gKCkgeyB9XFxuICAgIH0pO1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9IaXN0b3J5LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5Mb2FkZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHJlc291cmNlcyA9IHt9O1xcblxcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgICAgICBpZiAocmVzb3VyY2VzW3VybF0gIT09IHVuZGVmaW5lZClcXG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzW3VybF07XFxuXFxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gVC5QYXRoKHVybCkuZXh0ZW5zaW9uKCkudG9TdHJpbmcoKTtcXG4gICAgICAgIHZhciBoYW5kbGVyID0gVC5Mb2FkSGFuZGxlcnNbZXh0ZW5zaW9uXTtcXG5cXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpO1xcbiAgICAgICAgICAgIHJlc291cmNlc1t1cmxdID0gcmVzdWx0O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICQud2hlbihyZXN1bHQpLmFsd2F5cyhmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzW3VybF0gPSBudWxsO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBULmxvZ2dlci53YXJuKFxcXCJSZXNvdXJjZSBvZiB0eXBlIFxcXCIgKyBleHRlbnNpb24gKyBcXFwiIGJ1dCBubyBoYW5kbGVyIHJlZ2lzdGVyZWQuXFxcIik7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfTtcXG59O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9Mb2FkZXIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLk5hdmlnYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xcbiAgICBub3JtYWxpc2VPcHRpb25zKCk7XFxuICAgIHNldEluaXRpYWxQYW5lU3RhdGUoKTtcXG5cXG4gICAgdmFyIHN0YWNrID0gW2luaXRpYWxTdGFja0l0ZW0oKV07XFxuICAgIHZhciBjdXJyZW50RnJhbWUgPSAwO1xcblxcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XFxuXFxuICAgIHRoaXMubmF2aWdhdGUgPSBmdW5jdGlvbiAocGFuZU9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChvcHRpb25zLmJyb3dzZXIpXFxuICAgICAgICAgICAgVC5oaXN0b3J5Lm5hdmlnYXRlKG9wdGlvbnMuYnJvd3NlciAmJiBvcHRpb25zLmJyb3dzZXIudXJsRGF0YUZyb20ocGFuZU9wdGlvbnMpKTtcXG5cXG4gICAgICAgIHRyaW1TdGFjaygpO1xcbiAgICAgICAgc3RhY2sucHVzaChwYW5lT3B0aW9ucyk7XFxuICAgICAgICBjdXJyZW50RnJhbWUrKztcXG5cXG4gICAgICAgIG5hdmlnYXRlVG8ocGFuZU9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmlzQXRTdGFydCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGcmFtZSA9PT0gMDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5nbyA9IGZ1bmN0aW9uKGZyYW1lQ291bnQpIHtcXG4gICAgICAgIGdvKGZyYW1lQ291bnQpO1xcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvd3NlcikgVC5oaXN0b3J5LnVwZGF0ZShmcmFtZUNvdW50KTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGlmKG9wdGlvbnMuYnJvd3NlcikgVC5VdGlscy5oYW5kbGVEb2N1bWVudEV2ZW50KCdicm93c2VyLmdvJywgb25Ccm93c2VyR28pO1xcbiAgICBmdW5jdGlvbiBvbkJyb3dzZXJHbyhlKSB7XFxuICAgICAgICBnbyhlLmV2ZW50RGF0YS5jb3VudCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ28oZnJhbWVDb3VudCkge1xcbiAgICAgICAgdmFyIG5ld0ZyYW1lID0gY3VycmVudEZyYW1lICsgZnJhbWVDb3VudDtcXG4gICAgICAgIGlmIChuZXdGcmFtZSA8IDApIG5ld0ZyYW1lID0gMDtcXG4gICAgICAgIGlmIChuZXdGcmFtZSA+PSBzdGFjay5sZW5ndGgpIG5ld0ZyYW1lID0gc3RhY2subGVuZ3RoIC0gMTtcXG5cXG4gICAgICAgIGlmIChuZXdGcmFtZSAhPSBjdXJyZW50RnJhbWUpXFxuICAgICAgICAgICAgbmF2aWdhdGVUbyhzdGFja1tuZXdGcmFtZV0sIGZyYW1lQ291bnQgPCAwKTtcXG5cXG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IG5ld0ZyYW1lO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlVG8ocGFuZU9wdGlvbnMsIHJldmVyc2UpIHtcXG4gICAgICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50KCduYXZpZ2F0aW5nJywgeyBub2RlOiBub2RlLCBvcHRpb25zOiBwYW5lT3B0aW9ucywgYnJvd3NlckRhdGE6IG9wdGlvbnMuYnJvd3NlckRhdGEgfSk7XFxuICAgICAgICBub2RlLnRyYW5zaXRpb25UbyhwYW5lT3B0aW9ucywgb3B0aW9ucy50cmFuc2l0aW9uLCByZXZlcnNlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB0cmltU3RhY2soKSB7XFxuICAgICAgICBzdGFjay5zcGxpY2UoY3VycmVudEZyYW1lICsgMSwgc3RhY2subGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIFQuVXRpbHMuZGV0YWNoRG9jdW1lbnRFdmVudCgnYnJvd3Nlci5nbycsIG9uQnJvd3NlckdvKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMoKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXFxuICAgICAgICAgICAgb3B0aW9ucyA9IHsgdHJhbnNpdGlvbjogb3B0aW9ucyB9O1xcbiAgICAgICAgaWYgKG9wdGlvbnMuYnJvd3NlciA9PT0gdHJ1ZSlcXG4gICAgICAgICAgICBvcHRpb25zLmJyb3dzZXIgPSBULm9wdGlvbnMuZGVmYXVsdFVybFByb3ZpZGVyO1xcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzZXRJbml0aWFsUGFuZVN0YXRlKCkge1xcbiAgICAgICAgdmFyIHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goL1xcXFwjLiovKTtcXG4gICAgICAgIGlmIChxdWVyeSkgcXVlcnkgPSBxdWVyeVswXS5zdWJzdHJpbmcoMSk7XFxuICAgICAgICB2YXIgdXJsU3RhdGUgPSBvcHRpb25zLmJyb3dzZXIgJiYgb3B0aW9ucy5icm93c2VyLnBhbmVPcHRpb25zRnJvbShxdWVyeSk7XFxuICAgICAgICBpZiAodXJsU3RhdGUpIHtcXG4gICAgICAgICAgICBub2RlLnBhbmUucGF0aCA9IHVybFN0YXRlLnBhdGg7XFxuICAgICAgICAgICAgbm9kZS5wYW5lLmRhdGEgPSB1cmxTdGF0ZS5kYXRhO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBpbml0aWFsU3RhY2tJdGVtKCkge1xcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogbm9kZS5wYW5lLnBhdGgsIGRhdGE6IG5vZGUucGFuZS5kYXRhIH07XFxuICAgIH1cXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9OYXZpZ2F0aW9uLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5UeXBlcy5Ob2RlID0gZnVuY3Rpb24gKHBhcmVudCwgcGFuZSkge1xcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IHRoaXM7XFxuICAgIHRoaXMuaWQgPSBULlV0aWxzLmdldFVuaXF1ZUlkKCk7XFxuXFxuICAgIGlmIChwYXJlbnQpIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xcbiAgICBpZiAocGFuZSkgdGhpcy5zZXRQYW5lKHBhbmUpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYXRoT3JQYW5lLCBkYXRhKSB7XFxuICAgIHZhciBwYW5lT3B0aW9ucyA9IFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGF0aE9yUGFuZSwgeyBkYXRhOiBkYXRhIH0pO1xcbiAgICBpZiAoIVQuUGF0aChwYW5lT3B0aW9ucy5wYXRoKS5pc0Fic29sdXRlKCkpXFxuICAgICAgICAvLyB0aGlzIGlzIGR1cGxpY2F0ZWQgaW4gUGFuZS5pbmhlcml0UGF0aEZyb20gLSB0aGUgY29uY2VwdCAocmVsYXRpdmUgcGF0aHMgaW5oZXJpdCBleGlzdGluZyBwYXRocykgbmVlZHMgdG8gYmUgY2xlYXJlclxcbiAgICAgICAgcGFuZU9wdGlvbnMucGF0aCA9IFQuUGF0aCh0aGlzLm5vZGVGb3JQYXRoKCkucGFuZS5wYXRoKS53aXRob3V0RmlsZW5hbWUoKS5jb21iaW5lKHBhbmVPcHRpb25zLnBhdGgpLnRvU3RyaW5nKCk7XFxuICAgIFxcbiAgICB0aGlzLmZpbmROYXZpZ2F0aW9uKCkubmF2aWdhdGUocGFuZU9wdGlvbnMpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5uYXZpZ2F0ZUJhY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZmluZE5hdmlnYXRpb24oKS5nbygtMSk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLmZpbmROYXZpZ2F0aW9uID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmRlZmF1bHROYXZpZ2F0aW9uKVxcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdE5hdmlnYXRpb247XFxuXFxuICAgIGVsc2UgaWYgKHRoaXMubmF2aWdhdGlvbilcXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb247XFxuICAgICAgICBcXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmV3IFQuVHlwZXMuTmF2aWdhdGlvbih0aGlzKTtcXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb247XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROYXZpZ2F0aW9uKCk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uKHBhbmVPcHRpb25zLCB0cmFuc2l0aW9uLCByZXZlcnNlKSB7XFxuICAgIFQudHJhbnNpdGlvbih0aGlzLCB0cmFuc2l0aW9uLCByZXZlcnNlKS50byhwYW5lT3B0aW9ucyk7XFxufTtcXG5cXG5ULlR5cGVzLk5vZGUucHJvdG90eXBlLnNldFBhbmUgPSBmdW5jdGlvbiAocGFuZSkge1xcbiAgICBpZiAodGhpcy5wYW5lKVxcbiAgICAgICAgdGhpcy5wYW5lLm5vZGUgPSBudWxsO1xcblxcbiAgICBwYW5lLm5vZGUgPSB0aGlzO1xcbiAgICB0aGlzLnBhbmUgPSBwYW5lO1xcbiAgICB0aGlzLnNraXBQYXRoID0gcGFuZS5za2lwUGF0aDtcXG5cXG4gICAgaWYgKHBhbmUuaGFuZGxlc05hdmlnYXRpb24pIHtcXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBULlR5cGVzLk5hdmlnYXRpb24odGhpcywgcGFuZS5oYW5kbGVzTmF2aWdhdGlvbik7XFxuICAgICAgICBcXG4gICAgICAgIC8vIHRoaXMgc2V0cyB0aGlzIHBhbmUgYXMgdGhlIFxcXCJkZWZhdWx0XFxcIiwgYWNjZXNzaWJsZSBmcm9tIHBhbmVzIG91dHNpZGUgdGhlIHRyZWUuIEZpcnN0IGluIGJlc3QgZHJlc3NlZC5cXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiB8fCB0aGlzLm5hdmlnYXRpb247XFxuICAgIH1cXG5cXG4gICAgcGFuZS5pbmhlcml0UGF0aEZyb20odGhpcy5wYXJlbnQpO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5ub2RlRm9yUGF0aCA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5za2lwUGF0aCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Lm5vZGVGb3JQYXRoKCkgOiB0aGlzO1xcbn07XFxuXFxuVC5UeXBlcy5Ob2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLnJvb3QuZGVmYXVsdE5hdmlnYXRpb24gPT09IHRoaXMubmF2aWdhdGlvbilcXG4gICAgICAgIHRoaXMucm9vdC5kZWZhdWx0TmF2aWdhdGlvbiA9IG51bGw7XFxuXFxuICAgIGlmICh0aGlzLnBhcmVudClcXG4gICAgICAgIFQuVXRpbHMucmVtb3ZlSXRlbSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcyk7XFxuXFxuICAgIGlmICh0aGlzLnBhbmUgJiYgdGhpcy5wYW5lLmRpc3Bvc2UpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhbmUubm9kZTtcXG4gICAgICAgIHRoaXMucGFuZS5kaXNwb3NlKCk7XFxuICAgIH1cXG59O1xcblxcblQuVHlwZXMuTm9kZS5wcm90b3R5cGUuc3RhcnRGbG93ID0gVC5UeXBlcy5GbG93LnN0YXJ0RmxvdztcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvTm9kZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuT3BlcmF0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciBpbmNvbXBsZXRlID0gW107XFxuXFxuICAgIHRoaXMucHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG5cXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgICAgaW5jb21wbGV0ZS5wdXNoKGlkKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgICAgVC5VdGlscy5yZW1vdmVJdGVtKGluY29tcGxldGUsIGlkKTtcXG4gICAgICAgIGlmIChpbmNvbXBsZXRlLmxlbmd0aCA9PT0gMClcXG4gICAgICAgICAgICBzZWxmLnByb21pc2UucmVzb2x2ZSgpO1xcbiAgICB9O1xcbiAgICBcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UeXBlcy9PcGVyYXRpb24uanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLlBhbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICBULlV0aWxzLmluaGVyaXRPcHRpb25zKG9wdGlvbnMsIHRoaXMsIFsncGF0aCcsICdkYXRhJywgJ2VsZW1lbnQnLCAndHJhbnNpdGlvbicsICdyZXZlcnNlVHJhbnNpdGlvbkluJywgJ2hhbmRsZXNOYXZpZ2F0aW9uJywgJ3B1YnN1YicsICdpZCcsICdza2lwUGF0aCddKTtcXG5cXG4gICAgLy8gZXZlbnRzIHdlIGFyZSBpbnRlcmVzdGVkIGluIGhvb2tpbmcgaW4gdG8gLSB0aGlzIGNvdWxkIGJlIGRvbmUgY29tcGxldGVseSBnZW5lcmljYWxseSBieSB0aGUgcGlwZWxpbmVcXG4gICAgdGhpcy5pcyA9IHtcXG4gICAgICAgIHJlbmRlcmVkOiAkLkRlZmVycmVkKCksXFxuICAgICAgICBkaXNwb3NlZDogJC5EZWZlcnJlZCgpXFxuICAgIH07ICAgIFxcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChwYXRoT3JQYW5lLCBkYXRhKSB7XFxuICAgIHRoaXMubm9kZSAmJiB0aGlzLm5vZGUubmF2aWdhdGUocGF0aE9yUGFuZSwgZGF0YSk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5ub2RlICYmIHRoaXMubm9kZS5uYXZpZ2F0ZUJhY2soKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKHRoaXMuZWxlbWVudCkucmVtb3ZlKCk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuZGlzcG9zZSlcXG4gICAgICAgIHRoaXMubW9kZWwuZGlzcG9zZSgpO1xcblxcbiAgICBpZiAodGhpcy5ub2RlKSB7XFxuICAgICAgICBkZWxldGUgdGhpcy5ub2RlLnBhbmU7XFxuICAgICAgICB0aGlzLm5vZGUuZGlzcG9zZSgpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmVsZW1lbnQpXFxuICAgICAgICBULlV0aWxzLmNsZWFuRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS5pbmhlcml0UGF0aEZyb20gPSBmdW5jdGlvbiAobm9kZSkge1xcbiAgICBub2RlID0gbm9kZSAmJiBub2RlLm5vZGVGb3JQYXRoKCk7XFxuICAgIHZhciBwYW5lID0gbm9kZSAmJiBub2RlLnBhbmU7ICAgIFxcbiAgICB2YXIgcGF0aCA9IFQuUGF0aCh0aGlzLnBhdGgpO1xcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKCkgfHwgIXBhbmUpXFxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoLm1ha2VBYnNvbHV0ZSgpLnRvU3RyaW5nKCk7XFxuICAgIGVsc2VcXG4gICAgICAgIHRoaXMucGF0aCA9IFQuUGF0aChwYW5lLnBhdGgpLndpdGhvdXRGaWxlbmFtZSgpLmNvbWJpbmUocGF0aCkudG9TdHJpbmcoKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XFxuICAgIHJldHVybiAkKHRoaXMuZWxlbWVudCkuZmluZChzZWxlY3Rvcik7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnN0YXJ0UmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKHRoaXMuZWxlbWVudCkuYWRkQ2xhc3MoJ19fcmVuZGVyaW5nJyk7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLmVuZFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgJCh0aGlzLmVsZW1lbnQpLnJlbW92ZUNsYXNzKCdfX3JlbmRlcmluZycpO1xcbn07XFxuXFxuVC5UeXBlcy5QYW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIFxcXCJ7IHBhdGg6ICdcXFwiICsgdGhpcy5wYXRoICsgXFxcIicgfVxcXCI7XFxufTtcXG5cXG5ULlR5cGVzLlBhbmUucHJvdG90eXBlLnN0YXJ0U2FnYSA9IGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcXG4gICAgdmFyIHNhZ2EgPSBULmNvbnRleHQoKS5zYWdhc1twYXRoXTtcXG4gICAgdGhpcy5wdWJzdWIuc3RhcnRTYWdhLmFwcGx5KHRoaXMucHVic3ViLCBbc2FnYS5jb25zdHJ1Y3Rvcl0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcXG59O1xcblxcblQuVHlwZXMuUGFuZS5wcm90b3R5cGUuc3RhcnRGbG93ID0gVC5UeXBlcy5GbG93LnN0YXJ0RmxvdztcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvUGFuZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuUGlwZWxpbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBjb250ZXh0KSB7XFxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uIChldmVudHNUb0V4ZWN1dGUsIHRhcmdldCkge1xcbiAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IC0xO1xcbiAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuICAgICAgICBleGVjdXRlTmV4dEV2ZW50KCk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlTmV4dEV2ZW50KCkge1xcbiAgICAgICAgICAgIGN1cnJlbnRFdmVudCsrO1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50RXZlbnQgPj0gZXZlbnRzVG9FeGVjdXRlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRzVG9FeGVjdXRlW2N1cnJlbnRFdmVudF07XFxuICAgICAgICAgICAgdmFyIHRoaXNFdmVudCA9IGV2ZW50c1tldmVudE5hbWVdO1xcblxcbiAgICAgICAgICAgIGlmICghdGhpc0V2ZW50KSB7XFxuICAgICAgICAgICAgICAgIFQubG9nZ2VyLndhcm4oXFxcIk5vIGV2ZW50IGRlZmluZWQgZm9yIFxcXCIgKyBldmVudE5hbWUpO1xcbiAgICAgICAgICAgICAgICBleGVjdXRlTmV4dEV2ZW50KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJC53aGVuKHRoaXNFdmVudCh0YXJnZXQsIGNvbnRleHQpKVxcbiAgICAgICAgICAgICAgICAuZG9uZShleGVjdXRlTmV4dEV2ZW50KVxcbiAgICAgICAgICAgICAgICAuZmFpbChoYW5kbGVGYWlsdXJlKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVGYWlsdXJlKCkge1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RGVzY3JpcHRpb24gPSB0YXJnZXQgPyB0YXJnZXQudG9TdHJpbmcoKSA6IFxcXCJlbXB0eSB0YXJnZXRcXFwiO1xcbiAgICAgICAgICAgICAgICBULmxvZ2dlci5lcnJvcihcXFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlICdcXFwiICsgZXZlbnROYW1lICsgXFxcIicgZXZlbnQgZm9yIFxcXCIgKyB0YXJnZXREZXNjcmlwdGlvbik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgIH07XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHlwZXMvUGlwZWxpbmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULlR5cGVzLlJlc291cmNlcyA9IGZ1bmN0aW9uICgpIHsgfTtcXG5cXG5ULlR5cGVzLlJlc291cmNlcy5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAocmVzb3VyY2VQYXRoLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xcbiAgICB0aGlzW3Jlc291cmNlUGF0aF0gPSB7XFxuICAgICAgICBjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XFxuICAgIH07XFxuICAgIFQubG9nZ2VyLmRlYnVnKFxcXCJNb2RlbCBsb2FkZWQgZm9yIFxcXCIgKyByZXNvdXJjZVBhdGgpO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL1Jlc291cmNlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuVHlwZXMuVGVtcGxhdGVzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuc3RvcmUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhdGgpIHtcXG4gICAgICAgIHZhciBpZCA9IFQuUGF0aChwYXRoKS5hc01hcmt1cElkZW50aWZpZXIoKS50b1N0cmluZygpO1xcbiAgICAgICAgZW1iZWRUZW1wbGF0ZSh0ZW1wbGF0ZSwgJ3RlbXBsYXRlLScgKyBpZCk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBlbWJlZFRlbXBsYXRlKHRlbXBsYXRlLCBpZCkge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC90ZW1wbGF0ZScpO1xcbiAgICAgICAgZWxlbWVudC5pZCA9IGlkO1xcbiAgICAgICAgZWxlbWVudC50ZXh0ID0gdGVtcGxhdGU7XFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xcbiAgICB9XFxuICAgIFxcbiAgICB0aGlzLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGgpIHtcXG4gICAgICAgIHJldHVybiAkKCdoZWFkIHNjcmlwdCN0ZW1wbGF0ZS0nICsgVC5QYXRoKHBhdGgpLmFzTWFya3VwSWRlbnRpZmllcigpKS5sZW5ndGggPiAwO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhdGgpIHtcXG4gICAgICAgIHZhciBpZCA9IFQuUGF0aChwYXRoKS5hc01hcmt1cElkZW50aWZpZXIoKTtcXG4gICAgICAgIC8vIGNhbid0IHVzZSBodG1sKCkgdG8gYXBwZW5kIC0gdGhpcyB1c2VzIHRoZSBlbGVtZW50IGlubmVySFRNTCBwcm9wZXJ0eSBhbmQgSUU3IGFuZCA4IHdpbGwgc3RyaXAgY29tbWVudHMgKGkuZS4gY29udGFpbmVybGVzcyBjb250cm9sIGZsb3cgYmluZGluZ3MpXFxuICAgICAgICAkKHRhcmdldCkuZW1wdHkoKS5hcHBlbmQoJCgnaGVhZCBzY3JpcHQjdGVtcGxhdGUtJyArIGlkKS5odG1sKCkpO1xcbiAgICB9O1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1R5cGVzL1RlbXBsYXRlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLmFjdGl2ZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHJldHVybiBULlV0aWxzLmVsZW1lbnREZXN0cm95ZWQocGFuZS5lbGVtZW50KTtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvYWN0aXZlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnRleHQubW9kZWxzW3BhbmUucGF0aF07XFxuICAgIHZhciBtb2RlbCA9IGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciA/XFxuICAgICAgICBuZXcgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcihwYW5lKSA6XFxuICAgICAgICB7IHBhbmU6IHBhbmUsIGRhdGE6IHBhbmUuZGF0YSB9O1xcblxcbiAgICBULlV0aWxzLmVtYmVkU3RhdGUobW9kZWwsIGNvbnRleHQsIHBhbmUubm9kZSk7XFxuXFxuICAgIHBhbmUubW9kZWwgPSBtb2RlbDtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvY3JlYXRlTW9kZWwuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5jcmVhdGVQdWJTdWIgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAoY29udGV4dC5wdWJzdWIpXFxuICAgICAgICBwYW5lLnB1YnN1YiA9IGNvbnRleHQucHVic3ViLmNyZWF0ZUxpZmV0aW1lID9cXG4gICAgICAgICAgICBjb250ZXh0LnB1YnN1Yi5jcmVhdGVMaWZldGltZSgpIDpcXG4gICAgICAgICAgICBjb250ZXh0LnB1YnN1YjtcXG59O1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9FdmVudHMvY3JlYXRlUHViU3ViLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuZGlzcG9zZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgIHBhbmUucHVic3ViICYmIHBhbmUucHVic3ViLmVuZCAmJiBwYW5lLnB1YnN1Yi5lbmQoKTtcXG4gICAgcGFuZS5kaXNwb3NlKCk7XFxuICAgIHBhbmUuaXMuZGlzcG9zZWQucmVzb2x2ZSgpO1xcbn07XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9kaXNwb3NlLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5FdmVudHMuaW5pdGlhbGlzZU1vZGVsID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgaWYgKHBhbmUubW9kZWwuaW5pdGlhbGlzZSlcXG4gICAgICAgIHJldHVybiBwYW5lLm1vZGVsLmluaXRpYWxpc2UoKTtcXG4gICAgcmV0dXJuIG51bGw7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL2luaXRpYWxpc2VNb2RlbC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLmxvYWRSZXNvdXJjZXMgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgc3RyYXRlZ3kgPSBULkxvYWRTdHJhdGVnaWVzW2NvbnRleHQub3B0aW9ucy5sb2FkU3RyYXRlZ3ldO1xcbiAgICBcXG4gICAgaWYgKCFzdHJhdGVneSlcXG4gICAgICAgIHRocm93IFxcXCJVbmtub3duIHJlc291cmNlIGxvYWQgc3RyYXRlZ3lcXFwiO1xcblxcbiAgICByZXR1cm4gc3RyYXRlZ3kocGFuZSwgY29udGV4dCk7XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvRXZlbnRzL2xvYWRSZXNvdXJjZXMuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5ULkV2ZW50cy5yZW5kZXJDb21wbGV0ZSA9IGZ1bmN0aW9uIChwYW5lLCBjb250ZXh0KSB7XFxuICAgICQud2hlbihcXG4gICAgICAgIFQudHJhbnNpdGlvbihwYW5lLCBwYW5lLnRyYW5zaXRpb24sIHBhbmUucmV2ZXJzZVRyYW5zaXRpb25JbilbJ2luJ10oKSlcXG4gICAgIC5kb25lKGV4ZWN1dGVSZW5kZXJDb21wbGV0ZSk7XFxuICAgIFxcbiAgICBwYW5lLmVuZFJlbmRlcigpO1xcblxcbiAgICBmdW5jdGlvbiBleGVjdXRlUmVuZGVyQ29tcGxldGUoKSB7XFxuICAgICAgICBpZiAocGFuZS5tb2RlbC5yZW5kZXJDb21wbGV0ZSlcXG4gICAgICAgICAgICBwYW5lLm1vZGVsLnJlbmRlckNvbXBsZXRlKCk7XFxuICAgICAgICBwYW5lLmlzLnJlbmRlcmVkLnJlc29sdmUoKTtcXG4gICAgICAgIFQuVXRpbHMucmFpc2VEb2N1bWVudEV2ZW50KCdyZW5kZXJDb21wbGV0ZScsIHBhbmUpO1xcbiAgICAgICAgY29udGV4dC5yZW5kZXJPcGVyYXRpb24gPSBuZXcgVC5UeXBlcy5PcGVyYXRpb24oKTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9yZW5kZXJDb21wbGV0ZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuRXZlbnRzLnJlbmRlclBhbmUgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICB2YXIgcmVuZGVyT3BlcmF0aW9uID0gY29udGV4dC5yZW5kZXJPcGVyYXRpb247XFxuXFxuICAgIHBhbmUuc3RhcnRSZW5kZXIoKTtcXG4gICAgY29udGV4dC50ZW1wbGF0ZXMucmVuZGVyKHBhbmUuZWxlbWVudCwgcGFuZS5wYXRoKTtcXG4gICAgVC5VdGlscy50cnlDYXRjaChhcHBseUJpbmRpbmdzLCBudWxsLCBjb250ZXh0Lm9wdGlvbnMuaGFuZGxlRXhjZXB0aW9ucywgJ0FuIGVycm9yIG9jY3VycmVkIGFwcGx5aW5nIHRoZSBiaW5kaW5ncyBmb3IgJyArIHBhbmUudG9TdHJpbmcoKSk7XFxuXFxuICAgIGlmIChwYW5lLm1vZGVsLnBhbmVSZW5kZXJlZClcXG4gICAgICAgIHBhbmUubW9kZWwucGFuZVJlbmRlcmVkKCk7XFxuXFxuICAgIHJlbmRlck9wZXJhdGlvbi5jb21wbGV0ZShwYW5lKTtcXG4gICAgcmV0dXJuIHJlbmRlck9wZXJhdGlvbi5wcm9taXNlO1xcblxcbiAgICBmdW5jdGlvbiBhcHBseUJpbmRpbmdzKCkge1xcbiAgICAgICAga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMocGFuZS5tb2RlbCwgcGFuZS5lbGVtZW50KTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0V2ZW50cy9yZW5kZXJQYW5lLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuanMgPSBmdW5jdGlvbiAodXJsLCByZXNvdXJjZVBhdGgsIGNvbnRleHQpIHtcXG4gICAgcmV0dXJuICQuYWpheCh7XFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGRhdGFUeXBlOiAndGV4dCcsXFxuICAgICAgICBhc3luYzogIWNvbnRleHQub3B0aW9ucy5zeW5jaHJvbm91cyxcXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgIHN1Y2Nlc3M6IGV4ZWN1dGVTY3JpcHRcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVTY3JpcHQoc2NyaXB0KSB7XFxuICAgICAgICBULnNjcmlwdEVudmlyb25tZW50ID0ge1xcbiAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgIHJlc291cmNlUGF0aDogcmVzb3VyY2VQYXRoLFxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBULlV0aWxzLnRyeUNhdGNoKCQuZ2xvYmFsRXZhbCwgW2FwcGVuZFNvdXJjZVVybChzY3JpcHQpXSwgY29udGV4dC5vcHRpb25zLmhhbmRsZUV4Y2VwdGlvbnMsXFxuICAgICAgICAgICAgJ0FuIGVycm9yIG9jY3VycmVkIGV4ZWN1dGluZyBzY3JpcHQgbG9hZGVkIGZyb20gJyArIHVybCArIChyZXNvdXJjZVBhdGggPyAnIGZvciByZXNvdXJjZSAnICsgcmVzb3VyY2VQYXRoIDogJycpKTtcXG5cXG4gICAgICAgIGRlbGV0ZSBULnNjcmlwdEVudmlyb25tZW50O1xcblxcbiAgICAgICAgVC5sb2dnZXIuZGVidWcoJ0xvYWRlZCBzY3JpcHQgZnJvbSAnICsgdXJsKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhcHBlbmRTb3VyY2VVcmwoc2NyaXB0KSB7XFxuICAgICAgICByZXR1cm4gc2NyaXB0ICsgJ1xcXFxuLy9AIHNvdXJjZVVSTD10cmliZTovL0FwcGxpY2F0aW9uLycgKyB1cmwucmVwbGFjZSgvIC9nLCBcXFwiX1xcXCIpO1xcbiAgICB9ICAgIFxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0xvYWRIYW5kbGVycy9zY3JpcHRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuY3NzID0gZnVuY3Rpb24gKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdXBwb3J0c1RleHROb2RlcyA9IHRydWU7XFxuICAgIFxcbiAgICByZXR1cm4gJC5hamF4KHtcXG4gICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcXG4gICAgICAgIGFzeW5jOiAhY29udGV4dC5vcHRpb25zLnN5bmNocm9ub3VzLFxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxcbiAgICAgICAgc3VjY2VzczogcmVuZGVyU3R5bGVzaGVldFxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gcmVuZGVyU3R5bGVzaGVldChzdHlsZXNoZWV0KSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX3RyaWJlU3R5bGVzJyk7XFxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICdfX3RyaWJlJztcXG4gICAgICAgICAgICBlbGVtZW50LmlkID0gJ19fdHJpYmVTdHlsZXMnO1xcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZihzdXBwb3J0c1RleHROb2RlcylcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlc2hlZXQpKTtcXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XFxuICAgICAgICAgICAgICAgIHN1cHBvcnRzVGV4dE5vZGVzID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFzdXBwb3J0c1RleHROb2RlcylcXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHN0eWxlU2hlZXQuY3NzVGV4dCBpcyByZXF1aXJlZCBmb3IgSUU4IHN1cHBvcnRcXG4gICAgICAgICAgICAgICAgLy8gSUU4IGFsc28gaGFzIGEgbGltaXQgb24gdGhlIG51bWJlciBvZiA8c3R5bGUvPiBlbGVtZW50cywgc28gYXBwZW5kIGl0IHRvIHRoZSBzYW1lIG5vZGVcXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gc3R5bGVzaGVldDtcXG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gYXBwZW5kIHN0eWxlc2hlZXQgZm9yICcgKyByZXNvdXJjZVBhdGggKyAnIHRvIGRvY3VtZW50LicpO1xcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZEhhbmRsZXJzL3N0eWxlc2hlZXRzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5Mb2FkSGFuZGxlcnMuaHRtID0gZnVuY3Rpb24gKHVybCwgcmVzb3VyY2VQYXRoLCBjb250ZXh0KSB7XFxuICAgIHJldHVybiAkLmFqYXgoe1xcbiAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxcbiAgICAgICAgYXN5bmM6ICFjb250ZXh0Lm9wdGlvbnMuc3luY2hyb25vdXMsXFxuICAgICAgICBjYWNoZTogZmFsc2UsXFxuICAgICAgICBzdWNjZXNzOiBzdG9yZVRlbXBsYXRlXFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBzdG9yZVRlbXBsYXRlKHRlbXBsYXRlKSB7XFxuICAgICAgICBjb250ZXh0LnRlbXBsYXRlcy5zdG9yZSh0ZW1wbGF0ZSwgcmVzb3VyY2VQYXRoKTtcXG4gICAgfVxcbn07XFxuVC5Mb2FkSGFuZGxlcnMuaHRtbCA9IFQuTG9hZEhhbmRsZXJzLmh0bTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvTG9hZEhhbmRsZXJzL3RlbXBsYXRlcy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuTG9hZFN0cmF0ZWdpZXMuYWRob2MgPSBmdW5jdGlvbiAocGFuZSwgY29udGV4dCkge1xcbiAgICBpZiAoY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdICE9PSB1bmRlZmluZWQpXFxuICAgICAgICByZXR1cm4gY29udGV4dC5sb2FkZWRQYW5lc1twYW5lLnBhdGhdO1xcblxcbiAgICB2YXIgcGF0aCA9IFQuUGF0aChjb250ZXh0Lm9wdGlvbnMuYmFzZVBhdGgpLmNvbWJpbmUoVC5QYXRoKHBhbmUucGF0aCkubWFrZVJlbGF0aXZlKCkpO1xcblxcbiAgICBpZiAoY29udGV4dC50ZW1wbGF0ZXMubG9hZGVkKHBhbmUucGF0aCkgfHwgY29udGV4dC5tb2RlbHNbcGFuZS5wYXRoXSlcXG4gICAgICAgIHJldHVybiBudWxsO1xcblxcbiAgICB2YXIgZGVmZXJyZWQgPSAkLmNvbXBsZXRlKFtcXG4gICAgICAgIGNvbnRleHQubG9hZGVyLmdldChwYXRoLnNldEV4dGVuc2lvbignanMnKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpLFxcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdodG0nKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpLFxcbiAgICAgICAgY29udGV4dC5sb2FkZXIuZ2V0KHBhdGguc2V0RXh0ZW5zaW9uKCdjc3MnKS50b1N0cmluZygpLCBwYW5lLnBhdGgsIGNvbnRleHQpXFxuICAgIF0pO1xcblxcbiAgICBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gPSBkZWZlcnJlZDtcXG5cXG4gICAgJC53aGVuKGRlZmVycmVkKVxcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgVC5sb2dnZXIuZXJyb3IoXFxcIlVuYWJsZSB0byBsb2FkIHJlc291cmNlcyBmb3IgJ1xcXCIgKyBwYW5lLnBhdGggKyBcXFwiJy5cXFwiKTtcXG4gICAgICAgIH0pXFxuICAgICAgICAuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmxvYWRlZFBhbmVzW3BhbmUucGF0aF0gPSBudWxsO1xcbiAgICAgICAgfSk7XFxuXFxuICAgIHJldHVybiBkZWZlcnJlZDtcXG59O1xcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9Mb2FkU3RyYXRlZ2llcy9hZGhvYy5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQuTG9hZFN0cmF0ZWdpZXMucHJlbG9hZGVkID0gZnVuY3Rpb24gKHBhbmUsIGNvbnRleHQpIHtcXG4gICAgaWYgKCFjb250ZXh0Lm1vZGVsc1twYW5lLnBhdGhdICYmICFjb250ZXh0LnRlbXBsYXRlcy5sb2FkZWQocGFuZS5wYXRoKSkge1xcbiAgICAgICAgVC5sb2dnZXIuZXJyb3IoXFxcIk5vIHJlc291cmNlcyBsb2FkZWQgZm9yICdcXFwiICsgcGFuZS5wYXRoICsgXFxcIicuXFxcIik7XFxuICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlamVjdCgpO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0xvYWRTdHJhdGVnaWVzL3ByZWxvYWRlZC5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcblQudHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHRyYW5zaXRpb24sIHJldmVyc2UpIHtcXG4gICAgdmFyIG5vZGU7XFxuICAgIHZhciBwYW5lO1xcbiAgICB2YXIgZWxlbWVudDtcXG4gICAgc2V0U3RhdGUoKTtcXG4gICAgXFxuICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHx8IChwYW5lICYmIHBhbmUudHJhbnNpdGlvbikgfHwgKG5vZGUgJiYgbm9kZS50cmFuc2l0aW9uKTtcXG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gVC5UcmFuc2l0aW9uc1t0cmFuc2l0aW9uXTtcXG4gICAgaWYgKHJldmVyc2UgJiYgaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ucmV2ZXJzZSlcXG4gICAgICAgIGltcGxlbWVudGF0aW9uID0gVC5UcmFuc2l0aW9uc1tpbXBsZW1lbnRhdGlvbi5yZXZlcnNlXTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAgICdpbic6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkKGVsZW1lbnQpLnNob3coKTtcXG4gICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb25bJ2luJ10oZWxlbWVudCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICBvdXQ6IGZ1bmN0aW9uIChyZW1vdmUpIHtcXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uTW9kZSgpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24ub3V0KGVsZW1lbnQpO1xcbiAgICAgICAgICAgICQud2hlbihwcm9taXNlKS5kb25lKHJlbW92ZUVsZW1lbnQpO1xcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XFxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmhpZGUoKS5hdHRyKCdzdHlsZScsICcnKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlXFxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBcXG4gICAgICAgIHRvOiBmdW5jdGlvbiAocGFuZU9wdGlvbnMsIHJlbW92ZSkge1xcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gVC5jb250ZXh0KCk7XFxuICAgICAgICAgICAgaWYgKG5vZGUpXFxuICAgICAgICAgICAgICAgIFQuVXRpbHMuaW5zZXJ0UGFuZUFmdGVyKG5vZGUsIGVsZW1lbnQsIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMocGFuZU9wdGlvbnMsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgcmV2ZXJzZVRyYW5zaXRpb25JbjogcmV2ZXJzZSB9KSwgY29udGV4dCk7XFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICBULmluc2VydE5vZGVBZnRlcihlbGVtZW50LCBULlV0aWxzLmdldFBhbmVPcHRpb25zKHBhbmVPcHRpb25zLCB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHJldmVyc2VUcmFuc2l0aW9uSW46IHJldmVyc2UgfSksIG51bGwsIGNvbnRleHQpO1xcbiAgICAgICAgICAgIHRoaXMub3V0KHJlbW92ZSk7XFxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucmVuZGVyT3BlcmF0aW9uLnByb21pc2U7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uTW9kZSgpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuICAgICAgICBpZiAoVC50cmFuc2l0aW9uLm1vZGUgPT09ICdmaXhlZCcpXFxuICAgICAgICAgICAgJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAkZWxlbWVudC53aWR0aCgpLFxcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZWxlbWVudC5vZmZzZXQoKS5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6ICRlbGVtZW50Lm9mZnNldCgpLnRvcFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgICAgICAgICAgICB3aWR0aDogJGVsZW1lbnQud2lkdGgoKSxcXG4gICAgICAgICAgICAgICAgbGVmdDogJGVsZW1lbnQucG9zaXRpb24oKS5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6ICRlbGVtZW50LnBvc2l0aW9uKCkudG9wXFxuICAgICAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0U3RhdGUoKSB7XFxuICAgICAgICBpZiAoIXRhcmdldCkgdGhyb3cgXFxcIk5vIHRhcmdldCBwYXNzZWQgdG8gVC50cmFuc2l0aW9uXFxcIjtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5Ob2RlKSB7XFxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldDtcXG4gICAgICAgICAgICBwYW5lID0gbm9kZS5wYW5lO1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYW5lLmVsZW1lbnQ7XFxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gVC5UeXBlcy5QYW5lKSB7XFxuICAgICAgICAgICAgcGFuZSA9IHRhcmdldDtcXG4gICAgICAgICAgICBub2RlID0gcGFuZS5ub2RlO1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYW5lLmVsZW1lbnQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0YXJnZXQ7XFxuICAgICAgICB9XFxuICAgIH0gICAgXFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvVHJhbnNpdGlvbnMvdHJhbnNpdGlvbi5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0c1RyYW5zaXRpb25zKCk7XFxuICAgIFxcbiAgICBjcmVhdGVDc3NUcmFuc2l0aW9uKCdmYWRlJyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlTGVmdCcsICdzbGlkZVJpZ2h0Jyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlUmlnaHQnLCAnc2xpZGVMZWZ0Jyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlVXAnLCAnc2xpZGVEb3duJyk7XFxuICAgIGNyZWF0ZUNzc1RyYW5zaXRpb24oJ3NsaWRlRG93bicsICdzbGlkZVVwJyk7XFxuXFxuICAgIHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgdHJhbnNpdGlvbmVuZCBtc1RyYW5zaXRpb25FbmQnO1xcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVDc3NUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHJldmVyc2UpIHtcXG4gICAgICAgIFQuVHJhbnNpdGlvbnNbdHJhbnNpdGlvbl0gPSB7XFxuICAgICAgICAgICAgJ2luJzogZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHJldHVybiBudWxsO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCk7XFxuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYmluZCh0cmFuc2l0aW9uRW5kRXZlbnRzLCB0cmFuc2l0aW9uRW5kZWQoZWxlbWVudCwgcHJvbWlzZSkpXFxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3ByZXBhcmUgaW4gJyArIHRyYW5zaXRpb24pO1xcblxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIG91dDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHJldHVybiBudWxsO1xcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcXG5cXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygncHJlcGFyZSBvdXQgJyArIHRyYW5zaXRpb24pXFxuICAgICAgICAgICAgICAgICAgICAub24odHJhbnNpdGlvbkVuZEV2ZW50cywgdHJhbnNpdGlvbkVuZGVkKGVsZW1lbnQsIHByb21pc2UsIHRydWUpKTtcXG5cXG4gICAgICAgICAgICAgICAgdHJpZ2dlcihlbGVtZW50KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICByZXZlcnNlOiByZXZlcnNlIHx8IHRyYW5zaXRpb25cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyKGVsZW1lbnQpIHtcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygndHJpZ2dlcicpO1xcbiAgICAgICAgICAgIH0sIDMwKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRlZChlbGVtZW50LCBwcm9taXNlLCBoaWRlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnVuYmluZCh0cmFuc2l0aW9uRW5kRXZlbnRzKVxcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRyYW5zaXRpb24gKyAnIGluIG91dCBwcmVwYXJlIHRyaWdnZXInKTtcXG4gICAgICAgICAgICAgICAgaWYgKGhpZGUpICQoZWxlbWVudCkuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIFxcbiAgICBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25zKCkge1xcbiAgICAgICAgdmFyIGIgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG4gICAgICAgIHZhciBzdHlsZSA9IGIuc3R5bGU7XFxuICAgICAgICB2YXIgcHJvcGVydHkgPSAndHJhbnNpdGlvbic7XFxuICAgICAgICB2YXIgdmVuZG9ycyA9IFsnTW96JywgJ1dlYmtpdCcsICdLaHRtbCcsICdPJywgJ21zJ107XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BlcnR5XSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxcblxcbiAgICAgICAgLy8gVGVzdHMgZm9yIHZlbmRvciBzcGVjaWZpYyBwcm9wXFxuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbdmVuZG9yc1tpXSArIHByb3BlcnR5XSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9UcmFuc2l0aW9ucy9Dc3MvY3NzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuXFxuLy9cXG53aW5kb3cuX19hcHBlbmRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XFxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fdHJpYmVTdHlsZXMnKTtcXG4gICAgaWYgKCFlbGVtZW50KSB7XFxuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ19fdHJpYmUnO1xcbiAgICAgICAgZWxlbWVudC5pZCA9ICdfX3RyaWJlU3R5bGVzJztcXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYoZWxlbWVudC5zdHlsZVNoZWV0KVxcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gY29udGVudDtcXG4gICAgZWxzZVxcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XFxufTsvL1xcbndpbmRvdy5fX2FwcGVuZFN0eWxlKCcudHJpZ2dlcnstd2Via2l0LXRyYW5zaXRpb246YWxsIDI1MG1zIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246YWxsIDI1MG1zIGVhc2UtaW4tb3V0fS5mYWRlLmluLnByZXBhcmV7b3BhY2l0eTowfS5mYWRlLmluLnRyaWdnZXJ7b3BhY2l0eToxfS5mYWRlLm91dC5wcmVwYXJle29wYWNpdHk6MX0uZmFkZS5vdXQudHJpZ2dlcntvcGFjaXR5OjB9LnNsaWRlUmlnaHQuaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LnNsaWRlUmlnaHQuaW4udHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfS5zbGlkZVJpZ2h0Lm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSl9LnNsaWRlTGVmdC5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSl9LnNsaWRlTGVmdC5pbi50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnNsaWRlTGVmdC5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LnNsaWRlRG93bi5pbi5wcmVwYXJley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKX0uc2xpZGVEb3duLmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX0uc2xpZGVEb3duLm91dC50cmlnZ2Vyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSl9LnNsaWRlVXAuaW4ucHJlcGFyZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpfS5zbGlkZVVwLmluLnRyaWdnZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX0uc2xpZGVVcC5vdXQudHJpZ2dlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwJSl9Jyk7XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL1RyYW5zaXRpb25zL0Nzcy9zdHlsZS5jc3MuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICBULnJlZ2lzdGVyTW9kZWwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhZGRSZXNvdXJjZSgnbW9kZWxzJywgVC5VdGlscy5hcmd1bWVudHMoYXJndW1lbnRzKSk7XFxuICAgIH07XFxuXFxuICAgIFQucmVnaXN0ZXJTYWdhID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYWRkUmVzb3VyY2UoJ3NhZ2FzJywgVC5VdGlscy5hcmd1bWVudHMoYXJndW1lbnRzKSk7XFxuICAgIH07XFxuICAgIFxcbiAgICBmdW5jdGlvbiBhZGRSZXNvdXJjZShjb250ZXh0UHJvcGVydHksIGFyZ3MpIHtcXG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IFQuc2NyaXB0RW52aXJvbm1lbnQgfHwge307XFxuICAgICAgICB2YXIgY29udGV4dCA9IGVudmlyb25tZW50LmNvbnRleHQgfHwgVC5jb250ZXh0KCk7XFxuXFxuICAgICAgICB2YXIgcGF0aCA9IGFyZ3Muc3RyaW5nIHx8IGVudmlyb25tZW50LnJlc291cmNlUGF0aDtcXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZ3MuZnVuYztcXG4gICAgICAgIHZhciBvcHRpb25zID0gYXJncy5vYmplY3Q7XFxuXFxuICAgICAgICBjb250ZXh0W2NvbnRleHRQcm9wZXJ0eV0ucmVnaXN0ZXIocGF0aCwgY29uc3RydWN0b3IsIG9wdGlvbnMpO1xcbiAgICB9XFxuXFxuICAgIFQucnVuID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICAgICAgVC5vcHRpb25zID0gJC5leHRlbmQoVC5vcHRpb25zLCBvcHRpb25zKTtcXG4gICAgICAgIFQub3B0aW9ucy5wdWJzdWIgPSBULm9wdGlvbnMucHVic3ViIHx8IG5ldyBUcmliZS5QdWJTdWIoeyBzeW5jOiBULm9wdGlvbnMuc3luY2hyb25vdXMsIGhhbmRsZUV4Y2VwdGlvbnM6IFQub3B0aW9ucy5oYW5kbGVFeGNlcHRpb25zIH0pO1xcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncygpO1xcbiAgICAgICAgLy9pZiAocHJlbG9hZCkge1xcbiAgICAgICAgLy8gICAgdmFyIHByb21pc2VzID0gW107XFxuICAgICAgICAvLyAgICB2YXIgY29udGV4dCA9IFQuY29udGV4dCgpO1xcblxcbiAgICAgICAgLy8gICAgaWYgKCQuaXNBcnJheShwcmVsb2FkKSlcXG4gICAgICAgIC8vICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByZWxvYWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxcbiAgICAgICAgLy8gICAgICAgICAgICBhZGRQcm9taXNlKHByZWxvYWRbaV0pO1xcbiAgICAgICAgLy8gICAgZWxzZSBpZihwcmVsb2FkLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXFxuICAgICAgICAvLyAgICAgICAgYWRkUHJvbWlzZShwcmVsb2FkKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgIC8vICAgIGZ1bmN0aW9uIGFkZFByb21pc2UocGF0aCkge1xcbiAgICAgICAgLy8gICAgICAgIHByb21pc2VzLnB1c2goY29udGV4dC5sb2FkZXIuZ2V0KFQuUGF0aChjb250ZXh0Lm9wdGlvbnMuYmFzZVBhdGgpLmNvbWJpbmUocGF0aCkudG9TdHJpbmcoKSwgbnVsbCwgY29udGV4dCkpO1xcbiAgICAgICAgLy8gICAgfVxcblxcbiAgICAgICAgLy8gICAgcmV0dXJuICQud2hlbi5hcHBseShudWxsLCBwcm9taXNlcykuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyAgICAgICAga28uYXBwbHlCaW5kaW5ncyhtb2RlbCk7XFxuICAgICAgICAvLyAgICB9KTtcXG4gICAgICAgIC8vfSBlbHNlXFxuICAgICAgICAvLyAgICBrby5hcHBseUJpbmRpbmdzKG1vZGVsKTtcXG4gICAgfTtcXG59KSgpOyBcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL2FwaS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0aWNTdGF0ZTtcXG5cXG4gICAgVC5jb250ZXh0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgc3RhdGljU3RhdGUgPSBzdGF0aWNTdGF0ZSB8fCB7XFxuICAgICAgICAgICAgbW9kZWxzOiBuZXcgVC5UeXBlcy5SZXNvdXJjZXMoKSxcXG4gICAgICAgICAgICBzYWdhczogbmV3IFQuVHlwZXMuUmVzb3VyY2VzKCksXFxuICAgICAgICAgICAgbG9hZGVyOiBuZXcgVC5UeXBlcy5Mb2FkZXIoKSxcXG4gICAgICAgICAgICBvcHRpb25zOiBULm9wdGlvbnMsXFxuICAgICAgICAgICAgdGVtcGxhdGVzOiBuZXcgVC5UeXBlcy5UZW1wbGF0ZXMoKSxcXG4gICAgICAgICAgICBsb2FkZWRQYW5lczoge31cXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgcGVyQ29udGV4dFN0YXRlID0ge1xcbiAgICAgICAgICAgIHJlbmRlck9wZXJhdGlvbjogbmV3IFQuVHlwZXMuT3BlcmF0aW9uKCksXFxuICAgICAgICAgICAgcHVic3ViOiBULm9wdGlvbnMucHVic3ViXFxuICAgICAgICB9O1xcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBzdGF0aWNTdGF0ZSwgcGVyQ29udGV4dFN0YXRlLCBzb3VyY2UpO1xcbiAgICB9O1xcbn0pKCk7XFxuXFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0FwaS9jb250ZXh0LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuVC5vcHRpb25zLmRlZmF1bHRVcmxQcm92aWRlciA9IHtcXG4gICAgdXJsRGF0YUZyb206IGZ1bmN0aW9uKHBhbmVPcHRpb25zKSB7XFxuICAgICAgICByZXR1cm4gcGFuZU9wdGlvbnMgJiYgeyB1cmw6ICcjJyArICQucGFyYW0ocGFuZU9wdGlvbnMpIH07XFxuICAgIH0sXFxuICAgIHBhbmVPcHRpb25zRnJvbTogZnVuY3Rpb24odXJsKSB7XFxuICAgICAgICByZXR1cm4gdXJsICYmIFQuVXRpbHMuZGVwYXJhbSh1cmwuc3Vic3RyKDEpKTtcXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0FwaS9kZWZhdWx0VXJsUHJvdmlkZXIuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdXRpbHMgPSBULlV0aWxzO1xcblxcbiAgICBULmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcXG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlIHx8IFQubm9kZUZvcihlbGVtZW50KTtcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHV0aWxzLmNvbnRleHRGb3IoZWxlbWVudCkgfHwgVC5jb250ZXh0KCk7XFxuXFxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBULlR5cGVzLk5vZGUocGFyZW50Tm9kZSk7XFxuICAgICAgICB1dGlscy5iaW5kUGFuZShub2RlLCBlbGVtZW50LCBwYW5lT3B0aW9ucywgY29udGV4dCk7XFxuXFxuICAgICAgICByZXR1cm4gbm9kZTtcXG4gICAgfTtcXG5cXG4gICAgVC5hcHBlbmROb2RlID0gZnVuY3Rpb24gKHRhcmdldCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCgnPGRpdi8+JykuYXBwZW5kVG8odGFyZ2V0KTtcXG4gICAgICAgIHJldHVybiBULmNyZWF0ZU5vZGUoZWxlbWVudCwgcGFuZU9wdGlvbnMsIHBhcmVudE5vZGUsIGNvbnRleHQpO1xcbiAgICB9O1xcblxcbiAgICBULmluc2VydE5vZGVBZnRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhbmVPcHRpb25zLCBwYXJlbnROb2RlLCBjb250ZXh0KSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoJzxkaXYvPicpLmluc2VydEFmdGVyKHRhcmdldCk7XFxuICAgICAgICByZXR1cm4gVC5jcmVhdGVOb2RlKGVsZW1lbnQsIHBhbmVPcHRpb25zLCBwYXJlbnROb2RlIHx8IFQubm9kZUZvcih0YXJnZXQpLCBjb250ZXh0KTtcXG4gICAgfTtcXG5cXG4gICAgVC5ub2RlRm9yID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIFQuVXRpbHMuZXh0cmFjdE5vZGUoa28uY29udGV4dEZvcigkKGVsZW1lbnQpWzBdKSk7XFxuICAgIH07XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQXBpL25vZGVzLmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxuKGZ1bmN0aW9uKCkge1xcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaFByb3BlcnR5ID0ge1xcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcXG4gICAgICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmZvcmVhY2guaW5pdChlbGVtZW50LCBtYWtlQWNjZXNzb3IobWFwVG9BcnJheSh2YWx1ZUFjY2Vzc29yKCkpKSwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaC51cGRhdGUoZWxlbWVudCwgbWFrZUFjY2Vzc29yKG1hcFRvQXJyYXkodmFsdWVBY2Nlc3NvcigpKSksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBcXG4gICAgZnVuY3Rpb24gbWFrZUFjY2Vzc29yKHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG1hcFRvQXJyYXkoc291cmNlKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpXFxuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXFxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBvYmplY3QsIGV4dGVuZCBpdCBvbnRvIGEgbmV3IG9iamVjdFxcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgkLmV4dGVuZCh7ICRrZXk6IHByb3BlcnR5IH0sIHNvdXJjZVtwcm9wZXJ0eV0pKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG59KSgpO1xcblxcbi8vQCBzb3VyY2VVUkw9aHR0cDovL1RyaWJlLkNvbXBvc2l0ZS9CaW5kaW5nSGFuZGxlcnMvZm9yZWFjaFByb3BlcnR5LmpzXCIpO1xuXG5cbndpbmRvdy5ldmFsKFwiXFxua28uYmluZGluZ0hhbmRsZXJzLm5hdmlnYXRlID0ge1xcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgdmFyIG5vZGUgPSBULm5vZGVGb3IoZWxlbWVudCk7XFxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcXG5cXG4gICAgICAgIHZhciBkYXRhID0gVC5VdGlscy5ub3JtYWxpc2VCaW5kaW5ncyh2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yKTtcXG4gICAgICAgIHZhciBoYW5kbGVyID0ga28uYmluZGluZ0hhbmRsZXJzLnZhbGlkYXRlZENsaWNrIHx8IGtvLmJpbmRpbmdIYW5kbGVycy5jbGljaztcXG4gICAgICAgIGhhbmRsZXIuaW5pdChlbGVtZW50LCBuYXZpZ2F0ZSwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIG5hdmlnYXRlKCkge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG5vZGUubmF2aWdhdGUoZGF0YS52YWx1ZSwgVC5VdGlscy5jbG9uZURhdGEoZGF0YS5kYXRhKSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0JpbmRpbmdIYW5kbGVycy9uYXZpZ2F0ZS5qc1wiKTtcblxuXG53aW5kb3cuZXZhbChcIlxcbmtvLmJpbmRpbmdIYW5kbGVycy5uYXZpZ2F0ZUJhY2sgPSB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XFxuICAgICAgICB2YXIgbm9kZSA9IFQubm9kZUZvcihlbGVtZW50KTtcXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xcblxcbiAgICAgICAga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrLmluaXQoZWxlbWVudCwgbmF2aWdhdGVCYWNrLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gbmF2aWdhdGVCYWNrKCkge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG5vZGUubmF2aWdhdGVCYWNrKCk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuLy9AIHNvdXJjZVVSTD1odHRwOi8vVHJpYmUuQ29tcG9zaXRlL0JpbmRpbmdIYW5kbGVycy9uYXZpZ2F0ZUJhY2suanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG4oZnVuY3Rpb24oKSB7XFxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5wYW5lID0geyBpbml0OiB1cGRhdGVCaW5kaW5nIH07XFxuXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJpbmRpbmcoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xcbiAgICAgICAgVC5jcmVhdGVOb2RlKGVsZW1lbnQsIGNvbnN0cnVjdFBhbmVPcHRpb25zKCksIFQuVXRpbHMuZXh0cmFjdE5vZGUoYmluZGluZ0NvbnRleHQpLCBULlV0aWxzLmV4dHJhY3RDb250ZXh0KGJpbmRpbmdDb250ZXh0KSk7XFxuXFxuICAgICAgICByZXR1cm4geyBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZSB9O1xcblxcbiAgICAgICAgZnVuY3Rpb24gY29uc3RydWN0UGFuZU9wdGlvbnMoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFQuVXRpbHMuZ2V0UGFuZU9wdGlvbnMoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpLCBhbGxCaW5kaW5nc0FjY2Vzc29yKCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufSkoKTtcXG5cXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL3BhbmUuanNcIik7XG5cblxud2luZG93LmV2YWwoXCJcXG5rby5iaW5kaW5nSGFuZGxlcnMucHVibGlzaCA9IHtcXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcXG4gICAgICAgIHZhciBwdWJzdWIgPSBULm5vZGVGb3IoZWxlbWVudCkucGFuZS5wdWJzdWI7XFxuICAgICAgICBpZiAoIXB1YnN1YikgcmV0dXJuO1xcblxcbiAgICAgICAgdmFyIGRhdGEgPSBULlV0aWxzLm5vcm1hbGlzZUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBrby5iaW5kaW5nSGFuZGxlcnMudmFsaWRhdGVkQ2xpY2sgfHwga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrO1xcbiAgICAgICAgaGFuZGxlci5pbml0KGVsZW1lbnQsIHB1Ymxpc2hBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hBY2Nlc3NvcigpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBwdWJzdWIucHVibGlzaChkYXRhLnZhbHVlLCBULlV0aWxzLmNsb25lRGF0YShkYXRhLmRhdGEpKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG4vL0Agc291cmNlVVJMPWh0dHA6Ly9UcmliZS5Db21wb3NpdGUvQmluZGluZ0hhbmRsZXJzL3B1Ymxpc2guanNcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNhZ2E6IFQucmVnaXN0ZXJTYWdhLFxyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCByZWdpc3RlciBhIHN0YXRpYyBoYW5kbGVyIG9uIHRoZSBjbGllbnQgKHlldCkhXCIpO1xyXG4gICAgfSxcclxuICAgIHNlcnZpY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgcmVnaXN0ZXIgYSBzZXJ2aWNlIG9uIHRoZSBjbGllbnQhXCIpO1xyXG4gICAgfVxyXG59OyJdfQ==
