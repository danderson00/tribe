/*! The Tribe platform is licensed under the MIT license. See http://tribejs.com/ for more information. */
window.eval("window.Tribe = window.Tribe || {};\nTribe.PubSub = function (options) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    this.owner = this;\n    this.sync = option('sync');\n     \n    var subscribers = new Tribe.PubSub.SubscriberList();\n    this.subscribers = subscribers;\n\n    function publish(envelope) {\n        var messageSubscribers = subscribers.get(envelope.topic);\n        var sync = envelope.sync === true || self.sync === true;\n\n        for (var i = 0, l = messageSubscribers.length; i < l; i++) {\n            if (sync)\n                executeSubscriber(messageSubscribers[i].handler);\n            else {\n                (function (subscriber) {\n                    setTimeout(function () {\n                        executeSubscriber(subscriber.handler);\n                    });\n                })(messageSubscribers[i]);\n            }\n        }\n\n        function executeSubscriber(func) {\n            var exceptionHandler = option('exceptionHandler');\n            \n            if(option('handleExceptions'))\n                try {\n                    func(envelope.data, envelope);\n                } catch (e) {\n                    if (exceptionHandler) exceptionHandler(e, envelope);\n                }\n            else\n                func(envelope.data, envelope);\n        }\n    }\n\n    this.publish = function (topicOrEnvelope, data) {\n        var envelope = topicOrEnvelope && topicOrEnvelope.topic\n            ? topicOrEnvelope\n            : { topic: topicOrEnvelope, data: data, sync: false };\n        return publish(envelope);\n    };\n\n    this.publishSync = function (topic, data) {\n        return publish({ topic: topic, data: data, sync: true });\n    };\n\n    this.subscribe = function (topic, func) {\n        if (typeof (topic) === \"string\")\n            return subscribers.add(topic, func);\n        else if (utils.isArray(topic))\n            return utils.map(topic, function(topicName) {\n                return subscribers.add(topicName, func);\n            });\n        else\n            return utils.map(topic, function (individualFunc, topicName) {\n                return subscribers.add(topicName, individualFunc);\n            });\n    };\n\n    this.unsubscribe = function (tokens) {\n        if (Tribe.PubSub.utils.isArray(tokens)) {\n            var results = [];\n            for (var i = 0, l = tokens.length; i < l; i++)\n                results.push(subscribers.remove(tokens[i]));\n            return results;\n        }\n\n        return subscribers.remove(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self);\n    };\n    \n    function option(name) {\n        return (options && options.hasOwnProperty(name)) ? options[name] : Tribe.PubSub.options[name];\n    }\n};\n\n//@ sourceURL=tribe://Tribe.PubSub/PubSub.js");
window.eval("Tribe.PubSub.Lifetime = function (parent, owner) {\n    var self = this;\n    var tokens = [];\n\n    this.owner = owner;\n\n    this.publish = function(topicOrEnvelope, data) {\n        return parent.publish(topicOrEnvelope, data);\n    };\n\n    this.publishSync = function(topic, data) {\n        return parent.publishSync(topic, data);\n    };\n\n    this.subscribe = function(topic, func) {\n        var token = parent.subscribe(topic, func);\n        return recordToken(token);\n    };\n\n    this.subscribeOnce = function(topic, func) {\n        var token = parent.subscribeOnce(topic, func);\n        return recordToken(token);\n    };\n    \n    this.unsubscribe = function(token) {\n        // we should really remove the token(s) from our token list, but it has trivial impact if we don't\n        return parent.unsubscribe(token);\n    };\n\n    this.end = function() {\n        return parent.unsubscribe(tokens);\n    };\n\n    this.createLifetime = function() {\n        return new Tribe.PubSub.Lifetime(self, self.owner);\n    };\n    \n    function recordToken(token) {\n        if (Tribe.PubSub.utils.isArray(token))\n            tokens = tokens.concat(token);\n        else\n            tokens.push(token);\n        return token;\n    }\n};\n//@ sourceURL=tribe://Tribe.PubSub/Lifetime.js");
window.eval("window.Tribe.PubSub.options = {\n    sync: false,\n    handleExceptions: true,\n    exceptionHandler: function(e, envelope) {\n        console.log(\"Exception occurred in subscriber to '\" + envelope.topic + \"': \" + e.message);\n    }\n};\n//@ sourceURL=tribe://Tribe.PubSub/options.js");
window.eval("Tribe.PubSub.Saga = function (pubsub, definition, args) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n\n    pubsub = pubsub.createLifetime();\n    this.pubsub = pubsub;\n    this.children = [];\n\n    if (definition.constructor === Function) {\n        var definitionArgs = [self].concat(Array.prototype.slice.call(arguments, 2));\n        definition = utils.applyToConstructor(definition, definitionArgs);\n    }\n    var handlers = definition.handles || {};\n\n    this.start = function (data) {\n        utils.each(handlers, attachHandler);\n        if (handlers.onstart) handlers.onstart(data, self);\n        return self;\n    };\n\n    this.startChild = function (child, data) {\n        self.children.push(new Tribe.PubSub.Saga(pubsub, child).start(data));\n    };\n\n    this.end = function (data) {\n        if (handlers.onend) handlers.onend(data, self);\n        pubsub.end();\n        endChildren(data);\n    };\n\n    function attachHandler(handler, topic) {\n        if (topic !== 'onstart' && topic !== 'onend')\n            if (!handler)\n                pubsub.subscribe(topic, endHandler());\n            else if (handler.constructor === Function)\n                pubsub.subscribe(topic, messageHandlerFor(handler));\n            else\n                pubsub.subscribe(topic, childHandlerFor(handler));\n    }\n\n    function messageHandlerFor(handler) {\n        return function (messageData, envelope) {\n            if (!definition.endsChildrenExplicitly)\n                endChildren(messageData);\n            handler(messageData, envelope, self);\n        };\n    }\n\n    function childHandlerFor(childHandlers) {\n        return function (messageData, envelope) {\n            self.startChild({ handles: childHandlers }, messageData);\n        };\n    }\n\n    function endHandler() {\n        return function (messageData) {\n            self.end(messageData);\n        };\n    }\n\n    function endChildren(data) {\n        Tribe.PubSub.utils.each(self.children, function(child) {\n             child.end(data);\n        });\n    }    \n};\n\nTribe.PubSub.Saga.startSaga = function (definition, args) {\n    var constructorArgs = [this, definition].concat(Array.prototype.slice.call(arguments, 1));\n    var saga = Tribe.PubSub.utils.applyToConstructor(Tribe.PubSub.Saga, constructorArgs);\n    return saga.start();\n};\n\n\nTribe.PubSub.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\nTribe.PubSub.Lifetime.prototype.startSaga = Tribe.PubSub.Saga.startSaga;\n//@ sourceURL=tribe://Tribe.PubSub/Saga.js");
window.eval("Tribe.PubSub.prototype.subscribeOnce = function (topic, handler) {\n    var self = this;\n    var utils = Tribe.PubSub.utils;\n    var lifetime = this.createLifetime();\n\n    if (typeof (topic) === \"string\")\n        return lifetime.subscribe(topic, wrapHandler(handler));\n    else if (utils.isArray(topic))\n        return lifetime.subscribe(wrapTopicArray());\n    else\n        return lifetime.subscribe(wrapTopicObject());\n\n    function wrapTopicArray() {\n        var result = {};\n        utils.each(topic, function(topicName) {\n            result[topicName] = wrapHandler(handler);\n        });\n        return result;\n    }\n    \n    function wrapTopicObject() {\n        return utils.map(topic, function (func, topicName) {\n            return lifetime.subscribe(topicName, wrapHandler(func));\n        });\n    }\n\n    function wrapHandler(func) {\n        return function() {\n            lifetime.end();\n            func.apply(self, arguments);\n        };\n    }\n};\n//@ sourceURL=tribe://Tribe.PubSub/subscribeOnce.js");
window.eval("Tribe.PubSub.SubscriberList = function() {\n    var subscribers = {};\n    var lastUid = -1;\n\n    this.get = function (publishedTopic) {\n        var matching = [];\n        for (var registeredTopic in subscribers)\n            if (subscribers.hasOwnProperty(registeredTopic) && topicMatches(publishedTopic, registeredTopic))\n                matching = matching.concat(subscribers[registeredTopic]);\n        return matching;\n    };\n\n    this.add = function (topic, handler) {\n        var token = (++lastUid).toString();\n        if (!subscribers.hasOwnProperty(topic))\n            subscribers[topic] = [];\n        subscribers[topic].push({ topic: topic, handler: handler, token: token });\n        return token;\n    };\n\n    this.remove = function(token) {\n        for (var m in subscribers)\n            if (subscribers.hasOwnProperty(m))\n                for (var i = 0, l = subscribers[m].length; i < l; i++)\n                    if (subscribers[m][i].token === token) {\n                        subscribers[m].splice(i, 1);\n                        return token;\n                    }\n\n        return false;\n    };\n\n    function topicMatches(published, subscriber) {\n        if (subscriber === '*')\n            return true;\n        \n        var expression = \"^\" + subscriber\n            .replace(/\\./g, \"\\\\.\")\n            .replace(/\\*/g, \"[^\\.]*\") + \"$\";\n        return published.match(expression);\n    }\n};\n//@ sourceURL=tribe://Tribe.PubSub/SubscriberList.js");
window.eval("Tribe.PubSub.utils = {};\n(function(utils) {\n    utils.isArray = function (source) {\n        return source.constructor === Array;\n    };\n\n    utils.applyToConstructor = function(constructor, argArray) {\n        var args = [null].concat(argArray);\n        var factoryFunction = constructor.bind.apply(constructor, args);\n        return new factoryFunction();\n    };\n\n\n    // The following functions are taken from the underscore library, duplicated to avoid dependency. Licensing at http://underscorejs.org.\n    var nativeForEach = Array.prototype.forEach;\n    var nativeMap = Array.prototype.map;\n    var breaker = {};\n\n    utils.each = function (obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker) return;\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) return;\n                }\n            }\n        }\n    };\n\n    utils.map = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        utils.each(obj, function (value, index, list) {\n            results[results.length] = iterator.call(context, value, index, list);\n        });\n        return results;\n    };\n})(Tribe.PubSub.utils);\n\n//@ sourceURL=tribe://Tribe.PubSub/utils.js");
window.eval("(function (global) {\n    if (!jQuery)\n        throw 'jQuery must be loaded before knockout.composite can initialise';\n    if (!ko)\n        throw 'knockout.js must be loaded before knockout.composite can initialise';\n\n    global.Tribe = global.Tribe || {};\n    global.Tribe.Composite = {};\n    global.TC = global.Tribe.Composite;\n    global.TC.Events = {};\n    global.TC.Factories = {};\n    global.TC.LoadHandlers = {};\n    global.TC.LoadStrategies = {};\n    global.TC.Loggers = {};\n    global.TC.Transitions = {};\n    global.TC.Types = {};\n    global.TC.Utils = {};\n    global.T = global.TC.Utils;\n\n    $(function() {\n        $('head').append('<style class=\"__tribe\">.__rendering { position: fixed; top: -10000px; left: -10000px; }</style>');\n    });\n})(window || this);\n\n//@ sourceURL=tribe://Tribe.Composite/setup.js");
window.eval("TC.defaultOptions = function() {\n    return {\n        synchronous: false,\n        handleExceptions: true,\n        basePath: '',\n        loadStrategy: 'adhoc',\n        events: ['loadResources', 'createPubSub', 'createModel', 'initialiseModel', 'renderPane', 'renderComplete', 'active', 'dispose']\n    };\n};\nTC.options = TC.defaultOptions();\n//@ sourceURL=tribe://Tribe.Composite/options.js");
window.eval("(function () {\n    ko.bindingHandlers.cssClass = {\n        update: function (element, valueAccessor) {\n            var value = valueAccessor();\n            if (value)\n                $(element).addClass(ko.utils.unwrapObservable(value));\n        }\n    };\n\n    ko.bindingHandlers.enterPressed = keyPressedBindingHandler(13);\n    ko.bindingHandlers.escapePressed = keyPressedBindingHandler(27);\n    \n    function keyPressedBindingHandler(which) {\n        return {\n            init: function (element, valueAccessor) {\n                var $element = $(element);\n                var callback = valueAccessor();\n                if ($.isFunction(callback))\n                    $element.keyup(testKey);\n\n                function testKey(event) {\n                    if (event.which === which) {\n                        //$element.blur();\n                        callback($element.val());\n                    }\n                }\n            }\n        };\n    }\n\n})();\n//@ sourceURL=tribe://Tribe.Composite/Utilities/bindingHandlers.js");
window.eval("(function (utils) {    \n    utils.each = function (collection, iterator) {\n        return $.each(collection || [], function (index, value) {\n            return iterator(value, index);\n        });\n    };\n\n    // jQuery map flattens returned arrays - we don't want this for grids\n    utils.map = function (collection, iterator) {\n        var result = [];\n        utils.each(collection || [], function(value, index) {\n            result.push(iterator(value, index));\n        });\n        return result;\n    };\n\n    utils.filter = function(array, iterator) {\n        var result = [];\n        $.each(array || [], function(index, value) {\n            if (iterator(value, index))\n                result.push(value);\n        });\n        return result;\n    };\n\n    utils.pluck = function(array, property) {\n        return utils.map(array, function(value) {\n            return value && value[property];\n        });\n    };\n\n    utils.reduce = function (array, initialValue, reduceFunction) {\n        utils.each(array, function(value, index) {\n            initialValue = reduceFunction(initialValue, value, index, array);\n        });\n        return initialValue;\n    };\n})(TC.Utils);\n//@ sourceURL=tribe://Tribe.Composite/Utilities/collections.js");
window.eval("(function() {\n    TC.Utils.embedState = function (model, context, node) {\n        embedProperty(model, 'context', context);\n        embedProperty(model, 'node', node);\n    };\n\n    TC.Utils.contextFor = function (element) {\n        return element && TC.Utils.extractContext(ko.contextFor($(element)[0]));\n    };\n\n    TC.Utils.extractContext = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'context');\n    };\n\n    TC.Utils.extractNode = function (koBindingContext) {\n        return koBindingContext && embeddedProperty(koBindingContext.$root, 'node');\n    };\n\n    function embedProperty(target, key, value) {\n        if (!target)\n            throw \"Can't embed property in falsy value\";\n        target['__' + key] = value;\n    }\n\n    function embeddedProperty(target, key) {\n        return target && target['__' + key];\n    }\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/embeddedContext.js");
window.eval("(function () {\n    TC.Utils.elementDestroyed = function (element) {\n        if (element.constructor === jQuery)\n            element = element[0];\n\n        var promise = $.Deferred();\n\n        // Resolve when an element is removed using jQuery. This is a fallback for browsers not supporting DOMNodeRemoved and also executes synchronously.\n        $(element).on('destroyed', resolve);\n\n        // Resolve using the DOMNodeRemoved event. Not all browsers support this.\n        $(document).on(\"DOMNodeRemoved\", matchElement);\n\n        function matchElement(event) {\n            if (event.target === element)\n                resolve();\n        }\n\n        function resolve() {\n            $(element).off('destroyed', resolve);\n            $(document).off('DOMNodeRemoved', matchElement);\n            promise.resolve();\n        }\n\n        return promise;\n    };\n\n    TC.Utils.raiseDocumentEvent = function (name, data) {\n        var event = document.createEvent(\"Event\");\n        event.initEvent(name, true, false);\n        event.data = data;\n        document.dispatchEvent(event);\n    };\n\n    TC.Utils.handleDocumentEvent = function (name, handler) {\n        document.addEventListener(name, internalHandler);\n\n        return {\n            dispose: dispose\n        };\n\n        function internalHandler(e) {\n            handler(e.data, e);\n        }\n\n        function dispose() {\n            document.removeEventListener(name, internalHandler);\n        }\n    };    \n})();\n//@ sourceURL=tribe://Tribe.Composite/Utilities/events.js");
window.eval("TC.Utils.tryCatch = function(func, args, handleExceptions, message) {\n    if (handleExceptions)\n        try {\n            func.apply(func, args);\n        } catch (ex) {\n            TC.logger.error(message, ex);\n        }\n    else\n        func.apply(func, args);\n};\n//@ sourceURL=tribe://Tribe.Composite/Utilities/exceptions.js");
window.eval("(function () {\n    TC.Utils.idGenerator = function () {\n        return {\n            next: (function () {\n                var id = 0;\n                return function () {\n                    if (arguments[0] == 0) {\n                        id = 1;\n                        return 0;\n                    } else\n                        return id++;\n                };\n            })()\n        };\n    };\n\n    var generator = TC.Utils.idGenerator();\n    TC.Utils.getUniqueId = function () {\n        return generator.next();\n    };\n})();\n//@ sourceURL=tribe://Tribe.Composite/Utilities/idGenerator.js");
window.eval("(function ($) {\n    $.complete = function (deferreds) {\n        var wrappers = [];\n        var deferred = $.Deferred();\n        var resolve = false;\n\n        if ($.isArray(deferreds))\n            $.each(deferreds, wrapDeferred);\n        else\n            wrapDeferred(0, deferreds);\n\n        $.when.apply($, wrappers).done(function() {\n            resolve ?\n                deferred.resolve() :\n                deferred.reject();\n        });\n\n        return deferred;\n\n        function wrapDeferred(index, original) {\n            wrappers.push($.Deferred(function (thisDeferred) {\n                $.when(original)\n                    .done(function() {\n                        resolve = true;\n                    })\n                    .always(function () {\n                        thisDeferred.resolve();\n                    });\n            }));\n        }\n    };\n})(jQuery);\n//@ sourceURL=tribe://Tribe.Composite/Utilities/jquery.complete.js");
window.eval("(function ($) {\n    var oldClean = jQuery.cleanData;\n\n    // knockout also calls cleanData from it's cleanNode method - avoid any loops\n    //var cleaning = {};\n\n    $.cleanData = function (elements) {\n        for (var i = 0, element; (element = elements[i]) !== undefined; i++) {\n            //if (!cleaning[element]) {\n                //cleaning[element] = true;\n                $(element).triggerHandler(\"destroyed\");\n                //delete cleaning[element];\n            //}\n        }\n        oldClean(elements);\n    };\n})(jQuery);\n//@ sourceURL=tribe://Tribe.Composite/Utilities/jquery.destroyed.js");
window.eval("TC.Utils.cleanElement = function (element) {\n    // prevent knockout from calling cleanData \n    // - calls to this function ultimately result from cleanData being called by jQuery, so a loop will occur\n    var func = $.cleanData;\n    $.cleanData = undefined;\n    ko.cleanNode(element);\n    $.cleanData = func;\n};\n//@ sourceURL=tribe://Tribe.Composite/Utilities/knockout.js");
window.eval("TC.Utils.arguments = function (args) {\n    var byConstructor = {};\n    $.each(args, function (index, arg) {\n        byConstructor[arg.constructor] = arg;\n    });\n\n    return {\n        byConstructor: function (constructor) {\n            return byConstructor(constructor);\n        },\n        object: byConstructor[Object],\n        string: byConstructor[String],\n        'function': byConstructor[Function],\n        array: byConstructor[Array],\n        number: byConstructor[Number]\n    };\n};\n\nTC.Utils.removeItem = function (array, item) {\n    var index = $.inArray(item, array);\n    if (index > -1)\n        array.splice(index, 1);\n};\n\nTC.Utils.inheritOptions = function (from, to, options) {\n    for (var i = 0, l = options.length; i < l; i++)\n        to[options[i]] = from[options[i]];\n    return to;\n};\n\nTC.Utils.cloneData = function (from, except) {\n    if (!from) return;\n    var result = {};\n    for (var property in from) {\n        var value = from[property];\n        if (from.hasOwnProperty(property) &&\n            (!except || Array.prototype.indexOf.call(arguments, property) === -1) &&\n            (!value || (value.constructor !== Function || ko.isObservable(value))))\n\n            result[property] = ko.utils.unwrapObservable(value);\n    }\n    return result;\n};\n\nTC.Utils.normaliseBindings = function (valueAccessor, allBindingsAccessor) {\n    var data = allBindingsAccessor();\n    data.value = valueAccessor();\n    if (!ko.isObservable(data.value) && $.isFunction(data.value))\n        data.value = data.value();\n    return data;\n};\n\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/objects.js");
window.eval("(function () {\n    var utils = TC.Utils;\n\n    utils.getPaneOptions = function(value, otherOptions) {\n        var options = value.constructor === String ? { path: value } : value;\n        return $.extend({}, otherOptions, options);\n    };\n\n    utils.bindPane = function (node, element, paneOptions, context) {\n        context = context || utils.contextFor(element) || TC.context();\n        var pane = new TC.Types.Pane($.extend({ element: $(element)[0] }, paneOptions));\n        node.setPane(pane);\n\n        context.renderOperation.add(pane);\n\n        var pipeline = new TC.Types.Pipeline(TC.Events, context);\n        pipeline.execute(context.options.events, pane);\n\n        return pane;\n    };\n\n    utils.insertPaneAfter = function (node, target, paneOptions, context) {\n        var element = $('<div/>').insertAfter(target);\n        return utils.bindPane(node, element, paneOptions, context);\n    };\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/panes.js");
window.eval("(function() {\n    TC.Path = Path;\n\n    function Path(path) {\n        path = path ? normalise(path.toString()) : '';\n        var filenameIndex = path.lastIndexOf(\"/\") + 1;\n        var extensionIndex = path.lastIndexOf(\".\");\n\n        return {\n            withoutFilename: function() {\n                return Path(path.substring(0, filenameIndex));\n            },\n            filename: function() {\n                return Path(path.substring(filenameIndex));\n            },\n            extension: function() {\n                return extensionIndex === -1 ? '' : path.substring(extensionIndex + 1);\n            },\n            withoutExtension: function() {\n                return Path(extensionIndex === -1 ? path : path.substring(0, extensionIndex));\n            },\n            combine: function (additionalPath) {\n                return Path((path ? path + '/' : '') + additionalPath.toString());\n            },\n            isAbsolute: function() {\n                return path.charAt(0) === '/' ||\n                    path.indexOf('://') > -1;\n            },\n            makeAbsolute: function() {\n                return Path('/' + path);\n            },\n            makeRelative: function() {\n                return Path(path[0] === '/' ? path.substring(1) : path);\n            },\n            asMarkupIdentifier: function() {\n                return this.withoutExtension().toString().replace(/\\//g, '-').replace(/\\./g, '');\n            },\n            setExtension: function(extension) {\n                return Path(this.withoutExtension() + '.' + extension);\n            },\n            toString: function() {\n                return path.toString();\n            }\n        };\n\n        function normalise(input) {\n            input = removeDoubleSlashes(input);\n            input = removeParentPaths(input);\n            input = removeCurrentPaths(input);\n\n            return input;\n        }\n\n        function removeDoubleSlashes(input) {\n            var prefixEnd = input.indexOf('://') > -1 ? input.indexOf('://') + 3 : 0;\n            var prefix = input.substring(0, prefixEnd);\n            var inputPath = input.substring(prefixEnd);\n            return prefix + inputPath.replace(/\\/{2,}/g, '/');\n        }\n\n        function removeParentPaths(input) {\n            var regex = /[^\\/\\.]+\\/\\.\\.\\//;\n\n            while (input.match(regex))\n                input = input.replace(regex, '');\n\n            return input;\n        }\n\n        function removeCurrentPaths(input) {\n            var regex = /\\.\\//g;\n            // Ignore leading parent paths - the rest will have been stripped\n            // I can't figure out a regex that won't strip the ./ out of ../\n            var startIndex = input.lastIndexOf('../');\n            startIndex = startIndex == -1 ? 0 : startIndex + 3;\n            return input.substring(0, startIndex) + input.substring(startIndex).replace(regex, '');\n        }\n    };\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/Path.js");
window.eval("(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-parse.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    TC.Utils.Querystring = TC.Utils.Querystring || {};\n\n    TC.Utils.Querystring.parse = function (source, seperator, eqSymbol) {\n        stripLeadIn();\n        \n        return TC.Utils.reduce(\n            TC.Utils.map(\n                source.split(seperator || \"&\"),\n                pieceParser(eqSymbol || \"=\")\n            ),\n            {},\n            mergeParams\n        );\n\n        function stripLeadIn() {\n            if(source.length > 0 && source[0] === '?')\n                source = source.substring(1);\n        }\n    };\n    \n    function unescape(s) {\n        return decodeURIComponent(s.replace(/\\+/g, ' '));\n    };\n\n    function pieceParser(eq) {\n        return function parsePiece(key, val) {\n\n            var sliced, numVal, head, tail, ret;\n\n            if (arguments.length === 2) {\n                // key=val, called from the map/reduce\n                key = key.split(eq);\n                return parsePiece(\n                    unescape(key.shift()),\n                    unescape(key.join(eq)),\n                    true\n                );\n            }\n            \n            key = key.replace(/^\\s+|\\s+$/g, '');\n            if (val.constructor === String) {\n                val = val.replace(/^\\s+|\\s+$/g, '');\n                // convert numerals to numbers\n                if (!isNaN(val)) {\n                    numVal = +val;\n                    if (val === numVal.toString(10)) {\n                        val = numVal;\n                    }\n                }\n            }\n            \n            sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n            if (!sliced) {\n                ret = {};\n                if (key)\n                    ret[key] = val;\n                return ret;\n            }\n            \n            // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n            tail = sliced[2];\n            head = sliced[1];\n\n            // array: key[]=val\n            if (!tail)\n                return parsePiece(head, [val], true);\n\n            // object: key[subkey]=val\n            ret = {};\n            ret[tail] = val;\n            return parsePiece(head, ret, true);\n        };\n    }\n\n    // the reducer function that merges each query piece together into one set of params\n    function mergeParams(params, addition) {\n        return (\n            // if it's uncontested, then just return the addition.\n            (!params) ? addition\n            // if the existing value is an array, then concat it.\n            : ($.isArray(params)) ? params.concat(addition)\n            // if the existing value is not an array, and either are not objects, arrayify it.\n            : (!$.isPlainObject(params) || !$.isPlainObject(addition)) ? [params].concat(addition)\n            // else merge them as objects, which is a little more complex\n            : mergeObjects(params, addition)\n        );\n    }\n\n    // Merge two *objects* together. If this is called, we've already ruled\n    // out the simple cases, and need to do the for-in business.\n    function mergeObjects(params, addition) {\n        for (var i in addition)\n            if (i && addition.hasOwnProperty(i))\n                params[i] = mergeParams(params[i], addition[i]);\n\n        return params;\n    }\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/querystring.parse.js");
window.eval("(function () {\n    // This is a modified version of modules from the YUI Library - \n    // http://yuilibrary.com/yui/docs/api/files/querystring_js_querystring-stringify.js.html\n    // Either it should be rewritten or attribution and licensing be available here and on the website like in http://yuilibrary.com/license/\n\n    TC.Utils.Querystring = TC.Utils.Querystring || {};\n\n    var escape = encodeURIComponent;\n\n    TC.Utils.Querystring.stringify = function (source, options) {\n        return stringify(source, options);\n    };\n\n    function stringify(source, options, name, stack) {\n        options = options || {};\n        stack = stack || [];\n        var begin, end, i, l, n, s;\n        var sep = options.seperator || \"&\";\n        var eq = options.eqSymbol || \"=\";\n        var arrayKey = options.arrayKey !== false;\n\n        if (source === null || source === undefined || source.constructor === Function)\n            return name ? escape(name) + eq : '';\n\n        if (source.constructor === Boolean || Object.prototype.toString.call(source) === '[object Boolean]')\n            source = +source;\n\n        if (!isNaN(source) || source.constructor === String)\n            return escape(name) + eq + escape(source);\n\n        if ($.isArray(source)) {\n            s = [];\n            name = arrayKey ? name + '[]' : name;\n            for (i = 0, l = source.length; i < l; i++) {\n                s.push(stringify(source[i], options, name, stack));\n            }\n\n            return s.join(sep);\n        }\n        \n        // now we know it's an object.\n        // Check for cyclical references in nested objects\n        for (i = stack.length - 1; i >= 0; --i)\n            if (stack[i] === source)\n                throw new Error(\"TC.Utils.Querystring.stringify: cyclical reference\");\n\n        stack.push(source);\n        s = [];\n        begin = name ? name + '[' : '';\n        end = name ? ']' : '';\n        for (i in source) {\n            if (source.hasOwnProperty(i)) {\n                n = begin + i + end;\n                s.push(stringify(source[i], options, n, stack));\n            }\n        }\n\n        stack.pop();\n        s = s.join(sep);\n        if (!s && name)\n            return name + \"=\";\n\n        return s;\n    };\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Utilities/querystring.stringify.js");
window.eval("(function () {\n    TC.Types.Flow = function (navigationSource, definition, args) {\n        var self = this;\n\n        this.node = navigationNode();\n        this.pubsub = this.node.pane.pubsub.owner;\n        this.sagas = [];\n\n        definition = createDefinition(self, definition, Array.prototype.slice.call(arguments, 2));\n        this.saga = new Tribe.PubSub.Saga(this.pubsub, definition);\n\n        this.start = function(data) {\n            self.saga.start(data);\n            return self;\n        };\n\n        this.end = function(data) {\n            self.saga.end(data);\n            TC.Utils.each(self.sagas, function(saga) {\n                saga.end(data);\n            });\n            return self;\n        };\n\n        function navigationNode() {\n            if (navigationSource.constructor === TC.Types.Node)\n                return navigationSource.findNavigation().node;\n            if (navigationSource.constructor === TC.Types.Pane)\n                return navigationSource.node.findNavigation().node;\n            throw new Error(\"navigationSource must be either TC.Types.Pane or TC.Types.Node\");\n        }\n    };\n\n    TC.Types.Flow.prototype.startChild = function(definition, args) {\n        definition = createDefinition(this, definition, Array.prototype.slice.call(arguments, 1));\n        this.saga.startChild(definition);\n    };\n\n    TC.Types.Flow.prototype.navigate = function (pathOrOptions, data) {\n        this.node.navigate(pathOrOptions, data);\n    };\n\n    TC.Types.Flow.prototype.to = function (pathOrOptions, data) {\n        var node = this.node;\n        return function () {\n            node.navigate(pathOrOptions, data);\n        };\n    };\n\n    TC.Types.Flow.prototype.endsAt = function (pathOrOptions, data) {\n        var flow = this;\n        return function () {\n            flow.node.navigate(pathOrOptions, data);\n            flow.end();\n        };\n    };\n\n    TC.Types.Flow.prototype.start = function(flow, args) {\n        var thisFlow = this;\n        var childArguments = arguments;\n        return function() {\n            thisFlow.startChild.apply(thisFlow, childArguments);\n        };\n    };\n\n    // This keeps a separate collection of sagas bound to this flow's lifetime\n    // It would be nice to make them children of the underlying saga, but\n    // then they would end any time a message was executed.\n    TC.Types.Flow.prototype.startSaga = function (definition, args) {\n        var saga = this.pubsub.startSaga.apply(this.pubsub, arguments);\n        this.sagas.push(saga);\n        return saga;\n    };\n\n    // This is reused by Node and Pane\n    TC.Types.Flow.startFlow = function (definition, args) {\n        var constructorArgs = [this, definition].concat(Array.prototype.slice.call(arguments, 1));\n        var flow = Tribe.PubSub.utils.applyToConstructor(TC.Types.Flow, constructorArgs);\n        return flow.start();\n    };\n    \n    function createDefinition(flow, definition, argsToApply) {\n        if (definition.constructor === Function) {\n            var definitionArgs = [flow].concat(argsToApply);\n            definition = Tribe.PubSub.utils.applyToConstructor(definition, definitionArgs);\n        }\n        return definition;\n    }\n})();\n//@ sourceURL=tribe://Tribe.Composite/Types/Flow.js");
window.eval("TC.Types.History = function (history) {\n    var currentState = 0;\n    history.replaceState(currentState, window.title);\n\n    var popActions = {\n        raiseEvent: function (e) {\n            TC.Utils.raiseDocumentEvent('browser.go', { count: (e.state - currentState) });\n            currentState = e.state;\n        },\n        updateStack: function(e) {\n            currentState = e.state;\n            currentAction = popActions.raiseEvent;\n        }\n    };\n    var currentAction = popActions.raiseEvent;\n\n    window.addEventListener('popstate', executeCurrentAction);\n\n    function executeCurrentAction(e) {\n        if (e.state !== null) currentAction(e);\n    }\n\n    this.navigate = function (urlOptions) {\n        urlOptions = urlOptions || {};\n        history.pushState(++currentState, urlOptions.title, urlOptions.url);\n    };\n\n    this.go = function(frameCount) {\n        history.go(frameCount);\n    };\n\n    this.update = function(frameCount) {\n        currentAction = popActions.updateStack;\n        history.go(frameCount);\n    };\n\n    this.dispose = function () {\n        window.removeEventListener('popstate', executeCurrentAction);\n    };\n};\n\nif (window.history.pushState)\n    TC.history = new TC.Types.History(window.history);\nelse\n    TC.history = new TC.Types.History({\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { }\n    });\n//@ sourceURL=tribe://Tribe.Composite/Types/History.js");
window.eval("TC.Types.Loader = function () {\n    var self = this;\n    var resources = {};\n\n    this.get = function(url, resourcePath, context) {\n        if (resources[url] !== undefined)\n            return resources[url];\n\n        var extension = TC.Path(url).extension().toString();\n        var handler = TC.LoadHandlers[extension];\n\n        if (handler) {\n            var result = handler(url, resourcePath, context);\n            resources[url] = result;\n            \n            $.when(result).always(function() {\n                resources[url] = null;\n            });\n            \n            return result;\n        }\n\n        TC.logger.warn(\"Resource of type \" + extension + \" but no handler registered.\");\n        return null;\n    };\n};\n\n//@ sourceURL=tribe://Tribe.Composite/Types/Loader.js");
window.eval("TC.Types.Logger = function () {\n    var logLevel = 0;\n    var logger = 'console';\n\n    var levels = {\n        0: 'debug',\n        1: 'info',\n        2: 'warn',\n        3: 'error',\n        4: 'none'\n    };\n\n    this.debug = function (message) {\n        log(0, message);\n    };\n\n    this.info = function (message) {\n        log(1, message);\n    };\n\n    this.warn = function (message) {\n        log(2, message);\n    };\n\n    this.error = function (message, error) {\n        var logString;\n        if (error && error.stack)\n            logString = message + ' ' + error.stack;\n        else if (error && error.message)\n            logString = message + ' ' + error.message;\n        else\n            logString = message + ' ' + (error ? error : '');\n\n        log(3, logString);\n    };\n\n    function log(level, message) {\n        if(logLevel <= level)\n            TC.Loggers[logger](levels[level], message);\n    };\n\n    this.setLogLevel = function (level) {\n        $.each(levels, function(value, text) {\n            if (level === text)\n                logLevel = value;\n        });\n    };\n\n    this.setLogger = function(newLogger) {\n        logger = newLogger;\n    };\n};\n\nTC.logger = new TC.Types.Logger();\n//@ sourceURL=tribe://Tribe.Composite/Types/Logger.js");
window.eval("TC.Types.Models = function () { };\n\nTC.Types.Models.prototype.register = function (resourcePath, constructor, options) {\n    this[resourcePath] = {\n        constructor: constructor,\n        options: options || {}\n    };\n    TC.logger.debug(\"Model loaded for \" + resourcePath);\n};\n//@ sourceURL=tribe://Tribe.Composite/Types/Models.js");
window.eval("TC.Types.Navigation = function (node, options) {\n    normaliseOptions();\n    setInitialPaneState();\n\n    var stack = [initialStackItem()];\n    var currentFrame = 0;\n\n    this.node = node;\n    this.stack = stack;\n\n    this.navigate = function (paneOptions) {\n        if (options.browser)\n            TC.history.navigate(options.browser && options.browser.urlDataFrom(paneOptions));\n\n        trimStack();\n        stack.push(paneOptions);\n        currentFrame++;\n\n        navigateTo(paneOptions);\n    };\n\n    this.isAtStart = function() {\n        return currentFrame === 0;\n    };\n\n    this.go = function(frameCount) {\n        go(frameCount);\n        if (options.browser) TC.history.update(frameCount);\n    };\n    \n    if(options.browser) document.addEventListener('browser.go', onBrowserGo);\n    function onBrowserGo(e) {\n        go(e.data.count);\n    }\n\n    function go(frameCount) {\n        var newFrame = currentFrame + frameCount;\n        if (newFrame < 0) newFrame = 0;\n        if (newFrame >= stack.length) newFrame = stack.length - 1;\n\n        if (newFrame != currentFrame)\n            navigateTo(stack[newFrame], frameCount < 0);\n\n        currentFrame = newFrame;\n    }\n\n    function navigateTo(paneOptions, reverse) {\n        TC.Utils.raiseDocumentEvent('navigating', { node: node, options: paneOptions, browserData: options.browserData });\n        node.transitionTo(paneOptions, options.transition, reverse);\n    }\n\n    function trimStack() {\n        stack.splice(currentFrame + 1, stack.length);\n    }\n\n    this.dispose = function() {\n        document.removeEventListener('browser.go', onBrowserGo);\n    };\n    \n    function normaliseOptions() {\n        options = options || {};\n        if (options.constructor === String)\n            options = { transition: options };\n        if (options.browser === true)\n            options.browser = TC.options.defaultUrlProvider;\n    }\n    \n    function setInitialPaneState() {\n        var urlState = options.browser && options.browser.paneOptionsFrom(window.location.search);\n        if (urlState) {\n            node.pane.path = urlState.path;\n            node.pane.data = urlState.data;\n        }\n    }\n    \n    function initialStackItem() {\n        return { path: node.pane.path, data: node.pane.data };\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/Types/Navigation.js");
window.eval("TC.Types.Node = function (parent, pane) {\n    this.parent = parent;\n    this.children = [];\n    this.root = parent ? parent.root : this;\n    this.id = TC.Utils.getUniqueId();\n\n    if (parent) parent.children.push(this);\n    if (pane) this.setPane(pane);\n};\n\nTC.Types.Node.prototype.navigate = function (pathOrPane, data) {\n    var paneOptions = TC.Utils.getPaneOptions(pathOrPane, { data: data });\n    if (!TC.Path(paneOptions.path).isAbsolute())\n        // this is duplicated in Pane.inheritPathFrom - the concept (relative paths inherit existing paths) needs to be clearer\n        paneOptions.path = TC.Path(this.nodeForPath().pane.path).withoutFilename().combine(paneOptions.path).toString();\n    \n    this.findNavigation().navigate(paneOptions);\n};\n\nTC.Types.Node.prototype.navigateBack = function () {\n    this.findNavigation().go(-1);\n};\n\nTC.Types.Node.prototype.findNavigation = function() {\n    if (this.defaultNavigation)\n        return this.defaultNavigation;\n\n    else if (this.navigation)\n        return this.navigation;\n        \n    if (!this.parent) {\n        this.navigation = new TC.Types.Navigation(this);\n        return this.navigation;\n    }\n\n    return this.parent.findNavigation();\n};\n\nTC.Types.Node.prototype.transitionTo = function(paneOptions, transition, reverse) {\n    TC.transition(this, transition, reverse).to(paneOptions);\n};\n\nTC.Types.Node.prototype.setPane = function (pane) {\n    if (this.pane)\n        this.pane.node = null;\n\n    pane.node = this;\n    this.pane = pane;\n    this.skipPath = pane.skipPath;\n\n    if (pane.handlesNavigation) {\n        this.navigation = new TC.Types.Navigation(this, pane.handlesNavigation);\n        \n        // this sets this pane as the \"default\", accessible from panes outside the tree. First in best dressed.\n        this.root.defaultNavigation = this.root.defaultNavigation || this.navigation;\n    }\n\n    pane.inheritPathFrom(this.parent);\n};\n\nTC.Types.Node.prototype.nodeForPath = function() {\n    return this.skipPath && this.parent ? this.parent.nodeForPath() : this;\n};\n\nTC.Types.Node.prototype.dispose = function() {\n    if (this.root.defaultNavigation === this.navigation)\n        this.root.defaultNavigation = null;\n\n    if (this.parent)\n        TC.Utils.removeItem(this.parent.children, this);\n\n    if (this.pane && this.pane.dispose) {\n        delete this.pane.node;\n        this.pane.dispose();\n    }\n};\n\nTC.Types.Node.prototype.startFlow = TC.Types.Flow.startFlow;\n\n//@ sourceURL=tribe://Tribe.Composite/Types/Node.js");
window.eval("TC.Types.Operation = function () {\n    var self = this;\n    var incomplete = [];\n\n    this.promise = $.Deferred();\n\n    this.add = function(id) {\n        incomplete.push(id);\n    };\n\n    this.complete = function (id) {\n        TC.Utils.removeItem(incomplete, id);\n        if (incomplete.length === 0)\n            self.promise.resolve();\n    };\n    \n};\n//@ sourceURL=tribe://Tribe.Composite/Types/Operation.js");
window.eval("TC.Types.Pane = function (options) {\n    TC.Utils.inheritOptions(options, this, ['path', 'data', 'element', 'transition', 'reverseTransitionIn', 'handlesNavigation', 'pubsub', 'id', 'skipPath']);\n\n    // events we are interested in hooking in to - this could be done completely generically by the pipeline\n    this.is = {\n        rendered: $.Deferred(),\n        disposed: $.Deferred()\n    };    \n};\n\nTC.Types.Pane.prototype.navigate = function (pathOrPane, data) {\n    this.node && this.node.navigate(pathOrPane, data);\n};\n\nTC.Types.Pane.prototype.navigateBack = function () {\n    this.node && this.node.navigateBack();\n};\n\nTC.Types.Pane.prototype.remove = function () {\n    $(this.element).remove();\n};\n\nTC.Types.Pane.prototype.dispose = function () {\n    if (this.model && this.model.dispose)\n        this.model.dispose();\n\n    if (this.node) {\n        delete this.node.pane;\n        this.node.dispose();\n    }\n\n    if (this.element)\n        TC.Utils.cleanElement(this.element);\n};\n\nTC.Types.Pane.prototype.inheritPathFrom = function (node) {\n    node = node && node.nodeForPath();\n    var pane = node && node.pane;    \n    var path = TC.Path(this.path);\n    if (path.isAbsolute() || !pane)\n        this.path = path.makeAbsolute().toString();\n    else\n        this.path = TC.Path(pane.path).withoutFilename().combine(path).toString();\n};\n\nTC.Types.Pane.prototype.find = function(selector) {\n    return $(this.element).find(selector);\n};\n\nTC.Types.Pane.prototype.startRender = function () {\n    $(this.element).addClass('__rendering');\n};\n\nTC.Types.Pane.prototype.endRender = function () {\n    $(this.element).removeClass('__rendering');\n};\n\nTC.Types.Pane.prototype.toString = function () {\n    return \"{ path: '\" + this.path + \"' }\";\n};\n\nTC.Types.Pane.prototype.startFlow = TC.Types.Flow.startFlow;\n\n//@ sourceURL=tribe://Tribe.Composite/Types/Pane.js");
window.eval("TC.Types.Pipeline = function (events, context) {\n    this.execute = function (eventsToExecute, target) {\n        var currentEvent = -1;\n        var promise = $.Deferred();\n        executeNextEvent();\n\n        function executeNextEvent() {\n            currentEvent++;\n            if (currentEvent >= eventsToExecute.length) {\n                promise.resolve();\n                return;\n            }\n\n            var eventName = eventsToExecute[currentEvent];\n            var event = events[eventName];\n\n            if (!event) {\n                TC.logger.warn(\"No event defined for \" + eventName);\n                executeNextEvent();\n                return;\n            }\n\n            $.when(event(target, context))\n                .done(executeNextEvent)\n                .fail(handleFailure);\n\n            function handleFailure() {\n                promise.reject();\n                var targetDescription = target ? target.toString() : \"empty target\";\n                TC.logger.error(\"An error occurred in the '\" + eventName + \"' event for \" + targetDescription);\n            }\n        }\n\n        return promise;\n    };\n};\n//@ sourceURL=tribe://Tribe.Composite/Types/Pipeline.js");
window.eval("TC.Types.Templates = function () {\n    var self = this;\n\n    this.store = function (template, path) {\n        var id = TC.Path(path).asMarkupIdentifier().toString();\n        var $template = $(template);\n        if ($template.is(\"script\"))\n            $('head').append($template.filter('script'));\n        else\n            $('<script type=\"text/template\" class=\"__tribe\" id=\"template-' + id + '\"></script>').text(template).appendTo('head');\n    };\n\n    this.loaded = function(path) {\n        return $('head script#template-' + TC.Path(path).asMarkupIdentifier()).length > 0;\n    };\n\n    this.render = function (target, path) {\n        var id = TC.Path(path).asMarkupIdentifier();\n        // can't use html() to append - this uses the element innerHTML property and IE7 and 8 will strip comments (i.e. containerless control flow bindings)\n        $(target).empty().append($('head script#template-' + id).html());\n    };\n};\n//@ sourceURL=tribe://Tribe.Composite/Types/Templates.js");
window.eval("TC.Events.active = function (pane, context) {\n    return TC.Utils.elementDestroyed(pane.element);\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/active.js");
window.eval("TC.Events.createModel = function (pane, context) {\n    var definition = context.models[pane.path];\n    var model = definition && definition.constructor ?\n        new definition.constructor(pane) :\n        { pane: pane, data: pane.data };\n\n    TC.Utils.embedState(model, context, pane.node);\n\n    pane.model = model;\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/createModel.js");
window.eval("TC.Events.createPubSub = function (pane, context) {\n    if (context.pubsub)\n        pane.pubsub = context.pubsub.createLifetime ?\n            context.pubsub.createLifetime() :\n            context.pubsub;\n};\n\n//@ sourceURL=tribe://Tribe.Composite/Events/createPubSub.js");
window.eval("TC.Events.dispose = function (pane, context) {\n    pane.pubsub && pane.pubsub.end && pane.pubsub.end();\n    pane.dispose();\n    pane.is.disposed.resolve();\n};\n\n//@ sourceURL=tribe://Tribe.Composite/Events/dispose.js");
window.eval("TC.Events.initialiseModel = function (pane, context) {\n    if (pane.model.initialise)\n        return pane.model.initialise();\n    return null;\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/initialiseModel.js");
window.eval("TC.Events.loadResources = function (pane, context) {\n    var strategy = TC.LoadStrategies[context.options.loadStrategy];\n    \n    if (!strategy)\n        throw \"Unknown resource load strategy\";\n\n    return strategy(pane, context);\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/loadResources.js");
window.eval("TC.Events.renderComplete = function (pane, context) {\n    $.when(TC.transition(pane, pane.transition, pane.reverseTransitionIn).in()).done(executeRenderComplete);\n    setTimeout(function() {\n        pane.endRender();\n    });\n\n    function executeRenderComplete() {\n        if (pane.model.renderComplete)\n            pane.model.renderComplete();\n        pane.is.rendered.resolve();\n        TC.Utils.raiseDocumentEvent('renderComplete', pane);\n        context.renderOperation = new TC.Types.Operation();\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/renderComplete.js");
window.eval("TC.Events.renderPane = function (pane, context) {\n    var renderOperation = context.renderOperation;\n\n    pane.startRender();\n    context.templates.render(pane.element, pane.path);\n    TC.Utils.tryCatch(applyBindings, null, context.options.handleExceptions, 'An error occurred applying the bindings for ' + pane.toString());\n\n    if (pane.model.paneRendered)\n        pane.model.paneRendered();\n\n    renderOperation.complete(pane);\n    return renderOperation.promise;\n\n    function applyBindings() {\n        ko.applyBindingsToDescendants(pane.model, pane.element);\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/Events/renderPane.js");
window.eval("TC.LoadHandlers.js = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: executeScript\n    });\n\n    function executeScript(script) {\n        TC.scriptEnvironment = {\n            url: url,\n            resourcePath: resourcePath,\n            context: context\n        };\n\n        TC.Utils.tryCatch($.globalEval, [appendSourceUrl(script)], context.options.handleExceptions,\n            'An error occurred executing script loaded from ' + url + (resourcePath ? ' for resource ' + resourcePath : ''));\n\n        delete TC.scriptEnvironment;\n\n        TC.logger.debug('Loaded script from ' + url);\n    }\n\n    function appendSourceUrl(script) {\n        return script + '\\n//@ sourceURL=tribe://Application/' + url.replace(/ /g, \"_\");\n    }    \n};\n//@ sourceURL=tribe://Tribe.Composite/LoadHandlers/scripts.js");
window.eval("TC.LoadHandlers.css = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'text',\n        async: !context.options.synchronous,\n        cache: false,\n        success: renderStylesheet\n    });\n\n    function renderStylesheet(stylesheet) {\n        $('<style/>')\n            .attr('id', resourcePath ? 'style-' + TC.Path(resourcePath).asMarkupIdentifier() : null)\n            .attr('class', '__tribe')\n            .text(stylesheet)\n            .appendTo('head');\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/LoadHandlers/stylesheets.js");
window.eval("TC.LoadHandlers.htm = function (url, resourcePath, context) {\n    return $.ajax({\n        url: url,\n        dataType: 'html',\n        async: !context.options.synchronous,\n        cache: false,\n        success: storeTemplate\n    });\n\n    function storeTemplate(template) {\n        context.templates.store(template, resourcePath);\n    }\n};\nTC.LoadHandlers.html = TC.LoadHandlers.htm;\n\n//@ sourceURL=tribe://Tribe.Composite/LoadHandlers/templates.js");
window.eval("TC.LoadStrategies.adhoc = function (pane, context) {\n    if (context.loadedPanes[pane.path] !== undefined)\n        return context.loadedPanes[pane.path];\n\n    var path = TC.Path(context.options.basePath).combine(TC.Path(pane.path).makeRelative());\n\n    if (context.templates.loaded(pane.path) || context.models[pane.path])\n        return null;\n\n    var deferred = $.complete([\n        context.loader.get(path.setExtension('js').toString(), pane.path, context),\n        context.loader.get(path.setExtension('htm').toString(), pane.path, context),\n        context.loader.get(path.setExtension('css').toString(), pane.path, context)\n    ]);\n\n    context.loadedPanes[pane.path] = deferred;\n\n    $.when(deferred)\n        .fail(function() {\n            TC.logger.error(\"Unable to load resources for '\" + pane.path + \"'.\");\n        })\n        .always(function () {\n            context.loadedPanes[pane.path] = null;\n        });\n\n    return deferred;\n};\n//@ sourceURL=tribe://Tribe.Composite/LoadStrategies/adhoc.js");
window.eval("TC.LoadStrategies.preloaded = function (pane, context) {\n    if (!context.models[pane.path] && !context.templates.loaded(pane.path)) {\n        TC.logger.error(\"No resources loaded for '\" + pane.path + \"'.\");\n        return $.Deferred().reject();\n    }\n    return null;\n};\n//@ sourceURL=tribe://Tribe.Composite/LoadStrategies/preloaded.js");
window.eval("TC.transition = function (target, transition, reverse) {\n    var node;\n    var pane;\n    var element;\n    setState();\n    \n    transition = transition || (pane && pane.transition) || (node && node.transition);\n    var implementation = TC.Transitions[transition];\n    if (reverse && implementation && implementation.reverse)\n        implementation = TC.Transitions[implementation.reverse];\n\n    return {\n        in: function () {\n            $(element).show();\n            return implementation && implementation.in(element);\n        },\n        \n        out: function (remove) {\n            setTransitionMode();\n            \n            var promise = implementation && implementation.out(element);\n            $.when(promise).done(removeElement);\n            return promise;\n            \n            function removeElement() {\n                if (remove === false) {\n                    $(element).hide().attr('style', '');\n                } else\n                    $(element).remove();\n            }\n        },\n        \n        to: function (paneOptions, remove) {\n            var context = TC.context();\n            if (node)\n                TC.Utils.insertPaneAfter(node, element, TC.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), context);\n            else\n                TC.insertNodeAfter(element, TC.Utils.getPaneOptions(paneOptions, { transition: transition, reverseTransitionIn: reverse }), null, context);\n            this.out(remove);\n            return context.renderOperation.promise;\n        }\n    };\n    \n    function setTransitionMode() {\n        var $element = $(element);\n        if (TC.transition.mode === 'fixed')\n            $element.css({\n                position: 'fixed',\n                width: $element.width(),\n                left: $element.offset().left,\n                top: $element.offset().top\n            });\n        else\n            $element.css({\n                position: 'absolute',\n                width: $element.width(),\n                left: $element.position().left,\n                top: $element.position().top\n            });\n    }\n\n    function setState() {\n        if (!target) throw \"No target passed to TC.transition\";\n        \n        if (target.constructor === TC.Types.Node) {\n            node = target;\n            pane = node.pane;\n            element = pane.element;\n        } else if (target.constructor === TC.Types.Pane) {\n            pane = target;\n            node = pane.node;\n            element = pane.element;\n        } else {\n            element = target;\n        }\n    }    \n};\n//@ sourceURL=tribe://Tribe.Composite/Transitions/transition.js");
window.eval("(function () {\n    var supported = supportsTransitions();\n    \n    createCssTransition('fade');\n    createCssTransition('slideLeft', 'slideRight');\n    createCssTransition('slideRight', 'slideLeft');\n    createCssTransition('slideUp', 'slideDown');\n    createCssTransition('slideDown', 'slideUp');\n\n    var transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';\n\n    function createCssTransition(transition, reverse) {\n        TC.Transitions[transition] = {\n            in: function (element) {\n                if (!supported) return null;\n                \n                var promise = $.Deferred();\n                $(element).bind(transitionEndEvents, transitionEnded(element, promise))\n                    .addClass('prepare in ' + transition);\n\n                trigger(element);\n                return promise;\n            },\n\n            out: function (element) {\n                if (!supported) return null;\n                var promise = $.Deferred();\n\n                $(element).addClass('prepare out ' + transition)\n                    .on(transitionEndEvents, transitionEnded(element, promise, true));\n\n                trigger(element);\n                return promise;\n            },\n            reverse: reverse || transition\n        };\n\n        function trigger(element) {\n            setTimeout(function () {\n                $(element).addClass('trigger');\n            }, 30);\n        }\n\n        function transitionEnded(element, promise, hide) {\n            return function() {\n                $(element).unbind(transitionEndEvents)\n                    .removeClass(transition + ' in out prepare trigger');\n                if (hide) $(element).hide();\n                promise.resolve();\n            };\n        }\n    }\n    \n    function supportsTransitions() {\n        var b = document.body || document.documentElement;\n        var style = b.style;\n        var property = 'transition';\n        var vendors = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n        if (typeof style[property] == 'string') { return true; }\n\n        // Tests for vendor specific prop\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        for (var i = 0, l = vendors.length; i < l; i++) {\n            if (typeof style[vendors[i] + property] == 'string') { return true; }\n        }\n        \n        return false;\n    }\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Transitions/Css/css.js");
window.eval("$('<style/>')\n    .attr('class', '__tribe')\n    .text('.trigger{-webkit-transition:all 250ms ease-in-out;transition:all 250ms ease-in-out}.fade.in.prepare{opacity:0}.fade.in.trigger{opacity:1}.fade.out.prepare{opacity:1}.fade.out.trigger{opacity:0}.slideRight.in.prepare{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideRight.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideRight.out.trigger{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.prepare{-webkit-transform:translateX(100%);transform:translateX(100%)}.slideLeft.in.trigger{-webkit-transform:translateX(0);transform:translateX(0)}.slideLeft.out.trigger{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.slideDown.in.prepare{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.slideDown.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideDown.out.trigger{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.prepare{-webkit-transform:translateY(100%);transform:translateY(100%)}.slideUp.in.trigger{-webkit-transform:translateY(0);transform:translateY(0)}.slideUp.out.trigger{-webkit-transform:translateY(-100%);transform:translateY(-100%)}')\n    .appendTo('head');\n\n//@ sourceURL=tribe://Tribe.Composite/Transitions/Css/style.css.js");
window.eval("(function () {\n    TC.registerModel = function () {\n        var environment = TC.scriptEnvironment || {};\n        \n        var context = environment.context || TC.context();\n        var args = TC.Utils.arguments(arguments);\n        \n        var constructor = args.function;\n        var options = args.object;\n        var path = args.string || environment.resourcePath;\n        \n        context.models.register(path, constructor, options);\n    };\n\n    TC.run = function(preload, model) {\n        if (preload) {\n            var promises = [];\n            var context = TC.context();\n\n            if ($.isArray(preload))\n                for (var i = 0, l = preload.length; i < l; i++)\n                    addPromise(preload[i]);\n            else if(preload.constructor === String)\n                addPromise(preload);\n            \n            function addPromise(path) {\n                promises.push(context.loader.get(TC.Path(context.options.basePath).combine(path).toString(), null, context));\n            }\n\n            return $.when.apply(null, promises).done(function () {\n                ko.applyBindings(model);\n            });\n        } else\n            ko.applyBindings(model);\n    };\n})(); \n//@ sourceURL=tribe://Tribe.Composite/Api/api.js");
window.eval("(function () {\n    var staticState;\n\n    TC.context = function (source) {\n        staticState = staticState || {\n            models: new TC.Types.Models(),\n            loader: new TC.Types.Loader(),\n            options: TC.options,\n            templates: new TC.Types.Templates(),\n            loadedPanes: {},\n            pubsub: Tribe.PubSub && new Tribe.PubSub({ sync: TC.options.synchronous, handleExceptions: TC.options.handleExceptions })\n        };\n        var perContextState = {\n            renderOperation: new TC.Types.Operation()\n        };\n        return $.extend({}, staticState, perContextState, source);\n    };\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Api/context.js");
window.eval("TC.options.defaultUrlProvider = {\n    urlDataFrom: function(paneOptions) {\n        return null;\n    },\n    paneOptionsFrom: function(url) {\n        return null;\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/Api/defaultUrlProvider.js");
window.eval("(function () {\n    var utils = TC.Utils;\n\n    TC.createNode = function (element, paneOptions, parentNode, context) {\n        parentNode = parentNode || TC.nodeFor(element);\n        context = context || utils.contextFor(element) || TC.context();\n\n        var node = new TC.Types.Node(parentNode);\n        utils.bindPane(node, element, paneOptions, context);\n\n        return node;\n    };\n\n    TC.appendNode = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').appendTo(target);\n        return TC.createNode(element, paneOptions, parentNode, context);\n    };\n\n    TC.insertNodeAfter = function (target, paneOptions, parentNode, context) {\n        var element = $('<div/>').insertAfter(target);\n        return TC.createNode(element, paneOptions, parentNode || TC.nodeFor(target), context);\n    };\n\n    TC.nodeFor = function (element) {\n        return element && TC.Utils.extractNode(ko.contextFor($(element)[0]));\n    };\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/Api/nodes.js");
window.eval("ko.bindingHandlers.navigate = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = TC.nodeFor(element);\n        if (!node) return;\n\n        var data = TC.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, navigate, allBindingsAccessor, viewModel);\n\n        function navigate() {\n            return function () {\n                node.navigate(data.value, TC.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/BindingHandlers/navigate.js");
window.eval("ko.bindingHandlers.navigateBack = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var node = TC.nodeFor(element);\n        if (!node) return;\n\n        ko.bindingHandlers.click.init(element, navigateBack, allBindingsAccessor, viewModel);\n\n        function navigateBack() {\n            return function () {\n                node.navigateBack();\n            };\n        }\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/BindingHandlers/navigateBack.js");
window.eval("(function() {\n    ko.bindingHandlers.pane = { init: updateBinding };\n\n    function updateBinding(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        TC.createNode(element, constructPaneOptions(), TC.Utils.extractNode(bindingContext), TC.Utils.extractContext(bindingContext));\n\n        return { controlsDescendantBindings: true };\n\n        function constructPaneOptions() {\n            return TC.Utils.getPaneOptions(ko.utils.unwrapObservable(valueAccessor()), allBindingsAccessor());\n        }\n    }\n})();\n\n//@ sourceURL=tribe://Tribe.Composite/BindingHandlers/pane.js");
window.eval("ko.bindingHandlers.publish = {\n    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var pubsub = TC.nodeFor(element).pane.pubsub;\n        if (!pubsub) return;\n\n        var data = TC.Utils.normaliseBindings(valueAccessor, allBindingsAccessor);\n        var handler = ko.bindingHandlers.validatedClick || ko.bindingHandlers.click;\n        handler.init(element, publishAccessor, allBindingsAccessor, viewModel);\n\n        function publishAccessor() {\n            return function () {\n                pubsub.publish(data.value, TC.Utils.cloneData(data.data));\n            };\n        }\n    }\n};\n//@ sourceURL=tribe://Tribe.Composite/BindingHandlers/publish.js");
window.eval("TC.Loggers.console = function(level, message) {\n    if (window.console && window.console.log)\n        window.console.log(level.toUpperCase() + ': ' + message);\n};\n//@ sourceURL=tribe://Tribe.Composite/Loggers/console.js");
window.eval("Tribe = window.Tribe || {};\nTribe.MessageHub = Tribe.MessageHub || {};\n\nTribe.MessageHub.Client = function (pubsub, hub, publisher) {\n    var self = this;\n\n    var startConnection;\n    \n    hub.client.acceptServerMessage = function (data) {\n        var envelope = JSON.parse(data);\n        envelope.server = true;\n        envelope.sync = true;\n        pubsub.publish(envelope);\n    };\n\n    this.publishToServer = function(channelId, envelope, record) {\n        $.when(startConnection).done(function() {\n            publisher.publishToServer(channelId, envelope, record);\n        });\n    };\n\n    // want to support:\n    // (id)\n    // (id, replay)\n    // (id, { serverEvents, record, replay })\n    this.joinChannel = function (id, replayOrOptions) {\n        var lifetime;\n        var options = replayOrOptions === true ?\n            { replay: true } :\n            (replayOrOptions || { });\n\n        if(!startConnection)\n            startConnection = $.connection.hub.start();\n        \n        $.when(startConnection).done(function () {\n            hub.server.joinChannel(id);\n            if (options.replay)\n                hub.server.replayChannel(id);\n        });\n        relayMessages();\n\n        return {\n            leave: function() {\n                lifetime && lifetime.end();\n                self.leaveChannel(id);\n            }\n        };\n\n        function relayMessages() {\n            if (options.serverEvents && options.serverEvents.length > 0) {\n                lifetime = pubsub.createLifetime();\n                lifetime.subscribe(options.serverEvents, function (data, envelope) {\n                    self.publishToServer(id, envelope, options.record);\n                });\n            }\n        }\n    };\n\n    this.leaveChannel = function (id) {\n        if (startConnection)\n            $.when(startConnection).done(function() {\n                hub.server.leaveChannel(id);\n            });\n    };\n};\n//@ sourceURL=tribe://Tribe.MessageHub/client.js");
window.eval("/*!\n * Based on ASP.NET SignalR JavaScript Library v1.0.0 http://signalr.net/\n * License at https://github.com/SignalR/SignalR/blob/master/LICENSE.md\n */\n\n(function () {\n    if (typeof ($.signalR) !== \"function\")\n        window.console && window.console.log &&\n            window.console.log(\"SignalR: SignalR is not loaded. Please ensure jquery.signalR-x.js is referenced before Tribe.js\");\n\n    window.TMH = {\n        initialise: function (pubsub, url) {\n            initialiseSignalR(url || '/signalr');\n            $.extend(TMH, new Tribe.MessageHub.Client(\n                pubsub,\n                $.connection.hubImplementation,\n                new Tribe.MessageHub.Publisher($.connection.hubImplementation)));\n        },\n        publishToServer: notInitialised,\n        joinChannel: notInitialised,\n        leaveChannel: notInitialised\n    };\n    \n    function notInitialised() {\n        throw \"Tribe.MessageHub must be initialised before use by calling TMH.initialise(pubsub, url)\";\n    }\n\n    function initialiseSignalR(url) {\n        var signalR = $.signalR;\n\n        function makeProxyCallback(hub, callback) {\n            return function () {\n                // Call the client hub method\n                callback.apply(hub, $.makeArray(arguments));\n            };\n        }\n\n        function registerHubProxies(instance, shouldSubscribe) {\n            var key, hub, memberKey, memberValue, subscriptionMethod;\n\n            for (key in instance) {\n                if (instance.hasOwnProperty(key)) {\n                    hub = instance[key];\n\n                    if (!(hub.hubName)) {\n                        // Not a client hub\n                        continue;\n                    }\n\n                    if (shouldSubscribe) {\n                        // We want to subscribe to the hub events\n                        subscriptionMethod = hub.on;\n                    } else {\n                        // We want to unsubscribe from the hub events\n                        subscriptionMethod = hub.off;\n                    }\n\n                    // Loop through all members on the hub and find client hub functions to subscribe/unsubscribe\n                    for (memberKey in hub.client) {\n                        if (hub.client.hasOwnProperty(memberKey)) {\n                            memberValue = hub.client[memberKey];\n\n                            if (!$.isFunction(memberValue)) {\n                                // Not a client hub function\n                                continue;\n                            }\n\n                            subscriptionMethod.call(hub, memberKey, makeProxyCallback(hub, memberValue));\n                        }\n                    }\n                }\n            }\n        }\n\n        $.hubConnection.prototype.createHubProxies = function () {\n            var proxies = {};\n            this.starting(function () {\n                // Register the hub proxies as subscribed\n                // (instance, shouldSubscribe)\n                registerHubProxies(proxies, true);\n\n                this._registerSubscribedHubs();\n            }).disconnected(function () {\n                // Unsubscribe all hub proxies when we \"disconnect\".  This is to ensure that we do not re-add functional call backs.\n                // (instance, shouldSubscribe)\n                registerHubProxies(proxies, false);\n            });\n\n            proxies.hubImplementation = this.createHubProxy('hubImplementation');\n            proxies.hubImplementation.client = {};\n            proxies.hubImplementation.server = {\n                publish: function (channelId, message, record) {\n                    return proxies.hubImplementation.invoke.apply(proxies.hubImplementation, $.merge([\"Publish\"], $.makeArray(arguments)));\n                },\n                joinChannel: function (channelId) {\n                    return proxies.hubImplementation.invoke.apply(proxies.hubImplementation, $.merge([\"JoinChannel\"], $.makeArray(arguments)));\n                },\n                replayChannel: function (channelId) {\n                    return proxies.hubImplementation.invoke.apply(proxies.hubImplementation, $.merge([\"ReplayChannel\"], $.makeArray(arguments)));\n                },\n                leaveChannel: function (channelId) {\n                    return proxies.hubImplementation.invoke.apply(proxies.hubImplementation, $.merge([\"LeaveChannel\"], $.makeArray(arguments)));\n                }\n            };\n\n            return proxies;\n        };\n\n        signalR.hub = $.hubConnection(url, { useDefaultPath: false });\n        $.extend(signalR, signalR.hub.createHubProxies());\n    }\n})();\n\n//@ sourceURL=tribe://Tribe.MessageHub/initialise.js");
window.eval("Tribe = window.Tribe || {};\nTribe.MessageHub = Tribe.MessageHub || {};\n\nTribe.MessageHub.Publisher = function (hub) {\n    var self = this;\n    var queue = [];\n\n    this.publishToServer = function(channelId, envelope, record) {\n        if (!envelope.server) {\n            if (connected())\n                hub.server.publish(channelId, JSON.stringify(envelope), record === true);\n            else\n                queueMessage(channelId, envelope);\n        }\n    };\n    \n    function queueMessage(channelId, envelope) {\n        queue.push(function() {\n            self.publishToServer(channelId, envelope);\n        });\n    }\n    \n    hub.connection.stateChanged(function (change) {\n        if (connected(change.newState))\n            flushQueue();\n    });\n\n    function flushQueue() {\n        if (queue.length > 0) {\n            var oldQueue = queue;\n            queue = [];\n            $.each(oldQueue, function(index, queueItem) {\n                queueItem();\n            });\n        }\n    }\n\n    function connected(state) {\n        return state ?\n            state === $.signalR.connectionState.connected :\n            hub.connection.state === $.signalR.connectionState.connected;\n    }\n};\n//@ sourceURL=tribe://Tribe.MessageHub/Publisher.js");
window.eval("Tribe.PubSub.prototype.joinChannel = function(channelId, replayOrOptions) {\n    TMH.joinChannel(channelId, replayOrOptions);\n};\n\nTribe.PubSub.Lifetime.prototype.joinChannel = function (channelId, replayOrOptions) {\n    var endLifetime = this.end;\n    var channel = TMH.joinChannel(channelId, replayOrOptions);\n\n    this.end = function() {\n        channel.leave();\n        endLifetime();\n    };\n};\n//@ sourceURL=tribe://Tribe.MessageHub/PubSub.extensions.js");
